<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHSFGWQMSN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZHSFGWQMSN');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Founder Admin - VOC Process Editor</title>
    <script src="/config.js"></script>
    <script src="/auth.js"></script>
    <link rel="stylesheet" href="/styles/founder-voc-editor.css">
</head>
<body>
    <!-- Login Overlay -->
    <div id="loginOverlay" class="login-overlay hidden">
        <div class="login-container">
            <div id="loginFormSection">
                <h2>Sign in</h2>
                <p class="login-subtext">
                    Enter your work email and we'll email you a secure magic link.
                </p>
                <input type="email" id="loginEmail" placeholder="you@company.com" autocomplete="email">
                <button id="loginButton" type="button">Send Magic Link</button>
                <div id="loginError" class="login-error"></div>
                <div id="loginSuccess" class="login-success"></div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div id="mainContainer" class="container" style="display: none;">
        <div class="header">
            <div class="header-content">
                <nav class="breadcrumbs">
                    <a href="/founder_admin.html">Founder Admin</a>
                    <span class="breadcrumbs-separator">‚Ä∫</span>
                    <span>VOC Process Editor</span>
                </nav>
                <h1>VOC Process Editor</h1>
                <div class="subtitle">Manage and bulk update Process VOC data.</div>
            </div>
            <div class="founder-meta">
                <span id="founderEmail"></span>
                <button class="logout-btn" onclick="handleLogout()">Logout</button>
            </div>
        </div>

        <div class="content">
            <!-- Status Messages -->
            <div id="statusMessage" class="status-message"></div>

            <!-- Filters Section (Collapsible) -->
            <div class="collapsible-section" id="filtersSection">
                <div class="collapsible-header" onclick="toggleSection('filtersSection')">
                    <h3>üîç Filters</h3>
                    <span class="collapsible-toggle">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="filters">
                        <div class="filter-group">
                            <label>Client Name</label>
                            <input type="text" id="filterClientName" placeholder="Search client_name (partial match)">
                        </div>
                        <div class="filter-group">
                            <label>Project ID</label>
                            <input type="text" id="filterProjectId" placeholder="Search project_id (partial match)">
                        </div>
                        <div class="filter-group">
                            <label>Project Name</label>
                            <input type="text" id="filterProjectName" placeholder="Search project_name (partial match)">
                        </div>
                        <div class="filter-group">
                            <label>Dimension Ref</label>
                            <input type="text" id="filterDimensionRef" placeholder="Search dimension_ref (partial match)">
                        </div>
                        <div class="filter-group">
                            <label>Dimension Name</label>
                            <input type="text" id="filterDimensionName" placeholder="Search dimension_name (partial match)">
                        </div>
                        <div class="filter-group">
                            <label>Data Source</label>
                            <input type="text" id="filterDataSource" placeholder="Search data_source (partial match)">
                        </div>
                        <div class="filter-group">
                            <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
                        </div>
                        <div class="filter-group">
                            <button class="btn btn-secondary" onclick="clearFilters()">Clear</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bulk Edit Section (Collapsible, shown when filters are active) -->
            <div id="bulkEditSection" class="collapsible-section" style="display: none;">
                <div class="collapsible-header" onclick="toggleSection('bulkEditSection')">
                    <h3>‚úèÔ∏è Bulk Edit All Filtered Rows</h3>
                    <span class="collapsible-toggle">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="bulk-edit-card">
                        <p class="bulk-edit-info" id="bulkEditInfo">
                            Update all rows matching current filters
                        </p>
                        
                        <!-- Field Selector -->
                        <div class="field-selector" id="fieldSelector">
                            <h4>Select Fields to Edit:</h4>
                            <div class="field-categories" id="fieldCategories">
                                <!-- Dynamically populated -->
                            </div>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-secondary" onclick="selectAllFields()" style="font-size: 12px; padding: 6px 12px;">Select All</button>
                                <button class="btn btn-secondary" onclick="deselectAllFields()" style="font-size: 12px; padding: 6px 12px;">Deselect All</button>
                            </div>
                        </div>

                        <!-- Dynamic Field Inputs -->
                        <div class="dynamic-fields" id="dynamicFields">
                            <!-- Dynamically populated based on selected fields -->
                        </div>

                        <!-- Action Buttons -->
                        <div style="margin-top: 20px; display: flex; gap: 10px;">
                            <button class="btn btn-primary" onclick="applyBulkEdit()">
                                Update All Filtered Rows
                            </button>
                            <button class="btn btn-danger" onclick="deleteBulkRows()">
                                Delete All Filtered Rows
                            </button>
                            <button class="btn btn-secondary" onclick="clearBulkEdit()">
                                Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Table -->
            <div class="table-container">
                <div class="table-header">
                    <h2>Process VOC Data</h2>
                    <div class="table-actions">
                        <button class="btn btn-primary" onclick="saveBulkEdits()">Save Selected Changes</button>
                        <button class="btn btn-secondary" onclick="selectAll()">Select All</button>
                        <button class="btn btn-secondary" onclick="deselectAll()">Deselect None</button>
                    </div>
                </div>
                <div class="table-wrapper">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th class="checkbox-cell"><input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()"></th>
                                <th class="id-cell">ID</th>
                                <th class="editable-cell">Client Name</th>
                                <th>Project ID</th>
                                <th class="editable-cell">Project Name</th>
                                <th>Dimension Ref</th>
                                <th class="editable-cell">Data Source</th>
                                <th class="editable-cell">Dimension Name</th>
                                <th class="editable-cell">Question Text</th>
                                <th class="text-cell">Value</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                            <tr>
                                <td colspan="10" class="loading">Loading data...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Pagination -->
            <div class="pagination">
                <div class="pagination-info" id="paginationInfo">
                    Showing 0 - 0 of 0 rows
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" onclick="goToFirstPage()">First</button>
                    <button class="pagination-btn" onclick="goToPrevPage()">Previous</button>
                    <span>Page</span>
                    <input type="number" id="pageInput" class="page-input" min="1" value="1" onchange="goToPage()">
                    <span id="totalPagesSpan">of 1</span>
                    <button class="pagination-btn" onclick="goToNextPage()">Next</button>
                    <button class="pagination-btn" onclick="goToLastPage()">Last</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // API Configuration
        const API_BASE_URL = window.APP_CONFIG?.API_BASE_URL || 'http://localhost:8000';
        
        // State
        let currentPage = 1;
        let pageSize = 100;
        let totalPages = 1;
        let totalRows = 0;
        let currentFilters = {
            project_id: '',
            project_name: '',
            dimension_ref: '',
            dimension_name: '',
            client_name: '',
            data_source: ''
        };
        let editedRows = new Map(); // Track edited values: rowId -> {project_name, dimension_name}
        let fieldMetadata = []; // Store field metadata from API
        let selectedFields = new Set(); // Track which fields are selected for bulk edit

        // Authentication - using unified auth.js
        let founderInfo = null;

        function getAuthHeaders() {
            return Auth.getAuthHeaders();
        }

        function renderFounderInfo() {
            if (founderInfo?.email) {
                const emailEl = document.getElementById('founderEmail');
                if (emailEl) {
                    emailEl.textContent = founderInfo.email;
                }
            }
        }

        function initializePage() {
            document.getElementById('loginOverlay').classList.add('hidden');
            document.getElementById('mainContainer').style.display = 'flex';
            const userInfo = Auth.getStoredUserInfo();
            if (userInfo) {
                founderInfo = userInfo;
                renderFounderInfo();
            }
            loadFieldMetadata();
            loadData();
        }

        // Check authentication on page load
        Auth.checkAuth().then(authenticated => {
            if (authenticated) {
                const userInfo = Auth.getStoredUserInfo();
                if (!userInfo?.is_founder) {
                    Auth.showLogin();
                    const errorEl = document.getElementById('loginError');
                    if (errorEl) {
                        errorEl.textContent = 'Access denied: founder privileges required.';
                        errorEl.style.display = 'block';
                    }
                } else {
                    founderInfo = userInfo;
                    initializePage();
                }
            }
        });

        // Listen for auth events
        window.addEventListener('auth:authenticated', (e) => {
            const userInfo = e.detail.user;
            if (userInfo?.is_founder) {
                founderInfo = userInfo;
                initializePage();
            } else {
                Auth.showLogin();
                const errorEl = document.getElementById('loginError');
                if (errorEl) {
                    errorEl.textContent = 'Access denied: founder privileges required.';
                    errorEl.style.display = 'block';
                }
            }
        });

        function handleLogout() {
            Auth.handleLogout();
        }

        // Data Loading
        async function loadData() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '<tr><td colspan="10" class="loading">Loading data...</td></tr>';
            
            try {
                const params = new URLSearchParams();
                if (currentFilters.project_id) {
                    params.append('filter_project_id', currentFilters.project_id);
                }
                if (currentFilters.project_name) {
                    params.append('filter_project_name', currentFilters.project_name);
                }
                if (currentFilters.dimension_ref) {
                    params.append('filter_dimension_ref', currentFilters.dimension_ref);
                }
                if (currentFilters.dimension_name) {
                    params.append('filter_dimension_name', currentFilters.dimension_name);
                }
                if (currentFilters.client_name) {
                    params.append('filter_client_name', currentFilters.client_name);
                }
                if (currentFilters.data_source) {
                    params.append('filter_data_source', currentFilters.data_source);
                }
                params.append('page', currentPage.toString());
                params.append('page_size', pageSize.toString());
                
                const response = await fetch(`${API_BASE_URL}/api/founder-admin/voc-data?${params.toString()}`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        handleLogout();
                        return;
                    }
                    throw new Error(`Failed to load data: ${response.status}`);
                }
                
                const data = await response.json();
                
                totalRows = data.total;
                totalPages = data.total_pages;
                currentPage = data.page;
                
                renderTable(data.items);
                updatePagination();
                updateBulkEditSection();
                
            } catch (error) {
                tbody.innerHTML = `<tr><td colspan="10" style="color: #e74c3c;">Error: ${error.message}</td></tr>`;
                showStatus('Error loading data: ' + error.message, 'error');
            }
        }

        function renderTable(items) {
            const tbody = document.getElementById('tableBody');
            
            if (items.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" class="loading">No data found</td></tr>';
                return;
            }
            
            tbody.innerHTML = items.map(row => {
                const edited = editedRows.get(row.id) || {};
                const projectName = edited.project_name !== undefined ? edited.project_name : (row.project_name || '');
                const dimensionName = edited.dimension_name !== undefined ? edited.dimension_name : (row.dimension_name || '');
                const dataSource = edited.data_source !== undefined ? edited.data_source : (row.data_source || '');
                const clientName = edited.client_name !== undefined ? edited.client_name : (row.client_name || '');
                const questionText = edited.question_text !== undefined ? edited.question_text : (row.question_text || '');
                
                return `
                    <tr data-row-id="${row.id}">
                        <td class="checkbox-cell">
                            <input type="checkbox" class="row-checkbox" data-row-id="${row.id}" 
                                   ${editedRows.has(row.id) ? 'checked' : ''}>
                        </td>
                        <td class="id-cell">${row.id}</td>
                        <td class="editable-cell">
                            <input type="text" 
                                   class="editable-input client-name-input" 
                                   data-row-id="${row.id}"
                                   value="${escapeHtml(clientName)}"
                                   onchange="markRowEdited(${row.id}, 'client_name', this.value)">
                        </td>
                        <td>${row.project_id || ''}</td>
                        <td class="editable-cell">
                            <input type="text" 
                                   class="editable-input project-name-input" 
                                   data-row-id="${row.id}"
                                   value="${escapeHtml(projectName)}"
                                   onchange="markRowEdited(${row.id}, 'project_name', this.value)">
                        </td>
                        <td>${escapeHtml(row.dimension_ref || '')}</td>
                        <td class="editable-cell">
                            <input type="text" 
                                   class="editable-input data-source-input" 
                                   data-row-id="${row.id}"
                                   value="${escapeHtml(dataSource)}"
                                   onchange="markRowEdited(${row.id}, 'data_source', this.value)">
                        </td>
                        <td class="editable-cell">
                            <input type="text" 
                                   class="editable-input dimension-name-input" 
                                   data-row-id="${row.id}"
                                   value="${escapeHtml(dimensionName)}"
                                   onchange="markRowEdited(${row.id}, 'dimension_name', this.value)">
                        </td>
                        <td class="editable-cell">
                            <input type="text" 
                                   class="editable-input question-text-input" 
                                   data-row-id="${row.id}"
                                   value="${escapeHtml(questionText)}"
                                   onchange="markRowEdited(${row.id}, 'question_text', this.value)">
                        </td>
                        <td class="text-cell" title="${escapeHtml(row.value || '')}">${escapeHtml((row.value || '').substring(0, 50))}</td>
                    </tr>
                `;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function markRowEdited(rowId, field, value) {
            if (!editedRows.has(rowId)) {
                editedRows.set(rowId, {});
            }
            const edited = editedRows.get(rowId);
            edited[field] = value;
            
            // Check checkbox
            const checkbox = document.querySelector(`.row-checkbox[data-row-id="${rowId}"]`);
            if (checkbox) {
                checkbox.checked = true;
            }
        }

        // Filters
        function applyFilters() {
            currentFilters.project_id = document.getElementById('filterProjectId').value.trim();
            currentFilters.project_name = document.getElementById('filterProjectName').value.trim();
            currentFilters.dimension_ref = document.getElementById('filterDimensionRef').value.trim();
            currentFilters.dimension_name = document.getElementById('filterDimensionName').value.trim();
            currentFilters.client_name = document.getElementById('filterClientName').value.trim();
            currentFilters.data_source = document.getElementById('filterDataSource').value.trim();
            currentPage = 1;
            editedRows.clear();
            loadData();
        }

        function clearFilters() {
            document.getElementById('filterProjectId').value = '';
            document.getElementById('filterProjectName').value = '';
            document.getElementById('filterDimensionRef').value = '';
            document.getElementById('filterDimensionName').value = '';
            document.getElementById('filterClientName').value = '';
            document.getElementById('filterDataSource').value = '';
            currentFilters.project_id = '';
            currentFilters.project_name = '';
            currentFilters.dimension_ref = '';
            currentFilters.dimension_name = '';
            currentFilters.client_name = '';
            currentFilters.data_source = '';
            currentPage = 1;
            editedRows.clear();
            clearBulkEdit();
            loadData();
        }

        // Selection
        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllCheckbox').checked;
            document.querySelectorAll('.row-checkbox').forEach(cb => {
                cb.checked = selectAll;
            });
        }

        function selectAll() {
            document.getElementById('selectAllCheckbox').checked = true;
            toggleSelectAll();
        }

        function deselectAll() {
            document.getElementById('selectAllCheckbox').checked = false;
            toggleSelectAll();
        }

        // Bulk Save
        async function saveBulkEdits() {
            if (editedRows.size === 0) {
                showStatus('No changes to save', 'error');
                return;
            }

            const checkedBoxes = Array.from(document.querySelectorAll('.row-checkbox:checked'));
            if (checkedBoxes.length === 0) {
                showStatus('Please select at least one row to save', 'error');
                return;
            }

            const updates = [];
            checkedBoxes.forEach(checkbox => {
                const rowId = parseInt(checkbox.getAttribute('data-row-id'));
                const edited = editedRows.get(rowId);
                if (edited) {
                    updates.push({
                        id: rowId,
                        project_name: edited.project_name !== undefined ? edited.project_name : null,
                        dimension_name: edited.dimension_name !== undefined ? edited.dimension_name : null,
                        data_source: edited.data_source !== undefined ? edited.data_source : null,
                        client_name: edited.client_name !== undefined ? edited.client_name : null,
                        question_text: edited.question_text !== undefined ? edited.question_text : null
                    });
                }
            });

            if (updates.length === 0) {
                showStatus('No valid changes to save', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/founder-admin/voc-data/bulk-update`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ updates })
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        handleLogout();
                        return;
                    }
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to save changes');
                }

                const result = await response.json();
                showStatus(`Successfully updated ${result.updated_count} row(s)`, 'success');
                
                // Clear edited rows and reload
                editedRows.clear();
                loadData();

            } catch (error) {
                showStatus('Error saving changes: ' + error.message, 'error');
            }
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message ${type} show`;
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 5000);
        }

        // Pagination
        function updatePagination() {
            const start = totalRows === 0 ? 0 : (currentPage - 1) * pageSize + 1;
            const end = Math.min(currentPage * pageSize, totalRows);
            document.getElementById('paginationInfo').textContent = 
                `Showing ${start} - ${end} of ${totalRows} rows`;
            
            document.getElementById('totalPagesSpan').textContent = `of ${totalPages}`;
            document.getElementById('pageInput').value = currentPage;
        }

        function goToPage() {
            const page = parseInt(document.getElementById('pageInput').value);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                loadData();
            }
        }

        function goToFirstPage() {
            currentPage = 1;
            loadData();
        }

        function goToPrevPage() {
            if (currentPage > 1) {
                currentPage--;
                loadData();
            }
        }

        function goToNextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                loadData();
            }
        }

        function goToLastPage() {
            currentPage = totalPages;
            loadData();
        }

        // Bulk Edit Functions
        function updateBulkEditSection() {
            const hasFilters = currentFilters.project_id || currentFilters.project_name || currentFilters.dimension_ref || currentFilters.dimension_name || currentFilters.client_name || currentFilters.data_source;
            const bulkSection = document.getElementById('bulkEditSection');
            const bulkInfo = document.getElementById('bulkEditInfo');
            
            if (hasFilters) {
                bulkSection.style.display = 'block';
                const filterText = [];
                if (currentFilters.project_id) {
                    filterText.push(`Project ID: ${currentFilters.project_id}`);
                }
                if (currentFilters.project_name) {
                    filterText.push(`Project Name: ${currentFilters.project_name}`);
                }
                if (currentFilters.dimension_ref) {
                    filterText.push(`Dimension Ref: ${currentFilters.dimension_ref}`);
                }
                if (currentFilters.dimension_name) {
                    filterText.push(`Dimension Name: ${currentFilters.dimension_name}`);
                }
                if (currentFilters.client_name) {
                    filterText.push(`Client Name: ${currentFilters.client_name}`);
                }
                if (currentFilters.data_source) {
                    filterText.push(`Data Source: ${currentFilters.data_source}`);
                }
                bulkInfo.textContent = `Will update all rows matching: ${filterText.join(', ')} (${totalRows} rows)`;
            } else {
                bulkSection.style.display = 'none';
            }
        }

        async function applyBulkEdit() {
            if (!currentFilters.project_id && !currentFilters.project_name && !currentFilters.dimension_ref && !currentFilters.dimension_name && !currentFilters.client_name && !currentFilters.data_source) {
                showStatus('Please apply filters before bulk editing', 'error');
                return;
            }
            
            // Collect updates from all selected fields
            const updates = {};
            let hasUpdates = false;
            
            selectedFields.forEach(fieldName => {
                const input = document.getElementById(`bulk_${fieldName}`);
                if (input) {
                    let value = input.value.trim();
                    if (value) {
                        // Handle datetime-local inputs - convert to ISO format
                        const fieldMeta = fieldMetadata.find(f => f.name === fieldName);
                        if (fieldMeta && fieldMeta.type === 'datetime' && input.type === 'datetime-local') {
                            // datetime-local format is "YYYY-MM-DDTHH:mm" - convert to ISO format
                            // Add seconds if not present
                            if (value && value.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/)) {
                                value = value + ':00';
                            }
                            // Convert to ISO format with timezone (backend expects ISO format)
                            // datetime.fromisoformat can handle "YYYY-MM-DDTHH:mm:ss" format
                        }
                        updates[fieldName] = value;
                        hasUpdates = true;
                    }
                }
            });
            
            if (!hasUpdates) {
                showStatus('Please provide at least one value to update', 'error');
                return;
            }
            
            if (!confirm(`This will update ${totalRows} row(s). Are you sure?`)) {
                return;
            }
            
            try {
                const params = new URLSearchParams();
                if (currentFilters.project_id) {
                    params.append('filter_project_id', currentFilters.project_id);
                }
                if (currentFilters.project_name) {
                    params.append('filter_project_name', currentFilters.project_name);
                }
                if (currentFilters.dimension_ref) {
                    params.append('filter_dimension_ref', currentFilters.dimension_ref);
                }
                if (currentFilters.dimension_name) {
                    params.append('filter_dimension_name', currentFilters.dimension_name);
                }
                if (currentFilters.client_name) {
                    params.append('filter_client_name', currentFilters.client_name);
                }
                if (currentFilters.data_source) {
                    params.append('filter_data_source', currentFilters.data_source);
                }
                
                const response = await fetch(`${API_BASE_URL}/api/founder-admin/voc-data/bulk-update-filtered?${params.toString()}`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ updates })
                });
                
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        handleLogout();
                        return;
                    }
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to update rows');
                }
                
                const result = await response.json();
                showStatus(`Successfully updated ${result.updated_count} row(s)`, 'success');
                
                // Clear bulk edit fields and reload data
                clearBulkEdit();
                loadData();
                
            } catch (error) {
                showStatus('Error updating rows: ' + error.message, 'error');
            }
        }

        function clearBulkEdit() {
            // Clear all dynamic field inputs
            selectedFields.forEach(fieldName => {
                const input = document.getElementById(`bulk_${fieldName}`);
                if (input) input.value = '';
            });
            // Deselect all fields
            deselectAllFields();
        }

        async function deleteBulkRows() {
            if (!currentFilters.project_id && !currentFilters.project_name && !currentFilters.dimension_ref && !currentFilters.dimension_name && !currentFilters.client_name && !currentFilters.data_source) {
                showStatus('Please apply filters before deleting rows', 'error');
                return;
            }
            
            // Double confirmation for deletion
            const confirmMessage = `‚ö†Ô∏è WARNING: This will permanently delete ${totalRows} row(s). This action cannot be undone!\n\nAre you absolutely sure you want to proceed?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Second confirmation
            const secondConfirm = prompt(`Type "DELETE" to confirm deletion of ${totalRows} row(s):`);
            if (secondConfirm !== 'DELETE') {
                showStatus('Deletion cancelled', 'error');
                return;
            }
            
            try {
                const params = new URLSearchParams();
                if (currentFilters.project_id) {
                    params.append('filter_project_id', currentFilters.project_id);
                }
                if (currentFilters.project_name) {
                    params.append('filter_project_name', currentFilters.project_name);
                }
                if (currentFilters.dimension_ref) {
                    params.append('filter_dimension_ref', currentFilters.dimension_ref);
                }
                if (currentFilters.dimension_name) {
                    params.append('filter_dimension_name', currentFilters.dimension_name);
                }
                if (currentFilters.client_name) {
                    params.append('filter_client_name', currentFilters.client_name);
                }
                if (currentFilters.data_source) {
                    params.append('filter_data_source', currentFilters.data_source);
                }
                
                const response = await fetch(`${API_BASE_URL}/api/founder-admin/voc-data/bulk-delete?${params.toString()}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        handleLogout();
                        return;
                    }
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to delete rows');
                }
                
                const result = await response.json();
                showStatus(`Successfully deleted ${result.updated_count} row(s)`, 'success');
                
                // Reload data to show updated results
                loadData();
                
            } catch (error) {
                showStatus('Error deleting rows: ' + error.message, 'error');
            }
        }

        // Enter key handlers
        document.addEventListener('DOMContentLoaded', () => {
            const emailInput = document.getElementById('loginEmail');
            const passwordInput = document.getElementById('loginPassword');
            
            if (emailInput) {
                emailInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') handleLogin();
                });
            }
            
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') handleLogin();
                });
            }
        });

        // Collapsible Section Toggle
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('collapsed');
        }

        // Load Field Metadata
        async function loadFieldMetadata() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/founder-admin/field-metadata`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load field metadata');
                }
                
                const data = await response.json();
                fieldMetadata = data.fields;
                renderFieldSelector();
                
            } catch (error) {
                console.error('Error loading field metadata:', error);
            }
        }

        // Render Field Selector
        function renderFieldSelector() {
            const container = document.getElementById('fieldCategories');
            const categories = {};
            
            // Group fields by category
            fieldMetadata.forEach(field => {
                if (!categories[field.category]) {
                    categories[field.category] = [];
                }
                categories[field.category].push(field);
            });
            
            // Render categories
            container.innerHTML = Object.entries(categories).map(([category, fields]) => `
                <div class="field-category">
                    <h5>${category}</h5>
                    ${fields.map(field => `
                        <div class="field-checkbox">
                            <input type="checkbox" 
                                   id="field_${field.name}" 
                                   value="${field.name}"
                                   onchange="toggleFieldInput('${field.name}', this.checked)">
                            <label for="field_${field.name}">
                                ${field.name}
                                <span class="field-type-badge ${field.type}">${field.type}</span>
                            </label>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }

        // Toggle Field Input Visibility
        function toggleFieldInput(fieldName, show) {
            if (show) {
                selectedFields.add(fieldName);
                showFieldInput(fieldName);
            } else {
                selectedFields.delete(fieldName);
                hideFieldInput(fieldName);
            }
        }

        // Show Field Input
        function showFieldInput(fieldName) {
            const fieldMeta = fieldMetadata.find(f => f.name === fieldName);
            if (!fieldMeta) return;
            
            const container = document.getElementById('dynamicFields');
            const existing = document.getElementById(`dynamic_field_${fieldName}`);
            if (existing) {
                existing.classList.add('visible');
                return;
            }
            
            let inputHtml = '';
            const placeholder = fieldMeta.nullable ? 'Leave empty to keep existing' : 'Required';
            
            if (fieldMeta.type === 'integer') {
                inputHtml = `<input type="number" id="bulk_${fieldName}" placeholder="${placeholder}">`;
            } else if (fieldMeta.type === 'datetime') {
                // datetime-local format: YYYY-MM-DDTHH:mm
                inputHtml = `<input type="datetime-local" id="bulk_${fieldName}" placeholder="${placeholder}" step="1">`;
            } else if (fieldMeta.type === 'text') {
                inputHtml = `<textarea id="bulk_${fieldName}" rows="2" placeholder="${placeholder}"></textarea>`;
            } else if (fieldMeta.type === 'json') {
                inputHtml = `<textarea id="bulk_${fieldName}" rows="3" placeholder='${placeholder} (JSON format)'></textarea>`;
            } else {
                inputHtml = `<input type="text" id="bulk_${fieldName}" placeholder="${placeholder}">`;
            }
            
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'filter-group dynamic-field visible';
            fieldDiv.id = `dynamic_field_${fieldName}`;
            fieldDiv.innerHTML = `
                <label>
                    ${fieldName}
                    <span class="field-type-badge ${fieldMeta.type}">${fieldMeta.type}</span>
                </label>
                ${inputHtml}
            `;
            
            container.appendChild(fieldDiv);
        }

        // Hide Field Input
        function hideFieldInput(fieldName) {
            const fieldDiv = document.getElementById(`dynamic_field_${fieldName}`);
            if (fieldDiv) {
                fieldDiv.classList.remove('visible');
                // Clear the input value
                const input = document.getElementById(`bulk_${fieldName}`);
                if (input) input.value = '';
            }
        }

        // Select/Deselect All Fields
        function selectAllFields() {
            fieldMetadata.forEach(field => {
                const checkbox = document.getElementById(`field_${field.name}`);
                if (checkbox) {
                    checkbox.checked = true;
                    toggleFieldInput(field.name, true);
                }
            });
        }

        function deselectAllFields() {
            fieldMetadata.forEach(field => {
                const checkbox = document.getElementById(`field_${field.name}`);
                if (checkbox) {
                    checkbox.checked = false;
                    toggleFieldInput(field.name, false);
                }
            });
        }

        // Initialization is handled by Auth.checkAuth() above
    </script>
</body>
</html>

