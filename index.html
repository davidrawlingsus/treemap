<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHSFGWQMSN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZHSFGWQMSN');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#667eea">
    <title>Vizualizd | Marketably.ai</title>
    
    <!-- Lato font for marketing site header -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&display=swap" rel="stylesheet">
    
    <!-- Marketing site styles -->
    <link rel="stylesheet" href="/styles.css">
    
    <!-- App styles (extracted from inline) -->
    <link rel="stylesheet" href="/styles/app.css">
    <link rel="stylesheet" href="/styles/ads.css">
    
    <script src="/config.js"></script>
    <script src="/auth.js"></script>
    <!-- Image loading monitor for debugging intermittent Vercel Blob issues -->
    <script src="/js/utils/image-monitor.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
    <!-- Masonry layout for Ads grid -->
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
    <!-- Tiptap WYSIWYG Editor - will be loaded as ES module when needed -->
    
    <!-- Prompt Engineering Rendering Modules (for AI Expert feature) -->
    <script src="/js/founder-admin-common.js"></script>
    <script src="/js/prompt-engineering/state.js"></script>
    <script src="/js/prompt-engineering/rendering/markdown-converter.js"></script>
    <script src="/js/prompt-engineering/rendering/streaming-renderer.js"></script>
    <script src="/js/prompt-engineering/rendering/action-renderer.js"></script>
    <script src="/js/client-prompt-renderer.js"></script>
    <script src="/js/client-prompt-api.js"></script>
    
    <!-- Prompt Engineering CSS (for AI Expert feature) -->
    <link rel="stylesheet" href="/styles/prompt-engineering/common.css">
    <link rel="stylesheet" href="/styles/prompt-engineering/slideout.css">
    <link rel="stylesheet" href="/styles/prompt-engineering/idea-cards.css">
    <link rel="stylesheet" href="/styles/prompt-engineering/results.css">
    
    <!-- Utility modules (ES modules) -->
    <script type="module">
        import { adjustBrightness } from '/js/utils/colors.js';
        import { getStateCode, stateNameToCode, fipsToStateCode, getDimensionDisplayName as formatGetDimensionDisplayName, highlightSearchTerms as formatHighlightSearchTerms, toPascalCase as formatToPascalCase } from '/js/utils/format.js';
        import { debounce, escapeHtml, escapeHtmlForAttribute } from '/js/utils/dom.js';
        import { 
            saveState as storageSaveState, 
            loadState as storageLoadState,
            getFilterStorageKey as storageGetFilterStorageKey,
            loadFiltersFromStorage as storageLoadFiltersFromStorage,
            saveFiltersToStorage as storageSaveFiltersToStorage,
            getFavouritesStorageKey as storageGetFavouritesStorageKey,
            getFavourites as storageGetFavourites,
            saveFavourites as storageSaveFavourites,
            getTagColors,
            setTagColor,
            getTagColor,
            TAG_COLORS_STORAGE_KEY,
            TAG_COLOR_MAP,
            STATE_STORAGE_KEY
        } from '/js/services/storage.js';
        import {
            getToken as authServiceGetToken,
            getHeaders as authServiceGetHeaders,
            getHeadersSafe as authServiceGetHeadersSafe,
            isAuthAvailable as authServiceIsAuthAvailable,
            getStoredUserInfo as authServiceGetStoredUserInfo
        } from '/js/services/auth-service.js';
        import {
            getBaseUrl as apiConfigGetBaseUrl,
            API_BASE_URL as apiConfigAPI_BASE_URL
        } from '/js/services/api-config.js';
        import {
            loadClients as clientsApiLoadClients
        } from '/js/services/api-clients.js';
        import {
            loadProjects as dataSourcesApiLoadProjects,
            loadSources as dataSourcesApiLoadSources
        } from '/js/services/api-data-sources.js';
        import {
            loadVocData as vocDataApiLoadVocData,
            loadDimensionNames as vocDataApiLoadDimensionNames,
            loadQuestions as vocDataApiLoadQuestions
        } from '/js/services/api-voc-data.js';
        import {
            loadInsights as insightsApiLoadInsights,
            createInsight as insightsApiCreateInsight,
            updateInsight as insightsApiUpdateInsight,
            deleteInsight as insightsApiDeleteInsight
        } from '/js/services/api-insights.js';
        import {
            getCurrentClientId as appStateGetCurrentClientId,
            setCurrentClientId as appStateSetCurrentClientId,
            getCurrentProjectName as appStateGetCurrentProjectName,
            setCurrentProjectName as appStateSetCurrentProjectName,
            getCurrentDataSourceId as appStateGetCurrentDataSourceId,
            setCurrentDataSourceId as appStateSetCurrentDataSourceId,
            getCurrentQuestionRefKey as appStateGetCurrentQuestionRefKey,
            setCurrentQuestionRefKey as appStateSetCurrentQuestionRefKey,
            getState as appStateGetState,
            setState as appStateSetState,
            resetState as appStateResetState
        } from '/js/state/app-state.js';
        import {
            getRawData as vizStateGetRawData,
            setRawData as vizStateSetRawData,
            getFullRawData as vizStateGetFullRawData,
            setFullRawData as vizStateSetFullRawData,
            getDimensionFilteredData as vizStateGetDimensionFilteredData,
            setDimensionFilteredData as vizStateSetDimensionFilteredData,
            getHierarchyData as vizStateGetHierarchyData,
            setHierarchyData as vizStateSetHierarchyData,
            getVisualizationState as vizStateGetVisualizationState,
            setVisualizationState as vizStateSetVisualizationState,
            resetVisualizationState as vizStateResetVisualizationState
        } from '/js/state/visualization-state.js';
        import {
            getFilterRules as filterStateGetFilterRules,
            setFilterRules as filterStateSetFilterRules,
            getDimensionFilters as filterStateGetDimensionFilters,
            setDimensionFilters as filterStateSetDimensionFilters,
            getDimensionFilter as filterStateGetDimensionFilter,
            setDimensionFilter as filterStateSetDimensionFilter,
            clearDimensionFilter as filterStateClearDimensionFilter,
            clearAllDimensionFilters as filterStateClearAllDimensionFilters,
            getAvailableMetadataFields as filterStateGetAvailableMetadataFields,
            setAvailableMetadataFields as filterStateSetAvailableMetadataFields,
            getCurrentMetadataField as filterStateGetCurrentMetadataField,
            setCurrentMetadataField as filterStateSetCurrentMetadataField,
            getFilterState as filterStateGetFilterState,
            setFilterState as filterStateSetFilterState,
            resetFilterState as filterStateResetFilterState
        } from '/js/state/filter-state.js';
        import {
            getAvailableQuestions as availableOptionsGetAvailableQuestions,
            setAvailableQuestions as availableOptionsSetAvailableQuestions,
            getAvailableCategories as availableOptionsGetAvailableCategories,
            setAvailableCategories as availableOptionsSetAvailableCategories,
            getAvailableTopics as availableOptionsGetAvailableTopics,
            setAvailableTopics as availableOptionsSetAvailableTopics,
            getAvailableLocations as availableOptionsGetAvailableLocations,
            setAvailableLocations as availableOptionsSetAvailableLocations,
            getAvailableOptionsState as availableOptionsGetAvailableOptionsState,
            setAvailableOptionsState as availableOptionsSetAvailableOptionsState,
            resetAvailableOptionsState as availableOptionsResetAvailableOptionsState
        } from '/js/state/available-options-state.js';
        import {
            getCurrentView as viewStateGetCurrentView,
            setCurrentView as viewStateSetCurrentView,
            getViewStack as viewStateGetViewStack,
            setViewStack as viewStateSetViewStack,
            pushView as viewStatePushView,
            popView as viewStatePopView,
            clearViewStack as viewStateClearViewStack,
            getCurrentSourceFormat as viewStateGetCurrentSourceFormat,
            setCurrentSourceFormat as viewStateSetCurrentSourceFormat,
            getViewState as viewStateGetViewState,
            setViewState as viewStateSetViewState,
            resetViewState as viewStateResetViewState
        } from '/js/state/view-state.js';
        import {
            getAccessibleClients as authStateGetAccessibleClients,
            setAccessibleClients as authStateSetAccessibleClients,
            getAccessibleClientIds as authStateGetAccessibleClientIds,
            setAccessibleClientIds as authStateSetAccessibleClientIds,
            addAccessibleClientId as authStateAddAccessibleClientId,
            removeAccessibleClientId as authStateRemoveAccessibleClientId,
            hasAccessibleClientId as authStateHasAccessibleClientId,
            clearAccessibleClientIds as authStateClearAccessibleClientIds,
            getAuthenticatedUser as authStateGetAuthenticatedUser,
            setAuthenticatedUser as authStateSetAuthenticatedUser,
            getAuthState as authStateGetAuthState,
            setAuthState as authStateSetAuthState,
            resetAuthState as authStateResetAuthState
        } from '/js/state/auth-state.js';
        import {
            getAllClients as apiCacheGetAllClients,
            setAllClients as apiCacheSetAllClients,
            getClientProjects as apiCacheGetClientProjects,
            setClientProjects as apiCacheSetClientProjects,
            getClientSources as apiCacheGetClientSources,
            setClientSources as apiCacheSetClientSources,
            getDimensionNamesMap as apiCacheGetDimensionNamesMap,
            setDimensionNamesMap as apiCacheSetDimensionNamesMap,
            getDimensionName as apiCacheGetDimensionName,
            setDimensionName as apiCacheSetDimensionName,
            getQuestionTypesMap as apiCacheGetQuestionTypesMap,
            setQuestionTypesMap as apiCacheSetQuestionTypesMap,
            getQuestionType as apiCacheGetQuestionType,
            setQuestionType as apiCacheSetQuestionType,
            getApiCacheState as apiCacheGetApiCacheState,
            setApiCacheState as apiCacheSetApiCacheState,
            resetApiCacheState as apiCacheResetApiCacheState
        } from '/js/state/api-cache-state.js';
        import {
            toggleChart as uiControllerToggleChart,
            toggleTreemap as uiControllerToggleTreemap,
            toggleSettingsPanel as uiControllerToggleSettingsPanel,
            toggleInsightsPanel as uiControllerToggleInsightsPanel,
            toggleInsightsAddDropdown as uiControllerToggleInsightsAddDropdown,
            closeInsightsAddDropdown as uiControllerCloseInsightsAddDropdown
        } from '/js/controllers/ui-controller.js';
        import {
            getInsightsCurrentClientId as insightsStateGetInsightsCurrentClientId,
            setInsightsCurrentClientId as insightsStateSetInsightsCurrentClientId,
            getInsightsCurrentInsightId as insightsStateGetInsightsCurrentInsightId,
            setInsightsCurrentInsightId as insightsStateSetInsightsCurrentInsightId,
            getInsightsAllInsights as insightsStateGetInsightsAllInsights,
            setInsightsAllInsights as insightsStateSetInsightsAllInsights,
            getAllInsights as insightsStateGetAllInsights,
            setAllInsights as insightsStateSetAllInsights,
            getInsightsFilters as insightsStateGetInsightsFilters,
            setInsightsFilters as insightsStateSetInsightsFilters,
            getInsightsCurrentFilters as insightsStateGetInsightsCurrentFilters,
            setInsightsCurrentFilters as insightsStateSetInsightsCurrentFilters,
            getInsightsCurrentSortBy as insightsStateGetInsightsCurrentSortBy,
            setInsightsCurrentSortBy as insightsStateSetInsightsCurrentSortBy,
            getInsightsSortBy as insightsStateGetInsightsSortBy,
            setInsightsSortBy as insightsStateSetInsightsSortBy,
            getInsightsSortOrder as insightsStateGetInsightsSortOrder,
            setInsightsSortOrder as insightsStateSetInsightsSortOrder,
            getInsightsSearchTerm as insightsStateGetInsightsSearchTerm,
            setInsightsSearchTerm as insightsStateSetInsightsSearchTerm,
            getInsightsCurrentInsightEditor as insightsStateGetInsightsCurrentInsightEditor,
            setInsightsCurrentInsightEditor as insightsStateSetInsightsCurrentInsightEditor,
            getInsightsAutoFilter as insightsStateGetInsightsAutoFilter,
            setInsightsAutoFilter as insightsStateSetInsightsAutoFilter,
            getInsightsState as insightsStateGetInsightsState,
            setInsightsState as insightsStateSetInsightsState,
            resetInsightsState as insightsStateResetInsightsState
        } from '/js/state/insights-state.js';
        import {
            getHistoryCurrentClientId as historyStateGetHistoryCurrentClientId,
            setHistoryCurrentClientId as historyStateSetHistoryCurrentClientId,
            getHistoryAllActions as historyStateGetHistoryAllActions,
            setHistoryAllActions as historyStateSetHistoryAllActions,
            getHistorySearchTerm as historyStateGetHistorySearchTerm,
            setHistorySearchTerm as historyStateSetHistorySearchTerm,
            getSelectedHistoryIds as historyStateGetSelectedHistoryIds,
            setSelectedHistoryIds as historyStateSetSelectedHistoryIds,
            addSelectedHistoryId as historyStateAddSelectedHistoryId,
            removeSelectedHistoryId as historyStateRemoveSelectedHistoryId,
            hasSelectedHistoryId as historyStateHasSelectedHistoryId,
            clearSelectedHistoryIds as historyStateClearSelectedHistoryIds,
            getHistoryCurrentSortBy as historyStateGetHistoryCurrentSortBy,
            setHistoryCurrentSortBy as historyStateSetHistoryCurrentSortBy,
            getHistorySortOrder as historyStateGetHistorySortOrder,
            setHistorySortOrder as historyStateSetHistorySortOrder,
            getHistoryInitialized as historyStateGetHistoryInitialized,
            setHistoryInitialized as historyStateSetHistoryInitialized,
            getHistoryState as historyStateGetHistoryState,
            setHistoryState as historyStateSetHistoryState,
            resetHistoryState as historyStateResetHistoryState
        } from '/js/state/history-state.js';
        import {
            getSettingsInitialized as settingsStateGetSettingsInitialized,
            setSettingsInitialized as settingsStateSetSettingsInitialized,
            getSettingsCurrentClientId as settingsStateGetSettingsCurrentClientId,
            setSettingsCurrentClientId as settingsStateSetSettingsCurrentClientId,
            resetSettingsState as settingsStateResetSettingsState
        } from '/js/state/settings-state.js';
        import {
            fetchClientSettings as settingsApiFetchClientSettings,
            updateClientSettings as settingsApiUpdateClientSettings
        } from '/js/services/api-settings.js';
        import {
            getCurrentFilterType as uiInteractionGetCurrentFilterType,
            setCurrentFilterType as uiInteractionSetCurrentFilterType,
            getCurrentFilterSelections as uiInteractionGetCurrentFilterSelections,
            setCurrentFilterSelections as uiInteractionSetCurrentFilterSelections,
            addCurrentFilterSelection as uiInteractionAddCurrentFilterSelection,
            removeCurrentFilterSelection as uiInteractionRemoveCurrentFilterSelection,
            clearCurrentFilterSelections as uiInteractionClearCurrentFilterSelections,
            getCurrentFilterSearchTerm as uiInteractionGetCurrentFilterSearchTerm,
            setCurrentFilterSearchTerm as uiInteractionSetCurrentFilterSearchTerm,
            getCurrentVerbatimsData as uiInteractionGetCurrentVerbatimsData,
            setCurrentVerbatimsData as uiInteractionSetCurrentVerbatimsData,
            getCurrentTopicName as uiInteractionGetCurrentTopicName,
            setCurrentTopicName as uiInteractionSetCurrentTopicName,
            getCurrentCategoryName as uiInteractionGetCurrentCategoryName,
            setCurrentCategoryName as uiInteractionSetCurrentCategoryName,
            getCurrentEditingRefKey as uiInteractionGetCurrentEditingRefKey,
            setCurrentEditingRefKey as uiInteractionSetCurrentEditingRefKey,
            getSelectedInsightIds as uiInteractionGetSelectedInsightIds,
            setSelectedInsightIds as uiInteractionSetSelectedInsightIds,
            addSelectedInsightId as uiInteractionAddSelectedInsightId,
            removeSelectedInsightId as uiInteractionRemoveSelectedInsightId,
            clearSelectedInsightIds as uiInteractionClearSelectedInsightIds,
            getCurrentResizeHeader as uiInteractionGetCurrentResizeHeader,
            setCurrentResizeHeader as uiInteractionSetCurrentResizeHeader,
            getCurrentContextData as uiInteractionGetCurrentContextData,
            setCurrentContextData as uiInteractionSetCurrentContextData,
            getUiInteractionState as uiInteractionGetUiInteractionState,
            setUiInteractionState as uiInteractionSetUiInteractionState,
            resetUiInteractionState as uiInteractionResetUiInteractionState
        } from '/js/state/ui-interaction-state.js';
        import {
            DIMENSION_OPTIONS as dimensionConfigDIMENSION_OPTIONS,
            getDimensionOptions as dimensionConfigGetDimensionOptions,
            hasDimensionOption as dimensionConfigHasDimensionOption,
            addDimensionOption as dimensionConfigAddDimensionOption
        } from '/js/config/dimension-config.js';
        import {
            CATEGORY_COLORS as colorSchemesCATEGORY_COLORS,
            getColorSchemes as colorSchemesGetColorSchemes
        } from '/js/config/color-schemes.js';
        import {
            renderInsights as insightsRendererRenderInsights
        } from '/js/renderers/insights-renderer.js';
        import {
            renderHistoryTable as historyRendererRenderHistoryTable
        } from '/js/renderers/history-renderer.js';
        import {
            renderVerbatims as verbatimsRendererRenderVerbatims
        } from '/js/renderers/verbatims-renderer.js';
        import {
            renderTreemap as treemapRendererRenderTreemap
        } from '/js/renderers/treemap-renderer.js';
        import {
            renderBarChart as chartRendererRenderBarChart,
            renderTopicsChart as chartRendererRenderTopicsChart,
            renderHorizontalBarChart as chartRendererRenderHorizontalBarChart,
            toggleCategory as chartRendererToggleCategory,
            generateCategoryColorPalette as chartRendererGenerateCategoryColorPalette,
            adjustColorLightness as chartRendererAdjustColorLightness,
            processBarChartData as chartRendererProcessBarChartData,
            processTopicsData as chartRendererProcessTopicsData
        } from '/js/renderers/chart-renderer.js';
        import {
            initAdsPage as adsControllerInitAdsPage,
            renderAdsPage as adsControllerRenderAdsPage
        } from '/js/controllers/ads-controller.js';
        import {
            clearAdsState as adsStateClearAdsState
        } from '/js/state/ads-state.js';
        
        // Make color schemes config available globally
        window.colorSchemesCATEGORY_COLORS = colorSchemesCATEGORY_COLORS;
        window.colorSchemesGetColorSchemes = colorSchemesGetColorSchemes;
        
        // Make utilities available globally for backward compatibility
        window.adjustBrightness = adjustBrightness;
        window.getStateCode = getStateCode;
        window.stateNameToCode = stateNameToCode;
        window.fipsToStateCode = fipsToStateCode;
        window.getDimensionDisplayName = formatGetDimensionDisplayName;
        window.highlightSearchTerms = formatHighlightSearchTerms;
        window.toPascalCase = formatToPascalCase;
        window.debounce = debounce;
        window.escapeHtml = escapeHtml;
        window.escapeHtmlForAttribute = escapeHtmlForAttribute;
        
        // Make storage functions and constants available globally
        window.getTagColors = getTagColors;
        window.setTagColor = setTagColor;
        window.getTagColor = getTagColor;
        window.TAG_COLORS_STORAGE_KEY = TAG_COLORS_STORAGE_KEY;
        window.TAG_COLOR_MAP = TAG_COLOR_MAP;
        window.STATE_STORAGE_KEY = STATE_STORAGE_KEY;
        
        // Make storage module functions available for wrapper functions
        window.storageSaveState = storageSaveState;
        window.storageLoadState = storageLoadState;
        window.storageGetFilterStorageKey = storageGetFilterStorageKey;
        window.storageLoadFiltersFromStorage = storageLoadFiltersFromStorage;
        window.storageSaveFiltersToStorage = storageSaveFiltersToStorage;
        window.storageGetFavouritesStorageKey = storageGetFavouritesStorageKey;
        window.storageGetFavourites = storageGetFavourites;
        window.storageSaveFavourites = storageSaveFavourites;
        
        // Make auth service functions available globally for backward compatibility
        window.authServiceGetToken = authServiceGetToken;
        window.authServiceGetHeaders = authServiceGetHeaders;
        window.authServiceGetHeadersSafe = authServiceGetHeadersSafe;
        
        // Make API config available globally
        window.apiConfigGetBaseUrl = apiConfigGetBaseUrl;
        // API_BASE_URL will be set after module loads, but we can provide a getter function
        Object.defineProperty(window, 'apiConfigAPI_BASE_URL', {
            get: () => apiConfigGetBaseUrl(),
            enumerable: true,
            configurable: true
        });
        
        // Make clients API available globally for wrapper functions
        window.clientsApiLoadClients = clientsApiLoadClients;
        
        // Make data sources API available globally for wrapper functions
        window.dataSourcesApiLoadProjects = dataSourcesApiLoadProjects;
        window.dataSourcesApiLoadSources = dataSourcesApiLoadSources;
        
        // Make VOC data API available globally for wrapper functions
        window.vocDataApiLoadVocData = vocDataApiLoadVocData;
        window.vocDataApiLoadDimensionNames = vocDataApiLoadDimensionNames;
        window.vocDataApiLoadQuestions = vocDataApiLoadQuestions;
        
        // Make insights API available globally for wrapper functions
        window.insightsApiLoadInsights = insightsApiLoadInsights;
        window.insightsApiCreateInsight = insightsApiCreateInsight;
        window.insightsApiUpdateInsight = insightsApiUpdateInsight;
        window.insightsApiDeleteInsight = insightsApiDeleteInsight;
        
        // Make app state functions available globally for backward compatibility
        window.appStateGetCurrentClientId = appStateGetCurrentClientId;
        window.appStateSetCurrentClientId = appStateSetCurrentClientId;
        window.appStateGetCurrentProjectName = appStateGetCurrentProjectName;
        window.appStateSetCurrentProjectName = appStateSetCurrentProjectName;
        window.appStateGetCurrentDataSourceId = appStateGetCurrentDataSourceId;
        window.appStateSetCurrentDataSourceId = appStateSetCurrentDataSourceId;
        window.appStateGetCurrentQuestionRefKey = appStateGetCurrentQuestionRefKey;
        window.appStateSetCurrentQuestionRefKey = appStateSetCurrentQuestionRefKey;
        window.appStateGetState = appStateGetState;
        window.appStateSetState = appStateSetState;
        window.appStateResetState = appStateResetState;
        
        // Make visualization state functions available globally for backward compatibility
        window.vizStateGetRawData = vizStateGetRawData;
        window.vizStateSetRawData = vizStateSetRawData;
        window.vizStateGetFullRawData = vizStateGetFullRawData;
        window.vizStateSetFullRawData = vizStateSetFullRawData;
        window.vizStateGetDimensionFilteredData = vizStateGetDimensionFilteredData;
        window.vizStateSetDimensionFilteredData = vizStateSetDimensionFilteredData;
        window.vizStateGetHierarchyData = vizStateGetHierarchyData;
        window.vizStateSetHierarchyData = vizStateSetHierarchyData;
        window.vizStateGetVisualizationState = vizStateGetVisualizationState;
        window.vizStateSetVisualizationState = vizStateSetVisualizationState;
        window.vizStateResetVisualizationState = vizStateResetVisualizationState;
        
        // Make filter state functions available globally for backward compatibility
        window.filterStateGetFilterRules = filterStateGetFilterRules;
        window.filterStateSetFilterRules = filterStateSetFilterRules;
        window.filterStateGetDimensionFilters = filterStateGetDimensionFilters;
        window.filterStateSetDimensionFilters = filterStateSetDimensionFilters;
        window.filterStateGetDimensionFilter = filterStateGetDimensionFilter;
        window.filterStateSetDimensionFilter = filterStateSetDimensionFilter;
        window.filterStateClearDimensionFilter = filterStateClearDimensionFilter;
        window.filterStateClearAllDimensionFilters = filterStateClearAllDimensionFilters;
        window.filterStateGetAvailableMetadataFields = filterStateGetAvailableMetadataFields;
        window.filterStateSetAvailableMetadataFields = filterStateSetAvailableMetadataFields;
        window.filterStateGetCurrentMetadataField = filterStateGetCurrentMetadataField;
        window.filterStateSetCurrentMetadataField = filterStateSetCurrentMetadataField;
        window.filterStateGetFilterState = filterStateGetFilterState;
        window.filterStateSetFilterState = filterStateSetFilterState;
        window.filterStateResetFilterState = filterStateResetFilterState;
        
        // Make available options state functions available globally for backward compatibility
        window.availableOptionsGetAvailableQuestions = availableOptionsGetAvailableQuestions;
        window.availableOptionsSetAvailableQuestions = availableOptionsSetAvailableQuestions;
        window.availableOptionsGetAvailableCategories = availableOptionsGetAvailableCategories;
        window.availableOptionsSetAvailableCategories = availableOptionsSetAvailableCategories;
        window.availableOptionsGetAvailableTopics = availableOptionsGetAvailableTopics;
        window.availableOptionsSetAvailableTopics = availableOptionsSetAvailableTopics;
        window.availableOptionsGetAvailableLocations = availableOptionsGetAvailableLocations;
        window.availableOptionsSetAvailableLocations = availableOptionsSetAvailableLocations;
        window.availableOptionsGetAvailableOptionsState = availableOptionsGetAvailableOptionsState;
        window.availableOptionsSetAvailableOptionsState = availableOptionsSetAvailableOptionsState;
        window.availableOptionsResetAvailableOptionsState = availableOptionsResetAvailableOptionsState;
        
        // Make view state functions available globally for backward compatibility
        window.viewStateGetCurrentView = viewStateGetCurrentView;
        window.viewStateSetCurrentView = viewStateSetCurrentView;
        window.viewStateGetViewStack = viewStateGetViewStack;
        window.viewStateSetViewStack = viewStateSetViewStack;
        window.viewStatePushView = viewStatePushView;
        window.viewStatePopView = viewStatePopView;
        window.viewStateClearViewStack = viewStateClearViewStack;
        window.viewStateGetCurrentSourceFormat = viewStateGetCurrentSourceFormat;
        window.viewStateSetCurrentSourceFormat = viewStateSetCurrentSourceFormat;
        window.viewStateGetViewState = viewStateGetViewState;
        window.viewStateSetViewState = viewStateSetViewState;
        window.viewStateResetViewState = viewStateResetViewState;
        
        // Make authentication state functions available globally for backward compatibility
        window.authStateGetAccessibleClients = authStateGetAccessibleClients;
        window.authStateSetAccessibleClients = authStateSetAccessibleClients;
        window.authStateGetAccessibleClientIds = authStateGetAccessibleClientIds;
        window.authStateSetAccessibleClientIds = authStateSetAccessibleClientIds;
        window.authStateAddAccessibleClientId = authStateAddAccessibleClientId;
        window.authStateRemoveAccessibleClientId = authStateRemoveAccessibleClientId;
        window.authStateHasAccessibleClientId = authStateHasAccessibleClientId;
        window.authStateClearAccessibleClientIds = authStateClearAccessibleClientIds;
        window.authStateGetAuthenticatedUser = authStateGetAuthenticatedUser;
        window.authStateSetAuthenticatedUser = authStateSetAuthenticatedUser;
        window.authStateGetAuthState = authStateGetAuthState;
        window.authStateSetAuthState = authStateSetAuthState;
        window.authStateResetAuthState = authStateResetAuthState;
        
        // Make API cache state functions available globally for backward compatibility
        window.apiCacheGetAllClients = apiCacheGetAllClients;
        window.apiCacheSetAllClients = apiCacheSetAllClients;
        window.apiCacheGetClientProjects = apiCacheGetClientProjects;
        window.apiCacheSetClientProjects = apiCacheSetClientProjects;
        window.apiCacheGetClientSources = apiCacheGetClientSources;
        window.apiCacheSetClientSources = apiCacheSetClientSources;
        window.apiCacheGetDimensionNamesMap = apiCacheGetDimensionNamesMap;
        window.apiCacheSetDimensionNamesMap = apiCacheSetDimensionNamesMap;
        window.apiCacheGetDimensionName = apiCacheGetDimensionName;
        window.apiCacheSetDimensionName = apiCacheSetDimensionName;
        window.apiCacheGetQuestionTypesMap = apiCacheGetQuestionTypesMap;
        window.apiCacheSetQuestionTypesMap = apiCacheSetQuestionTypesMap;
        window.apiCacheGetQuestionType = apiCacheGetQuestionType;
        window.apiCacheSetQuestionType = apiCacheSetQuestionType;
        window.apiCacheGetApiCacheState = apiCacheGetApiCacheState;
        window.apiCacheSetApiCacheState = apiCacheSetApiCacheState;
        window.apiCacheResetApiCacheState = apiCacheResetApiCacheState;
        
        // Make UI controller functions available globally for backward compatibility
        window.uiControllerToggleChart = uiControllerToggleChart;
        window.uiControllerToggleTreemap = uiControllerToggleTreemap;
        window.uiControllerToggleSettingsPanel = uiControllerToggleSettingsPanel;
        window.uiControllerToggleInsightsPanel = uiControllerToggleInsightsPanel;
        window.uiControllerToggleInsightsAddDropdown = uiControllerToggleInsightsAddDropdown;
        window.uiControllerCloseInsightsAddDropdown = uiControllerCloseInsightsAddDropdown;
        
        // Make insights state functions available globally for backward compatibility
        window.insightsStateGetInsightsCurrentClientId = insightsStateGetInsightsCurrentClientId;
        window.insightsStateSetInsightsCurrentClientId = insightsStateSetInsightsCurrentClientId;
        window.insightsStateGetInsightsCurrentInsightId = insightsStateGetInsightsCurrentInsightId;
        window.insightsStateSetInsightsCurrentInsightId = insightsStateSetInsightsCurrentInsightId;
        window.insightsStateGetInsightsAllInsights = insightsStateGetInsightsAllInsights;
        window.insightsStateSetInsightsAllInsights = insightsStateSetInsightsAllInsights;
        window.insightsStateGetAllInsights = insightsStateGetAllInsights;
        window.insightsStateSetAllInsights = insightsStateSetAllInsights;
        window.insightsStateGetInsightsFilters = insightsStateGetInsightsFilters;
        window.insightsStateSetInsightsFilters = insightsStateSetInsightsFilters;
        window.insightsStateGetInsightsCurrentFilters = insightsStateGetInsightsCurrentFilters;
        window.insightsStateSetInsightsCurrentFilters = insightsStateSetInsightsCurrentFilters;
        window.insightsStateGetInsightsCurrentSortBy = insightsStateGetInsightsCurrentSortBy;
        window.insightsStateSetInsightsCurrentSortBy = insightsStateSetInsightsCurrentSortBy;
        window.insightsStateGetInsightsSortBy = insightsStateGetInsightsSortBy;
        window.insightsStateSetInsightsSortBy = insightsStateSetInsightsSortBy;
        window.insightsStateGetInsightsSortOrder = insightsStateGetInsightsSortOrder;
        window.insightsStateSetInsightsSortOrder = insightsStateSetInsightsSortOrder;
        window.insightsStateGetInsightsSearchTerm = insightsStateGetInsightsSearchTerm;
        window.insightsStateSetInsightsSearchTerm = insightsStateSetInsightsSearchTerm;
        window.insightsStateGetInsightsCurrentInsightEditor = insightsStateGetInsightsCurrentInsightEditor;
        
        // Make renderers available globally for backward compatibility
        window.insightsRendererRenderInsights = insightsRendererRenderInsights;
        window.historyRendererRenderHistoryTable = historyRendererRenderHistoryTable;
        window.adsControllerInitAdsPage = adsControllerInitAdsPage;
        window.initAdsPage = adsControllerInitAdsPage;
        window.renderAdsPage = adsControllerRenderAdsPage;
        window.verbatimsRendererRenderVerbatims = verbatimsRendererRenderVerbatims;
        window.treemapRendererRenderTreemap = treemapRendererRenderTreemap;
        window.chartRendererRenderBarChart = chartRendererRenderBarChart;
        window.chartRendererRenderTopicsChart = chartRendererRenderTopicsChart;
        window.chartRendererRenderHorizontalBarChart = chartRendererRenderHorizontalBarChart;
        window.chartRendererToggleCategory = chartRendererToggleCategory;
        window.chartRendererGenerateCategoryColorPalette = chartRendererGenerateCategoryColorPalette;
        window.chartRendererAdjustColorLightness = chartRendererAdjustColorLightness;
        window.chartRendererProcessBarChartData = chartRendererProcessBarChartData;
        window.chartRendererProcessTopicsData = chartRendererProcessTopicsData;
        window.insightsStateSetInsightsCurrentInsightEditor = insightsStateSetInsightsCurrentInsightEditor;
        window.insightsStateGetInsightsAutoFilter = insightsStateGetInsightsAutoFilter;
        window.insightsStateSetInsightsAutoFilter = insightsStateSetInsightsAutoFilter;
        window.insightsStateGetInsightsState = insightsStateGetInsightsState;
        window.insightsStateSetInsightsState = insightsStateSetInsightsState;
        window.insightsStateResetInsightsState = insightsStateResetInsightsState;
        
        // Make history state functions available globally for backward compatibility
        window.historyStateGetHistoryCurrentClientId = historyStateGetHistoryCurrentClientId;
        window.historyStateSetHistoryCurrentClientId = historyStateSetHistoryCurrentClientId;
        window.historyStateGetHistoryAllActions = historyStateGetHistoryAllActions;
        window.historyStateSetHistoryAllActions = historyStateSetHistoryAllActions;
        window.historyStateGetHistorySearchTerm = historyStateGetHistorySearchTerm;
        window.historyStateSetHistorySearchTerm = historyStateSetHistorySearchTerm;
        window.historyStateGetSelectedHistoryIds = historyStateGetSelectedHistoryIds;
        window.historyStateSetSelectedHistoryIds = historyStateSetSelectedHistoryIds;
        window.historyStateAddSelectedHistoryId = historyStateAddSelectedHistoryId;
        window.historyStateRemoveSelectedHistoryId = historyStateRemoveSelectedHistoryId;
        window.historyStateHasSelectedHistoryId = historyStateHasSelectedHistoryId;
        window.historyStateClearSelectedHistoryIds = historyStateClearSelectedHistoryIds;
        window.historyStateGetHistoryCurrentSortBy = historyStateGetHistoryCurrentSortBy;
        window.historyStateSetHistoryCurrentSortBy = historyStateSetHistoryCurrentSortBy;
        window.historyStateGetHistorySortOrder = historyStateGetHistorySortOrder;
        window.historyStateSetHistorySortOrder = historyStateSetHistorySortOrder;
        window.historyStateGetHistoryInitialized = historyStateGetHistoryInitialized;
        window.historyStateSetHistoryInitialized = historyStateSetHistoryInitialized;
        window.historyStateGetHistoryState = historyStateGetHistoryState;
        window.historyStateSetHistoryState = historyStateSetHistoryState;
        window.historyStateResetHistoryState = historyStateResetHistoryState;
        
        // Make settings state and API functions available globally for backward compatibility
        window.settingsStateGetSettingsInitialized = settingsStateGetSettingsInitialized;
        window.settingsStateSetSettingsInitialized = settingsStateSetSettingsInitialized;
        window.settingsStateGetSettingsCurrentClientId = settingsStateGetSettingsCurrentClientId;
        window.settingsStateSetSettingsCurrentClientId = settingsStateSetSettingsCurrentClientId;
        window.settingsStateResetSettingsState = settingsStateResetSettingsState;
        window.settingsApiFetchClientSettings = settingsApiFetchClientSettings;
        window.settingsApiUpdateClientSettings = settingsApiUpdateClientSettings;
        
        // Make UI interaction state functions available globally for backward compatibility
        window.uiInteractionGetCurrentFilterType = uiInteractionGetCurrentFilterType;
        window.uiInteractionSetCurrentFilterType = uiInteractionSetCurrentFilterType;
        window.uiInteractionGetCurrentFilterSelections = uiInteractionGetCurrentFilterSelections;
        window.uiInteractionSetCurrentFilterSelections = uiInteractionSetCurrentFilterSelections;
        window.uiInteractionAddCurrentFilterSelection = uiInteractionAddCurrentFilterSelection;
        window.uiInteractionRemoveCurrentFilterSelection = uiInteractionRemoveCurrentFilterSelection;
        window.uiInteractionClearCurrentFilterSelections = uiInteractionClearCurrentFilterSelections;
        window.uiInteractionGetCurrentFilterSearchTerm = uiInteractionGetCurrentFilterSearchTerm;
        window.uiInteractionSetCurrentFilterSearchTerm = uiInteractionSetCurrentFilterSearchTerm;
        window.uiInteractionGetCurrentVerbatimsData = uiInteractionGetCurrentVerbatimsData;
        window.uiInteractionSetCurrentVerbatimsData = uiInteractionSetCurrentVerbatimsData;
        window.uiInteractionGetCurrentTopicName = uiInteractionGetCurrentTopicName;
        window.uiInteractionSetCurrentTopicName = uiInteractionSetCurrentTopicName;
        window.uiInteractionGetCurrentCategoryName = uiInteractionGetCurrentCategoryName;
        window.uiInteractionSetCurrentCategoryName = uiInteractionSetCurrentCategoryName;
        window.uiInteractionGetCurrentEditingRefKey = uiInteractionGetCurrentEditingRefKey;
        window.uiInteractionSetCurrentEditingRefKey = uiInteractionSetCurrentEditingRefKey;
        window.uiInteractionGetSelectedInsightIds = uiInteractionGetSelectedInsightIds;
        window.uiInteractionSetSelectedInsightIds = uiInteractionSetSelectedInsightIds;
        window.uiInteractionAddSelectedInsightId = uiInteractionAddSelectedInsightId;
        window.uiInteractionRemoveSelectedInsightId = uiInteractionRemoveSelectedInsightId;
        window.uiInteractionClearSelectedInsightIds = uiInteractionClearSelectedInsightIds;
        window.uiInteractionGetCurrentResizeHeader = uiInteractionGetCurrentResizeHeader;
        window.uiInteractionSetCurrentResizeHeader = uiInteractionSetCurrentResizeHeader;
        window.uiInteractionGetCurrentContextData = uiInteractionGetCurrentContextData;
        window.uiInteractionSetCurrentContextData = uiInteractionSetCurrentContextData;
        window.uiInteractionGetUiInteractionState = uiInteractionGetUiInteractionState;
        window.uiInteractionSetUiInteractionState = uiInteractionSetUiInteractionState;
        window.uiInteractionResetUiInteractionState = uiInteractionResetUiInteractionState;
        
        // Make dimension config available globally for backward compatibility
        window.dimensionConfigDIMENSION_OPTIONS = dimensionConfigDIMENSION_OPTIONS;
        window.dimensionConfigGetDimensionOptions = dimensionConfigGetDimensionOptions;
        window.dimensionConfigHasDimensionOption = dimensionConfigHasDimensionOption;
        window.dimensionConfigAddDimensionOption = dimensionConfigAddDimensionOption;
    </script>
</head>
<body>
    <!-- Login Overlay -->
    <div id="loginOverlay" class="login-overlay hidden">
        <div class="login-container">
            <div id="loginFormSection">
                <h2>Sign in</h2>
                <p class="login-subtext">
                    Enter your work email and we'll email you a secure magic link.
                    Only approved company domains can sign in.
                </p>
                <input type="email" id="loginEmail" placeholder="you@company.com" autocomplete="email">
                <button id="loginButton" type="button">Send Magic Link</button>
                <div id="loginError" class="login-error"></div>
                <div id="loginSuccess" class="login-success"></div>
            </div>

            <div id="accountSelectionSection" class="hidden">
                <div class="account-selection-header">
                    <p class="account-selection-greeting" id="accountSelectionGreeting"></p>
                    <h2>Which client?</h2>
                    <p class="account-selection-note">
                        Pick a client to open their dashboard. You can switch at any time from the client selector.
                    </p>
                </div>
                <div class="account-selection-content">
                    <div id="accountSelectionList" class="account-selection-grid" role="list"></div>
                    <div id="accountSelectionError" class="login-error"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container" id="mainContainer" style="display: none;">
        <!-- Navigation Menu -->
        <nav class="app-navigation">
            <div class="nav-menu" id="navMenu">
                <a href="#" class="nav-menu-item" id="navVisualizations" onclick="navigateToView('visualizations'); return false;">
                    <span>Visualizations</span>
                </a>
                <a href="#" class="nav-menu-item" id="navAds" onclick="navigateToView('ads'); return false;">
                    <span>Ads</span>
                </a>
                <a href="#" class="nav-menu-item" id="navInsights" onclick="navigateToView('insights'); return false;">
                    <span>Insights</span>
                </a>
                <a href="#" class="nav-menu-item" id="navHistory" onclick="navigateToView('history'); return false;">
                    <span>History</span>
                </a>
                <a href="/founder_prompt_engineering.html" class="nav-menu-item founder-admin hidden" id="navPrompts">
                    <span>Prompts</span>
                </a>
                <a href="#" class="nav-menu-item" id="navSettings" onclick="navigateToView('settings'); return false;">
                    <span>Settings</span>
                </a>
                <a href="/founder_admin.html" class="nav-menu-item founder-admin hidden" id="navFounderAdmin">
                    <span>Admin</span>
                </a>
            </div>
        </nav>
        
        <!-- Visualizations Section -->
        <div id="visualizations-section" class="spa-section active">
        <!-- Data Source Selector -->
        <div class="data-source-selector">
            <div class="filter-tabs" role="tablist" aria-label="Data filters">
                <button type="button" class="filter-tab active" id="clientTab" role="tab" aria-selected="true" aria-controls="clientPanel" data-target="clientPanel">
                    <span class="filter-tab__label">Client</span>
                </button>
                <button type="button" class="filter-tab" id="projectTab" role="tab" aria-selected="false" aria-controls="projectPanel" data-target="projectPanel" disabled>
                    <span class="filter-tab__label">Project</span>
                </button>
                <button type="button" class="filter-tab" id="sourceTab" role="tab" aria-selected="false" aria-controls="sourcePanel" data-target="sourcePanel" disabled>
                    <span class="filter-tab__label">Source</span>
                </button>
                <button type="button" class="filter-tab" id="dimensionTab" role="tab" aria-selected="false" aria-controls="dimensionPanel" data-target="dimensionPanel" disabled>
                    <span class="filter-tab__label">Dimension</span>
                </button>
            </div>

            <div class="data-source-selector__content">
                <div class="filter-panels">
                    <div class="filter-panel active" id="clientPanel" role="tabpanel" aria-labelledby="clientTab">
                        <label for="clientSelect">Business:</label>
                        <select id="clientSelect">
                            <option value="">Loading...</option>
                        </select>
                    </div>

                    <div class="filter-panel" id="projectPanel" role="tabpanel" aria-labelledby="projectTab">
                        <label for="projectSelect">Project:</label>
                        <select id="projectSelect">
                            <option value="">Select client first...</option>
                        </select>
                    </div>

                    <div class="filter-panel" id="sourcePanel" role="tabpanel" aria-labelledby="sourceTab">
                        <label for="sourceSelect">Source:</label>
                        <select id="sourceSelect">
                            <option value="">Select client first...</option>
                        </select>
                    </div>

                    <!-- Dimension Filter (for survey data) -->
                    <div class="filter-panel" id="dimensionPanel" role="tabpanel" aria-labelledby="dimensionTab">
                        <label for="questionSelect" id="questionLabel" style="display:none;">Dimension:</label>
                        <select id="questionSelect" style="display:none;">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                </div>

                <div class="data-source-actions">
                    <!-- Add Data Button -->
                    <a id="addDataBtn" href="#" style="padding: 8px 24px; background: #B9F040; color: #000000; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; text-decoration: none; display: none; margin-right: 8px; transition: background 200ms; min-height: 44px; line-height: 28px;">
                        Add
                    </a>
                    <!-- Advanced Multi-Filter -->
                    <div class="filter-menu">
                        <div class="ai-button-container">
                            <button id="aiBtn" class="filter-button" type="button" aria-label="Open AI insights" onclick="toggleAIDropdown(event)">
                                <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/insights/1768461403664-yqwfwo.png" alt="" aria-hidden="true">
                            </button>
                            <div class="ai-dropdown-menu" id="aiDropdownMenu">
                                <button class="ai-dropdown-item" onclick="handleAIDropdownOption('manual')">Manual Insight</button>
                                <button class="ai-dropdown-item" onclick="handleAIDropdownOption('overview')">AI Overview</button>
                                <div class="ai-dropdown-divider"></div>
                                <div id="aiExpertOptionsContainer"></div>
                            </div>
                        </div>
                        <button id="filterBtn" class="filter-button" type="button" aria-label="Open filters">
                            <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/filter_list.svg" alt="" aria-hidden="true">
                            <span id="filterBadge" class="filter-badge" aria-hidden="true"></span>
                        </button>
                        <div id="filterDropdown" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 350px; max-width: 450px; z-index: 1000; max-height: 500px; overflow-y: auto;">
                            <!-- Filter Type Selection View -->
                            <div id="filterTypeView" style="display: block;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <strong style="font-size: 14px;">Filter By</strong>
                                    <button id="clearAllFilters" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Clear All</button>
                                </div>
                                <div id="filterTypeList" style="padding: 8px;">
                                    <!-- Filter types will be dynamically populated here -->
                                </div>
                                <div id="activeFiltersList" style="padding: 8px 12px; border-top: 1px solid #e0e0e0; background: #f8f9fa; max-height: 150px; overflow-y: auto;"></div>
                            </div>
                            
                            <!-- Metadata Field Selection View (second level for metadata) -->
                            <div id="metadataFieldView" style="display: none;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <button id="backFromMetadataField" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 16px; font-weight: 500;"></button>
                                        <strong style="font-size: 14px;">Select Metadata Field</strong>
                                    </div>
                                </div>
                                <div id="metadataFieldList" style="padding: 8px; max-height: 350px; overflow-y: auto;"></div>
                            </div>
                            
                            <!-- Filter Selection View (for categories, topics, locations, or metadata values) -->
                            <div id="filterSelectionView" style="display: none;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <button id="backToFilterType" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 16px; font-weight: 500;"></button>
                                        <strong id="filterSelectionTitle" style="font-size: 14px;">Select Items</strong>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button id="selectAllItems" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Select All</button>
                                        <button id="clearAllItems" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Clear All</button>
                                    </div>
                                </div>
                                <div style="padding: 8px 12px; border-bottom: 1px solid #e0e0e0; background: #f0f0f0; display: flex; gap: 8px; align-items: center;">
                                    <span style="font-size: 12px; color: #666;">Mode:</span>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px;">
                                        <input type="radio" name="filterMode" value="include" checked style="cursor: pointer;">
                                        <span>Include</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px;">
                                        <input type="radio" name="filterMode" value="exclude" style="cursor: pointer;">
                                        <span>Exclude</span>
                                    </label>
                                </div>
                                <div style="padding: 8px 12px; border-bottom: 1px solid #e0e0e0; background: #fff;">
                                    <div style="position: relative;">
                                        <input
                                            type="text"
                                            id="filterSelectionSearch"
                                            placeholder="Search items..."
                                            style="width: 100%; padding: 6px 30px 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                        />
                                        <button
                                            id="filterSelectionSearchClear"
                                            onclick="clearFilterSelectionSearch()"
                                            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #999; font-size: 18px; line-height: 1; width: 20px; height: 20px; align-items: center; justify-content: center; border-radius: 3px;"
                                            title="Clear search"
                                            onmouseover="this.style.backgroundColor='#f0f0f0'; this.style.color='#666';"
                                            onmouseout="this.style.backgroundColor='transparent'; this.style.color='#999';"
                                        >&times;</button>
                                    </div>
                                </div>
                                <div id="filterSelectionList" style="padding: 8px; max-height: 300px; overflow-y: auto;"></div>
                                <div style="padding: 12px; border-top: 1px solid #e0e0e0; background: #f8f9fa;">
                                    <button id="applyFilter" style="width: 100%; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Apply Filter</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Inline Dimension Name Editor -->
                    <div id="dimensionNameEditor" style="display:none; align-items: center; gap: 8px;">
                        <label style="font-size: 13px; color: #666;">Name:</label>
                        <select id="dimensionNameSelect" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: white; cursor: pointer;">
                            <option value="">-- Select --</option>
                        </select>
                        <input 
                            type="text" 
                            id="dimensionNameCustom" 
                            placeholder="or enter custom name"
                            style="display:none; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; width: 200px;"
                        />
                        <button id="saveDimensionBtn" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 500;">
                            Save
                        </button>
                        <button id="manageOptionsBtn" style="padding: 6px 12px; background: #f0f0f0; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 13px;">
                            Manage Options
                        </button>
                        <span id="saveStatusInline" style="font-size: 12px; color: #666; font-style: italic;"></span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="treemap-section">
            <div class="treemap-container">
                <div class="treemap-header">
                    <div class="treemap-header-top">
                        <h2 class="treemap-title">Topic Distribution</h2>
                        <button class="chart__toggle" onclick="toggleTreemap(this)" aria-label="Toggle treemap visibility">
                            <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="treemap-search-container">
                    <div class="treemap-search-input-wrapper">
                        <input
                            type="text"
                            id="treemapSearch"
                            class="treemap-search-input"
                            placeholder="Search verbatims by keyword..."
                        />
                        <button
                            id="treemapSearchClear"
                            class="treemap-search-clear"
                            onclick="clearTreemapSearch()"
                            title="Clear search"
                            style="display: none;"
                        >&times;</button>
                    </div>
                </div>
                <div class="treemap-svg-container">
                    <div class="loading" id="loading">Loading data...</div>
                    <svg id="treemap"></svg>
                </div>
            </div>
        </div>

        <div class="visualizations-grid">
            <div class="chart-column">
                <div class="chart" role="figure" aria-label="Topics by Category">
                    <div class="chart__header">
                        <div class="chart__header-top">
                            <h2 class="chart__title">Topics by Category</h2>
                            <button class="chart__toggle" onclick="toggleChart(this)" aria-label="Toggle chart visibility">
                                <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                        <p class="chart__subtitle">Frequency of customer conversation topics</p>
                    </div>
                    <div class="chart__body">
                        <div class="chart__labels" id="barChartLabels"></div>
                        <div class="chart__bars" id="barChartBars"></div>
                    </div>
                    <div class="chart__footer" id="barChartFooter">Frequency (n=<span id="totalCount">0</span>)</div>
                </div>

                <!-- Insights Panel -->
                <div class="insights-panel-container">
                    <div class="insights-panel-header">
                        <div class="insights-panel-header-left">
                            <h2>Insights</h2>
                            <span id="insightsFilterBadge" class="insights-filter-badge" style="display: none;"></span>
                        </div>
                        <div class="insights-panel-header-search">
                            <div class="search-box">
                                <input type="text" id="insightsSearchInput" placeholder="Search insights..." oninput="handleInsightsSearch()" onfocus="updateInsightsSearchClearButton()">
                                <button
                                    id="insightsSearchClear"
                                    onclick="clearInsightsSearch()"
                                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                                    title="Clear search"
                                >&times;</button>
                            </div>
                        </div>
                        <div class="insights-panel-header-right">
                            <div class="insights-add-dropdown">
                                <button class="insights-panel-add-btn" onclick="toggleInsightsAddDropdown(event)" id="insightsPanelAddBtn" title="Add Insight">
                                    <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/add.png" alt="Add Insight" width="20" height="20">
                                </button>
                                <div class="insights-add-dropdown-menu" id="insightsAddDropdownMenu">
                                    <button class="insights-add-dropdown-item" onclick="handleInsightsAddOption('manual')">Manual Insight</button>
                                    <button class="insights-add-dropdown-item" onclick="handleInsightsAddOption('overview')">AI Overview</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="insights-panel-body" id="insightsPanelBody">
                        <div class="insights-table-section">
                            <div class="table-container">
                                <table class="notion-table">
                                    <thead>
                                        <tr>
                                            <th class="name-cell sorted draggable" data-column="name" draggable="true" onclick="sortInsightsBy('name')">
                                                <span class="drag-handle"></span>
                                                <span class="column-icon">Aa</span>
                                                <span>Name</span>
                                                <span class="sort-indicator"></span>
                                            </th>
                                            <th class="draggable" data-column="created_at" draggable="true" onclick="sortInsightsBy('created_at')">
                                                <span class="drag-handle"></span>
                                                <span class="column-icon"></span>
                                                <span>Created</span>
                                                <span class="sort-indicator"></span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody id="insightsTableBody">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart" role="figure" aria-label="All Topics">
                <div class="chart__header">
                    <div class="chart__header-top">
                        <h2 class="chart__title">All Topics</h2>
                        <button class="chart__toggle" onclick="toggleChart(this)" aria-label="Toggle chart visibility">
                            <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                    <p class="chart__subtitle">Individual topic frequency across all categories</p>
                </div>
                <div class="chart__body">
                    <div class="chart__labels" id="topicsChartLabels"></div>
                    <div class="chart__bars" id="topicsChartBars"></div>
                </div>
                <div class="chart__footer" id="topicsChartFooter">Frequency (n=<span id="topicsCount">0</span>)</div>
            </div>
        </div>
    </div>

    <!-- Overlay Modal for Verbatims -->
    <!-- Old overlay modal - hidden, kept for backward compatibility -->
    <div id="overlay" class="overlay" style="display: none !important;">
        <div class="overlay-content">
            <div class="overlay-header">
                <div style="flex: 1;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                        <div>
                            <h2 class="overlay-title" id="overlayTitle">Customer Feedback</h2>
                            <p class="overlay-subtitle" id="overlaySubtitle"></p>
                        </div>
                        <div class="overlay-header-actions">
                            <button class="settings-button" onclick="toggleSettingsPanel()" title="Card Settings">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"></path>
                                </svg>
                            </button>
                            <button class="close-button" onclick="closeOverlay()">&times;</button>
                        </div>
                    </div>
                    <div style="margin-top: 12px; position: relative;">
                        <input
                            type="text"
                            id="verbatimSearch"
                            placeholder="Search verbatims..."
                            style="width: 100%; padding: 8px 36px 8px 12px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; font-size: 14px; background: rgba(255, 255, 255, 0.1); color: white; backdrop-filter: blur(10px);"
                        />
                        <button
                            id="verbatimSearchClear"
                            onclick="clearVerbatimSearch()"
                            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: rgba(255, 255, 255, 0.8); font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                            title="Clear search"
                            onmouseover="this.style.backgroundColor='rgba(185, 240, 64, 0.2)'; this.style.color='#B9F040';"
                            onmouseout="this.style.backgroundColor='transparent'; this.style.color='rgba(255, 255, 255, 0.8)';"
                        >&times;</button>
                    </div>
                </div>
                <div id="settingsPanel" class="settings-panel">
                    <h3>Display Metadata</h3>
                    <div class="settings-option">
                        <input type="checkbox" id="showSentiment" checked onchange="updateMetadataSettings()">
                        <label for="showSentiment">Sentiment</label>
                    </div>
                    <div class="settings-option">
                        <input type="checkbox" id="showLocation" checked onchange="updateMetadataSettings()">
                        <label for="showLocation">Location</label>
                    </div>
                    <div class="settings-option">
                        <input type="checkbox" id="showIndex" checked onchange="updateMetadataSettings()">
                        <label for="showIndex">Index</label>
                    </div>
                </div>
            </div>
            <div id="verbatims" class="verbatim-container" style="display: none;"></div>
        </div>
    </div>

    <!-- Overlay Modal for Dimension Editor -->
    <div id="dimensionEditorOverlay" class="overlay">
        <div class="overlay-content">
            <div class="overlay-header">
                <div>
                    <h2 class="overlay-title">Edit Dimension Names</h2>
                    <p class="overlay-subtitle">Assign human-readable names to survey dimensions</p>
                </div>
                <button class="close-button" onclick="closeDimensionEditor()">&times;</button>
            </div>
            <div id="dimensionEditorContent" class="dimension-editor-container"></div>
        </div>
    </div>

    <!-- Context Menu for Right-Click -->
    <div id="contextMenu" class="context-menu" style="display: none;">
        <div class="context-menu-item" data-action="create-insight" style="cursor: pointer; user-select: none;">
            Create Insight
        </div>
        <div class="context-menu-item context-menu-item-with-submenu" data-action="ai-expert" style="cursor: pointer; user-select: none; position: relative;">
            <span>AI Expert</span>
            <span class="context-menu-item-chevron"></span>
            <div id="aiExpertSubmenu" class="context-menu-submenu">
                <!-- Populated dynamically with live prompts -->
            </div>
        </div>
        <div class="context-menu-item" data-action="exclude-category" style="display: none; cursor: pointer; user-select: none;">
            Exclude Category
        </div>
        <div class="context-menu-item" data-action="copy-json" style="cursor: pointer; user-select: none;">
            Copy JSON
        </div>
    </div>

    <!-- Create Insight Modal -->
    <div id="createInsightModal" class="insight-modal-overlay" style="display: none;">
        <div class="insight-modal-content">
            <div class="insight-modal-header">
                <h2>Create Insight</h2>
                <button class="insight-modal-close" onclick="closeCreateInsightModal()">&times;</button>
            </div>
            <form id="createInsightForm" onsubmit="handleCreateInsightSubmit(event)">
                <div class="insight-form-group">
                    <label for="insightModalName">Insight Name *</label>
                    <input type="text" id="insightModalName" required>
                </div>
                <div class="insight-form-group">
                    <label for="insightModalDescription">Description</label>
                    <textarea id="insightModalDescription" placeholder="Detailed description"></textarea>
                </div>
                <div class="insight-form-group">
                    <label>Origin</label>
                    <div id="insightModalOriginPreview" class="insight-origin-preview"></div>
                </div>
                <div class="insight-modal-actions">
                    <button type="button" class="insight-modal-cancel" onclick="closeCreateInsightModal()">Cancel</button>
                    <button type="submit" class="insight-modal-submit">Create</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Configuration - dynamically set to container size
        let width = 1200; // Will be updated when container is available
        let height = 600; // Will be updated when container is available
        
        // Debounce function - now imported from js/utils/dom.js module
        // Function is available globally via window.debounce
        
        function resetFilterSelectionSearch() {
            currentFilterSearchTerm = '';
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            updateFilterSelectionSearchClearButton();
        }
        
        function clearFilterSelectionSearch() {
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput) {
                searchInput.value = '';
                currentFilterSearchTerm = '';
                populateFilterSelectionList();
                updateFilterSelectionSearchClearButton();
            }
        }
        
        function updateFilterSelectionSearchClearButton() {
            const searchInput = document.getElementById('filterSelectionSearch');
            const clearButton = document.getElementById('filterSelectionSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.style.display = 'flex';
                } else {
                    clearButton.style.display = 'none';
                }
            }
        }
        
        // Color schemes - uses color-schemes.js module (with fallback for module load timing)
        const colorSchemes = (typeof window.colorSchemesGetColorSchemes === 'function') 
            ? window.colorSchemesGetColorSchemes(d3)
            : { categories: d3.scaleOrdinal(['#A97FFF', '#77D9D6', '#F8A04C', '#58B3F0', '#6ED49B', '#F47280', '#9A7B6C', '#FFB366', '#B794F6', '#4ECDC4']) };
        
        // State code mappings - now imported from js/utils/format.js module
        // Available globally via window.stateNameToCode and window.fipsToStateCode
        
        // getStateCode function - now imported from js/utils/format.js module
        // Available globally via window.getStateCode
        
        // adjustBrightness function - now imported from js/utils/colors.js module
        // Available globally via window.adjustBrightness

        // Global state
        let rawData = [];
        let fullRawData = []; // Store unfiltered data
        let dimensionFilteredData = []; // Store dimension-filtered data (before category filtering)
        let hierarchyData = null;
        let currentView = 'root';
        let viewStack = [];
        let currentSourceFormat = null;
        let availableQuestions = [];
        let availableCategories = [];
        let availableTopics = [];
        let availableLocations = [];
        
        // Filter rules: array of {type: 'category'|'topic'|'location'|'metadata', mode: 'include'|'exclude', values: Set, metadataField?: string}
        let filterRules = [];
        // Store filters per dimension: key is dimension ref key (or 'all' for null), value is array of filter rules
        let dimensionFilters = {}; // Map of dimensionRef -> filterRules array
        let availableMetadataFields = {}; // Map of fieldName -> array of values
        let currentMetadataField = null; // Currently selected metadata field
        // Core selection state - managed by js/state/app-state.js module
        // Wrapper functions that call module directly (modules always loaded)
        function getCurrentClientId() {
            return window.appStateGetCurrentClientId();
        }
        function setCurrentClientId(value) {
            window.appStateSetCurrentClientId(value);
        }
        function getCurrentProjectName() {
            return window.appStateGetCurrentProjectName();
        }
        function setCurrentProjectName(value) {
            window.appStateSetCurrentProjectName(value);
        }
        function getCurrentDataSourceId() {
            return window.appStateGetCurrentDataSourceId();
        }
        function setCurrentDataSourceId(value) {
            window.appStateSetCurrentDataSourceId(value);
        }
        function getCurrentQuestionRefKey() {
            return window.appStateGetCurrentQuestionRefKey();
        }
        function setCurrentQuestionRefKey(value) {
            window.appStateSetCurrentQuestionRefKey(value);
        }
        // For backward compatibility during migration, keep local variables that sync with module
        // These will be replaced gradually with direct getter/setter calls
        let currentClientId = null;
        let currentProjectName = null;
        let currentDataSourceId = null;
        let currentQuestionRefKey = null;
        let allClients = [];
        let clientProjects = [];
        let clientSources = [];
        let dimensionNamesMap = {}; // Map of ref_key -> custom_name
        let questionTypesMap = {}; // Map of dimension_ref -> question_type

        let headerUserInfoEl = null;
        let headerUserEmailEl = null;
        let headerLogoutButton = null;
        const headerControlState = {
            initialized: false,
            user: null,
        };

        function getHeaderDisplayEmail(user) {
            if (!user || typeof user !== 'object') {
                return '';
            }
            return (
                user.email ||
                user.email_address ||
                user.user_email ||
                user.name ||
                ''
            );
        }

        function handleHeaderLogoutClick() {
            if (typeof Auth !== 'undefined' && typeof Auth.handleLogout === 'function') {
                Auth.handleLogout();
            } else {
                window.dispatchEvent(new Event('auth:logout'));
            }
        }

        function ensureHeaderControls() {
            if (headerControlState.initialized && headerUserInfoEl && headerLogoutButton) {
                return true;
            }

            headerUserInfoEl = document.getElementById('headerUserInfo');
            headerUserEmailEl = document.getElementById('headerUserEmail');
            headerLogoutButton = document.getElementById('headerLogoutButton');

            if (!headerUserInfoEl || !headerLogoutButton) {
                return false;
            }

            headerLogoutButton.addEventListener('click', handleHeaderLogoutClick);
            headerControlState.initialized = true;
            return true;
        }

        function applyHeaderUserState() {
            if (!ensureHeaderControls()) {
                return;
            }

            const user = headerControlState.user;
            if (user) {
                const email = getHeaderDisplayEmail(user);
                if (headerUserEmailEl) {
                    headerUserEmailEl.textContent = email;
                }
                headerUserInfoEl.classList.remove('hidden');
            } else {
                if (headerUserEmailEl) {
                    headerUserEmailEl.textContent = '';
                }
                headerUserInfoEl.classList.add('hidden');
            }
        }

        function showHeaderUserInfo(user) {
            headerControlState.user = user || null;
            applyHeaderUserState();
        }

        function hideHeaderUserInfo() {
            headerControlState.user = null;
            applyHeaderUserState();
        }

        window.addEventListener('marketablyHeader:ready', () => {
            applyHeaderUserState();
        });

        const storedHeaderUser = typeof Auth !== 'undefined' && typeof Auth.getStoredUserInfo === 'function'
            ? Auth.getStoredUserInfo()
            : null;

        if (storedHeaderUser) {
            showHeaderUserInfo(storedHeaderUser);
            // Show/hide founder admin nav items based on stored user info
            const adminNavItem = document.getElementById('navFounderAdmin');
            const promptsNavItem = document.getElementById('navPrompts');
            if (storedHeaderUser.is_founder) {
                if (adminNavItem) adminNavItem.classList.remove('hidden');
                if (promptsNavItem) promptsNavItem.classList.remove('hidden');
            }
        } else {
            applyHeaderUserState();
        }
        
        // State persistence - now imported from js/services/storage.js module
        // STATE_STORAGE_KEY available globally via window.STATE_STORAGE_KEY
        
        // Flag to prevent auto-launch loops
        let hasAutoLaunched = false;
        let isInitializing = false;
        
        // Save current state to localStorage - uses storage module
        function saveState() {
            // Sync local variables to module state
            const localState = {
                clientId: currentClientId,
                projectName: currentProjectName,
                dataSourceId: currentDataSourceId,
                questionRefKey: currentQuestionRefKey
            };
            window.appStateSetState(localState);
            // Get state from module and save to storage
            const state = window.appStateGetState();
            window.storageSaveState(state);
        }
        
        // Load state from localStorage - uses storage module with fallback
        function loadState() {
            // Fallback for when module hasn't loaded yet (race condition with Auth.checkAuth)
            if (typeof window.storageLoadState === 'function') {
                return window.storageLoadState();
            }
            // Direct localStorage fallback
            try {
                const stateJson = localStorage.getItem('treemap_app_state');
                if (stateJson) {
                    return JSON.parse(stateJson);
                }
            } catch (error) {
                console.error('Error loading state (fallback):', error);
            }
            return null;
        }
        
        // Predefined dimension options
        let dimensionOptions = [
            'Original Desire',
            'Triggers',
            'False Beliefs',
            'Competitors',
            'Appeal',
            'Exclusivity',
            'Objections',
            'Proof Elements',
            'Trusted Personalities',
            'Trusted Media',
            'Usability Friction',
            'Relevant Features',
            'Relevant Benefits',
            'Product Ideas',
            'Service Ideas'
        ];


        // Authentication helpers provided by auth.js
        let accessibleClients = [];
        let accessibleClientIds = new Set();
        let authenticatedUser = null;

        const FILTER_TAB_CONFIG = [
            { key: 'client', tabId: 'clientTab', panelId: 'clientPanel', selectId: 'clientSelect' },
            { key: 'project', tabId: 'projectTab', panelId: 'projectPanel', selectId: 'projectSelect' },
            { key: 'source', tabId: 'sourceTab', panelId: 'sourcePanel', selectId: 'sourceSelect' },
            { key: 'dimension', tabId: 'dimensionTab', panelId: 'dimensionPanel', selectId: 'questionSelect' }
        ];

        function getFilterTabConfig(key) {
            return FILTER_TAB_CONFIG.find((config) => config.key === key);
        }

        function isMobileFilterView() {
            return window.matchMedia('(max-width: 768px)').matches;
        }

        function hasSelectableOption(selectEl) {
            if (!selectEl) {
                return false;
            }
            return Array.from(selectEl.options || []).some((option) => option.value !== '');
        }

        function setTabEnabled(key, enabled) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            if (!tab) return;
            tab.disabled = !enabled;
            tab.classList.toggle('is-disabled', !enabled);
            tab.setAttribute('aria-disabled', enabled ? 'false' : 'true');
            tab.setAttribute('tabindex', enabled ? '0' : '-1');
            if (!enabled) {
                tab.classList.remove('complete');
                tab.classList.remove('active');
                tab.setAttribute('aria-selected', 'false');
            }
        }

        function setTabVisibility(key, visible) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            const panel = document.getElementById(config.panelId);
            if (tab) {
                tab.style.display = visible ? '' : 'none';
                if (!visible) {
                    tab.classList.remove('active');
                    tab.setAttribute('aria-selected', 'false');
                }
            }
            if (panel) {
                panel.dataset.hidden = visible ? 'false' : 'true';
                panel.setAttribute('aria-hidden', visible ? 'false' : 'true');
                if (!visible) {
                    panel.classList.remove('active');
                }
            }
        }

        function markTabComplete(key, complete) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            if (!tab) return;
            tab.classList.toggle('complete', complete);
        }

        function setActiveTab(tabId) {
            const tab = document.getElementById(tabId);
            if (!tab || tab.disabled || tab.style.display === 'none') {
                return;
            }
            FILTER_TAB_CONFIG.forEach(({ tabId: id, panelId }) => {
                const tabEl = document.getElementById(id);
                const panelEl = document.getElementById(panelId);
                const tabIsVisible = !(tabEl && tabEl.style.display === 'none');
                const isActive = id === tabId && tabIsVisible && !(tabEl && tabEl.disabled);
                if (tabEl) {
                    tabEl.classList.toggle('active', isActive);
                    tabEl.setAttribute('aria-selected', isActive ? 'true' : 'false');
                }
                if (panelEl) {
                    panelEl.classList.toggle('active', isActive);
                    panelEl.setAttribute('aria-hidden', isActive ? 'false' : 'true');
                }
            });
        }

        function ensureActiveFilterTab() {
            const availableTabs = FILTER_TAB_CONFIG
                .map(({ tabId }) => document.getElementById(tabId))
                .filter((tab) => tab && tab.style.display !== 'none' && !tab.disabled);

            if (availableTabs.length === 0) {
                return;
            }

            const currentlyActive = availableTabs.find((tab) => tab.classList.contains('active'));
            if (currentlyActive) {
                setActiveTab(currentlyActive.id);
                return;
            }

            const firstIncomplete = availableTabs.find((tab) => !tab.classList.contains('complete'));
            if (firstIncomplete) {
                setActiveTab(firstIncomplete.id);
                return;
            }

            setActiveTab(availableTabs[0].id);
        }

        function focusNextTab(currentKey) {
            if (!isMobileFilterView()) {
                return;
            }
            const currentIndex = FILTER_TAB_CONFIG.findIndex((config) => config.key === currentKey);
            if (currentIndex === -1) {
                return;
            }
            for (let i = currentIndex + 1; i < FILTER_TAB_CONFIG.length; i++) {
                const nextConfig = FILTER_TAB_CONFIG[i];
                const tabEl = document.getElementById(nextConfig.tabId);
                if (tabEl && !tabEl.disabled && tabEl.style.display !== 'none') {
                    setActiveTab(nextConfig.tabId);
                    break;
                }
            }
        }

        function applyPanelDisplayForViewport() {
            const currentActive = document.querySelector('.filter-tab.active');
            if (currentActive) {
                setActiveTab(currentActive.id);
            } else {
                ensureActiveFilterTab();
            }
        }

        function syncFilterTabState() {
            const clientSelect = document.getElementById('clientSelect');
            const projectSelect = document.getElementById('projectSelect');
            const sourceSelect = document.getElementById('sourceSelect');
            const questionSelect = document.getElementById('questionSelect');

            setTabEnabled('client', !!clientSelect);
            markTabComplete('client', !!clientSelect && !!clientSelect.value);

            const projectHasOptions = hasSelectableOption(projectSelect);
            setTabEnabled('project', projectHasOptions);
            markTabComplete('project', !!projectSelect && !!projectSelect.value);

            const sourceHasOptions = hasSelectableOption(sourceSelect);
            setTabEnabled('source', sourceHasOptions);
            markTabComplete('source', !!sourceSelect && !!sourceSelect.value);

            const dimensionVisible = !!questionSelect && questionSelect.style.display !== 'none';
            setTabVisibility('dimension', dimensionVisible);
            setTabEnabled('dimension', dimensionVisible);
            markTabComplete('dimension', !!questionSelect && !!questionSelect.value);

            ensureActiveFilterTab();
            applyPanelDisplayForViewport();
            // Use requestAnimationFrame to ensure layout is complete
            requestAnimationFrame(() => {
                setTimeout(() => autoSizeFilterSelects(), 0);
            });
        }

        // Auto-size filter selects to fit their content, with truncation if needed
        function autoSizeFilterSelects() {
            // Skip auto-sizing on mobile view where selects should be full width
            if (isMobileFilterView()) {
                return;
            }

            const selectIds = ['clientSelect', 'projectSelect', 'sourceSelect', 'questionSelect'];
            const selects = selectIds
                .map(id => document.getElementById(id))
                .filter(select => select && select.style.display !== 'none' && select.offsetParent !== null);
            
            if (selects.length === 0) return;

            // Get the parent container that holds both filter-panels and data-source-actions
            const contentContainer = document.querySelector('.data-source-selector__content');
            const filterPanels = document.querySelector('.filter-panels');
            const actionsContainer = document.querySelector('.data-source-actions');
            
            if (!contentContainer || !filterPanels) return;

            // Get the actual available width for filter-panels
            // Use getBoundingClientRect for more accurate measurements
            const contentRect = contentContainer.getBoundingClientRect();
            let availableWidth = contentRect.width;
            
            // Account for the actions container if it's visible
            const contentGap = 24; // Gap between filter-panels and actions
            if (actionsContainer && actionsContainer.offsetParent !== null) {
                const actionsRect = actionsContainer.getBoundingClientRect();
                availableWidth = availableWidth - actionsRect.width - contentGap;
            }

            if (availableWidth <= 100) return; // Minimum reasonable width

            // Temporarily reset widths to auto to get accurate measurements
            selects.forEach(select => {
                const originalWidth = select.style.width;
                select.style.width = 'auto';
                // Force a reflow
                void select.offsetWidth;
            });

            // Create a temporary span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.position = 'absolute';
            measureSpan.style.whiteSpace = 'nowrap';
            measureSpan.style.fontSize = window.getComputedStyle(selects[0]).fontSize;
            measureSpan.style.fontFamily = window.getComputedStyle(selects[0]).fontFamily;
            measureSpan.style.fontWeight = window.getComputedStyle(selects[0]).fontWeight;
            measureSpan.style.padding = '0';
            document.body.appendChild(measureSpan);

            // Calculate ideal widths for each select
            const idealWidths = selects.map(select => {
                const selectedOption = select.options[select.selectedIndex];
                const text = selectedOption ? selectedOption.text : '';
                measureSpan.textContent = text;
                // Add padding for dropdown arrow and some extra space
                const selectStyle = window.getComputedStyle(select);
                const padding = parseFloat(selectStyle.paddingLeft) + parseFloat(selectStyle.paddingRight) + 35; // Extra for dropdown arrow
                return Math.max(measureSpan.offsetWidth + padding, 80); // Minimum 80px
            });

            document.body.removeChild(measureSpan);

            const gap = 24; // Gap between panels
            const labelWidths = selects.map(select => {
                const label = document.querySelector(`label[for="${select.id}"]`);
                if (label && label.offsetParent !== null) {
                    const labelStyle = window.getComputedStyle(label);
                    const labelGap = parseFloat(labelStyle.marginRight) || 10;
                    return label.offsetWidth + labelGap;
                }
                return 0;
            });

            // Calculate total width needed
            const totalNeeded = idealWidths.reduce((sum, width, i) => sum + width + labelWidths[i], 0) + 
                                (selects.length - 1) * gap;

            // Add a small buffer (20px) to account for any measurement inaccuracies
            const buffer = 20;

            // If everything fits (with small buffer), use ideal widths
            if (totalNeeded <= availableWidth + buffer) {
                selects.forEach((select, i) => {
                    select.style.width = idealWidths[i] + 'px';
                    select.style.minWidth = '0';
                    select.style.maxWidth = 'none';
                });
            } else {
                // Need to truncate - distribute available space proportionally
                const availableForSelects = availableWidth - (selects.length - 1) * gap - 
                                         labelWidths.reduce((sum, w) => sum + w, 0);
                
                // Calculate proportional widths
                const totalIdeal = idealWidths.reduce((sum, w) => sum + w, 0);
                const scale = Math.max(0, Math.min(1, availableForSelects / totalIdeal));

                selects.forEach((select, i) => {
                    const scaledWidth = Math.max(80, Math.floor(idealWidths[i] * scale));
                    select.style.width = scaledWidth + 'px';
                    select.style.minWidth = '0';
                    select.style.maxWidth = 'none';
                });
            }
        }

        let filterTabsInitialized = false;

        function setupFilterTabs() {
            if (filterTabsInitialized) {
                syncFilterTabState();
                return;
            }

            FILTER_TAB_CONFIG.forEach((config) => {
                const tab = document.getElementById(config.tabId);
                const select = document.getElementById(config.selectId);
                if (tab) {
                    tab.addEventListener('click', () => setActiveTab(config.tabId));
                }
                if (select && !select.dataset.mobileNavBound) {
                    select.addEventListener('change', (event) => {
                        syncFilterTabState();
                        if (event.target.value) {
                            focusNextTab(config.key);
                        } else if (isMobileFilterView()) {
                            setActiveTab(config.tabId);
                        }
                    });
                    select.dataset.mobileNavBound = 'true';
                }
            });

            window.addEventListener('resize', applyPanelDisplayForViewport);
            
            // Add debounced resize listener for auto-sizing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    autoSizeFilterSelects();
                }, 100);
            });
            
            filterTabsInitialized = true;
            syncFilterTabState();
        }

        function updateAccessibleClients(clients = []) {
            accessibleClients = Array.isArray(clients) ? clients : [];
            accessibleClientIds = new Set(
                accessibleClients.map((client) => client.id)
            );
        }

        function enterAccountSelectionMode() {
            const overlay = document.getElementById('loginOverlay');
            const mainContainer = document.getElementById('mainContainer');
            const formSection = document.getElementById('loginFormSection');
            const selectionSection = document.getElementById('accountSelectionSection');
            const successMessage = document.getElementById('loginSuccess');
            const errorMessage = document.getElementById('loginError');
            const loginContainer = document.querySelector('.login-container');

            if (mainContainer) {
                mainContainer.style.display = 'none';
            }
            if (overlay) {
                overlay.classList.remove('hidden');
            }
            if (formSection) {
                formSection.classList.add('hidden');
            }
            if (selectionSection) {
                selectionSection.classList.remove('hidden');
            }
            if (successMessage) {
                successMessage.style.display = 'none';
            }
            if (errorMessage) {
                errorMessage.style.display = 'none';
            }
            if (loginContainer) {
                loginContainer.classList.add('account-selection-mode');
                loginContainer.scrollTop = 0;
            }
        }

        function renderAccountSelection(clients) {
            enterAccountSelectionMode();
            const listEl = document.getElementById('accountSelectionList');
            const errorEl = document.getElementById('accountSelectionError');
            const greetingEl = document.getElementById('accountSelectionGreeting');

            if (errorEl) {
                errorEl.style.display = 'none';
            }

            if (!listEl) {
                console.error('Account selection list element not found');
                return;
            }

            listEl.innerHTML = '';
            listEl.scrollTop = 0;

            if (greetingEl) {
                const nameSources = [
                    authenticatedUser?.first_name,
                    authenticatedUser?.name,
                    authenticatedUser?.email
                        ? authenticatedUser.email.split('@')[0]
                        : null,
                ].filter(Boolean);
                const firstName = nameSources.length
                    ? String(nameSources[0]).split(' ')[0]
                    : null;
                greetingEl.textContent = firstName
                    ? `Hi ${firstName},`
                    : 'Welcome back,';
                greetingEl.style.display = 'block';
            }

            const getClientLabel = (client) =>
                client?.name ||
                client?.client_name ||
                client?.display_name ||
                client?.clientUuid ||
                client?.client_uuid ||
                client?.id ||
                'Client';

            const sortedClients = [...clients].sort((a, b) => {
                const labelA = getClientLabel(a).toLowerCase();
                const labelB = getClientLabel(b).toLowerCase();
                return labelA.localeCompare(labelB);
            });

            sortedClients.forEach((client) => {
                const clientId =
                    client?.id ??
                    client?.client_uuid ??
                    client?.clientUuid ??
                    client?.uuid ??
                    null;

                const button = document.createElement('button');
                button.className = 'account-option';
                if (clientId) {
                    button.dataset.clientId = clientId;
                }
                button.textContent = getClientLabel(client);
                button.setAttribute('role', 'listitem');
                button.addEventListener('click', () => {
                    if (clientId) {
                        selectClientAndLaunch(clientId);
                    }
                });
                listEl.appendChild(button);
            });
        }

        function selectClientAndLaunch(clientId) {
            // Prevent multiple calls
            if (hasAutoLaunched && currentClientId === clientId) {
                return;
            }
            currentClientId = clientId;
            window.appStateSetCurrentClientId(clientId);
            
            // Sync Insights tab client ID to keep both tabs in sync
            if (typeof insightsCurrentClientId !== 'undefined') {
                insightsCurrentClientId = clientId;
            }
            
            // Load insights for the visualizations panel (async, doesn't block)
            if (typeof loadInsightsPage === 'function') {
                loadInsightsPage().catch(err => console.warn('Failed to load insights for panel:', err));
            }
            
            saveState();
            hasAutoLaunched = true;
            const loginContainer = document.querySelector('.login-container');
            if (loginContainer) {
                loginContainer.classList.remove('account-selection-mode');
            }
            if (typeof Auth !== 'undefined') {
                Auth.hideLogin();
            }
            const mainContainer = document.getElementById('mainContainer');
            if (mainContainer) {
                mainContainer.style.display = 'flex';
            }
            // Only call init if we haven't already initialized
            // Check if we're already in the main view - if so, just load the data
            const isAlreadyInitialized = mainContainer && mainContainer.style.display !== 'none' && 
                                         document.querySelector('.treemap-svg-container');
            if (!isAlreadyInitialized) {
                init();
            } else {
                // Already initialized, just load the client's data
                // But make sure UI handlers are set up
                setupFilterUI();
                setupAddButton();
                
                // Ensure client dropdown is populated (loadClients might not have been called)
                const select = document.getElementById('clientSelect');
                const urlParams = new URLSearchParams(window.location.search);
                const urlProject = urlParams.get('project');
                const urlSource = urlParams.get('source');
                const urlDimension = urlParams.get('dimension');
                
                // Check saved state for restoration
                const savedState = loadState();
                
                // Priority: URL params > current globals > saved state
                // This ensures values restored in handleAuthenticatedUser() are used
                const restoreState = {
                    projectName: urlProject || currentProjectName || (savedState && savedState.projectName) || null,
                    dataSourceId: urlSource || currentDataSourceId || (savedState && savedState.dataSourceId) || null,
                    questionRefKey: urlDimension || currentQuestionRefKey || (savedState && savedState.questionRefKey) || null
                };
                
                // Update globals if we have values from URL or saved state (but not if already set from handleAuthenticatedUser)
                if (restoreState.projectName && !currentProjectName) {
                    currentProjectName = restoreState.projectName;
                    window.appStateSetCurrentProjectName(restoreState.projectName);
                }
                if (restoreState.dataSourceId && !currentDataSourceId) {
                    currentDataSourceId = restoreState.dataSourceId;
                    window.appStateSetCurrentDataSourceId(restoreState.dataSourceId);
                }
                if (restoreState.questionRefKey && !currentQuestionRefKey) {
                    currentQuestionRefKey = restoreState.questionRefKey;
                    window.appStateSetCurrentQuestionRefKey(restoreState.questionRefKey);
                }
                
                if (select && (select.innerHTML === '' || select.innerHTML.includes('Loading'))) {
                    console.log('Client dropdown not populated, loading clients...');
                    // Temporarily set hasAutoLaunched to prevent loadClients from triggering another launch
                    const wasAutoLaunched = hasAutoLaunched;
                    hasAutoLaunched = true;
                    loadClients().then(() => {
                        // Restore the flag
                        hasAutoLaunched = wasAutoLaunched;
                        // After clients are loaded, load the specific client's data
                        return loadClientProjects(clientId, restoreState);
                    }).then(() => {
                        // renderFavourites(); // Removed - favourites section no longer exists
                        updateNavLinks(); // Update nav links after client loads
                    }).catch((error) => {
                        console.error('Error loading clients or projects:', error);
                        hasAutoLaunched = wasAutoLaunched;
                    });
                } else {
                    // Dropdown already populated, just load the client's data
                    loadClientProjects(clientId, restoreState).then(() => {
                        // renderFavourites(); // Removed - favourites section no longer exists
                        updateNavLinks(); // Update nav links after client loads
                    });
                }
            }
        }

        function handleAuthenticatedUser(userInfo) {
            if (!userInfo) {
                return;
            }

            authenticatedUser = userInfo;
            showHeaderUserInfo(userInfo);
            updateAccessibleClients(userInfo.accessible_clients || []);
            
            // Show/hide founder admin nav items
            const adminNavItem = document.getElementById('navFounderAdmin');
            const promptsNavItem = document.getElementById('navPrompts');
            if (adminNavItem) {
                if (userInfo.is_founder) {
                    adminNavItem.classList.remove('hidden');
                } else {
                    adminNavItem.classList.add('hidden');
                }
            }
            if (promptsNavItem) {
                if (userInfo.is_founder) {
                    promptsNavItem.classList.remove('hidden');
                } else {
                    promptsNavItem.classList.add('hidden');
                }
            }

            if (accessibleClients.length === 0) {
                const errorEl = document.getElementById('accountSelectionError');
                if (errorEl) {
                    errorEl.textContent = 'No accounts are linked to your email yet. Please contact your administrator.';
                    errorEl.style.display = 'block';
                }
                if (typeof Auth !== 'undefined') {
                    Auth.showLogin();
                }
                return;
            }

            // Check for client_uuid in URL - if present and accessible, auto-launch
            const urlParams = new URLSearchParams(window.location.search);
            const urlClientUuid = urlParams.get('client_uuid');
            if (urlClientUuid) {
                // Check if the client_uuid is in the accessible clients list
                const matchingClient = accessibleClients.find(client => 
                    client.client_uuid === urlClientUuid || client.id === urlClientUuid
                );
                if (matchingClient) {
                    console.log('Found client_uuid in URL, auto-launching:', urlClientUuid);
                    selectClientAndLaunch(urlClientUuid);
                    return;
                } else {
                    console.log('Client_uuid in URL not found in accessible clients:', urlClientUuid);
                }
            }

            // Check saved state - if there's a saved client that's accessible, auto-launch it
            const savedState = loadState();
            if (savedState && savedState.clientId) {
                const matchingClient = accessibleClients.find(client => 
                    client.client_uuid === savedState.clientId || client.id === savedState.clientId
                );
                if (matchingClient) {
                    console.log('Found saved client in state, auto-launching:', savedState.clientId);
                    // Restore the full state (project, source, dimension) before launching
                    // so it's available throughout the loading chain
                    if (savedState.projectName) {
                        currentProjectName = savedState.projectName;
                        window.appStateSetCurrentProjectName(savedState.projectName);
                        console.log('Restored saved project:', currentProjectName);
                    }
                    if (savedState.dataSourceId) {
                        currentDataSourceId = savedState.dataSourceId;
                        window.appStateSetCurrentDataSourceId(savedState.dataSourceId);
                        console.log('Restored saved data source:', currentDataSourceId);
                    }
                    if (savedState.questionRefKey) {
                        currentQuestionRefKey = savedState.questionRefKey;
                        window.appStateSetCurrentQuestionRefKey(savedState.questionRefKey);
                        console.log('Restored saved dimension:', currentQuestionRefKey);
                    }
                    // Update module with client ID too
                    window.appStateSetCurrentClientId(savedState.clientId);
                    currentClientId = savedState.clientId;
                    selectClientAndLaunch(savedState.clientId);
                    return;
                } else {
                    console.log('Saved client not found in accessible clients:', savedState.clientId);
                }
            }

            if (accessibleClients.length === 1) {
                selectClientAndLaunch(accessibleClients[0].id);
                return;
            }

            renderAccountSelection(accessibleClients);
        }

        window.addEventListener('auth:authenticated', (event) => {
            const userInfo = event.detail?.user;
            handleAuthenticatedUser(userInfo);
        });

        window.addEventListener('auth:magicVerified', (event) => {
            const userInfo = event.detail?.user;
            if (userInfo) {
                handleAuthenticatedUser(userInfo);
            }
        });

        window.addEventListener('auth:logout', () => {
            accessibleClients = [];
            accessibleClientIds = new Set();
            authenticatedUser = null;
            hideHeaderUserInfo();
            
            // Hide admin nav items on logout
            const adminNavItem = document.getElementById('navFounderAdmin');
            const promptsNavItem = document.getElementById('navPrompts');
            if (adminNavItem) {
                adminNavItem.classList.add('hidden');
            }
            if (promptsNavItem) {
                promptsNavItem.classList.add('hidden');
            }
        });

        // API Configuration - now imported from js/services/api-config.js module
        // API base URL from module (with fallback for module load timing)
        const API_BASE_URL = (typeof window.apiConfigGetBaseUrl === 'function') 
            ? window.apiConfigGetBaseUrl() 
            : (window.APP_CONFIG?.API_BASE_URL || 'http://localhost:8000');
        
        // Load available clients - uses API module for fetching, handles DOM/state
        async function loadClients() {
            console.log('loadClients() called');
            try {
                // Fetch clients using API module
                allClients = await window.clientsApiLoadClients({
                    accessibleClientIds: accessibleClientIds,
                    getAuthHeaders: getAuthHeaders
                });
                console.log(`Loaded ${allClients.length} clients:`, allClients);

                const select = document.getElementById('clientSelect');
                console.log('Client select element:', select);
                if (!select) {
                    console.error('Client select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (allClients.length === 0) {
                    console.log('No clients available');
                    select.innerHTML = '<option value="">No clients available</option>';
                    select.disabled = true;
                    return;
                }
                select.disabled = false;
                
                // Check URL parameters for client_uuid and other state (e.g., when navigating back)
                const urlParams = new URLSearchParams(window.location.search);
                const urlClientUuid = urlParams.get('client_uuid');
                const urlProject = urlParams.get('project');
                const urlSource = urlParams.get('source');
                const urlDimension = urlParams.get('dimension');
                
                // Try to restore saved state
                const savedState = loadState();
                console.log('Saved state:', savedState);
                console.log('URL params:', { urlClientUuid, urlProject, urlSource, urlDimension });
                
                // Priority: URL parameter > saved state > current
                // Check if URL client_uuid matches any accessible client (by id or client_uuid)
                if (urlClientUuid) {
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === urlClientUuid || client.id === urlClientUuid
                    );
                    if (matchingClient) {
                        currentClientId = urlClientUuid;
                        window.appStateSetCurrentClientId(urlClientUuid);
                        console.log('Restored client from URL:', currentClientId);
                        // Restore other state from URL if present
                        if (urlProject) {
                            currentProjectName = urlProject;
                            window.appStateSetCurrentProjectName(urlProject);
                            console.log('Restored project from URL:', currentProjectName);
                        }
                        if (urlSource) {
                            currentDataSourceId = urlSource;
                            window.appStateSetCurrentDataSourceId(urlSource);
                            console.log('Restored data source from URL:', currentDataSourceId);
                        }
                        if (urlDimension) {
                            currentQuestionRefKey = urlDimension;
                            window.appStateSetCurrentQuestionRefKey(urlDimension);
                            console.log('Restored dimension from URL:', currentQuestionRefKey);
                        }
                    }
                } else if (savedState && savedState.clientId) {
                    // Check if saved client exists in accessible clients
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === savedState.clientId || client.id === savedState.clientId
                    );
                    if (matchingClient) {
                        currentClientId = savedState.clientId;
                        window.appStateSetCurrentClientId(savedState.clientId);
                        console.log('Restored client from saved state:', currentClientId);
                    }
                }

                // Validate current client is in accessible list
                if (currentClientId) {
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === currentClientId || client.id === currentClientId
                    );
                    if (!matchingClient) {
                        console.log('Stored client is not accessible, clearing');
                        currentClientId = null;
                    }
                }

                console.log('Populating client dropdown...');
                allClients.forEach((client, index) => {
                    const option = document.createElement('option');
                    option.value = client.client_uuid;
                    option.textContent = client.client_name || `Client ${client.client_uuid}`;
                    select.appendChild(option);
                    
                    // Restore saved client or select first one by default (only if not already set from URL)
                    if (!currentClientId) {
                        if (savedState && savedState.clientId === client.client_uuid) {
                            currentClientId = client.client_uuid;
                        } else if (!savedState && index === 0) {
                            currentClientId = client.client_uuid;
                        }
                    }
                });

                if (!currentClientId && accessibleClients.length > 0) {
                    const preferredClient = accessibleClients.find(client =>
                        accessibleClientIds.has(client.id)
                    );
                    if (preferredClient) {
                        currentClientId = preferredClient.id;
                    }
                }

                // Set the select value to match the current client
                if (currentClientId) {
                    select.value = currentClientId;
                    
                    // Update header logo for initially selected client
                    const selectedClient = allClients.find(c => c.client_uuid === currentClientId);
                    if (selectedClient && typeof window.updateHeaderLogo === 'function') {
                        window.updateHeaderLogo(selectedClient.logo_url, selectedClient.header_color);
                    }
                    
                    // If we restored from URL, trigger the client selection to load data (only once)
                    // Check if we're in login/selection mode (login container visible or main container hidden)
                    // Only auto-launch if we're NOT already in the process of launching (to prevent double loads)
                    const loginContainer = document.querySelector('.login-container');
                    const mainContainer = document.getElementById('mainContainer');
                    const isLoginVisible = loginContainer && (loginContainer.style.display !== 'none' || loginContainer.classList.contains('account-selection-mode'));
                    const isMainVisible = mainContainer && mainContainer.style.display !== 'none';
                    const isInitialized = document.querySelector('.treemap-svg-container') !== null;
                    
                    // Auto-launch if we have URL params and we're in login/selection mode
                    // But NOT if we're already initialized and main container is visible (prevents double load)
                    if (urlClientUuid && urlClientUuid === currentClientId && !hasAutoLaunched && (isLoginVisible || !isMainVisible) && !isInitialized && !isMainVisible) {
                        console.log('Auto-launching client from URL:', currentClientId);
                        // Use setTimeout to ensure DOM is ready and avoid calling during loadClients
                        setTimeout(() => {
                            // Double-check we haven't launched yet (race condition protection)
                            if (!hasAutoLaunched && currentClientId === urlClientUuid) {
                                selectClientAndLaunch(currentClientId);
                            }
                        }, 300);
                    }
                }
                
                // Add change listener (remove existing one first to avoid duplicates)
                const handleClientChange = async (e) => {
                    const newClientId = e.target.value;
                    if (!newClientId || newClientId === currentClientId) {
                        return; // No change or same client
                    }
                    currentClientId = newClientId;
                    
                    // Sync Insights tab client ID to keep both tabs in sync
                    if (typeof insightsCurrentClientId !== 'undefined') {
                        insightsCurrentClientId = newClientId;
                    }
                    
                    // Load insights for the visualizations panel (async, doesn't block)
                    if (typeof loadInsightsPage === 'function') {
                        loadInsightsPage().catch(err => console.warn('Failed to load insights for panel:', err));
                    }
                    
                    // Update header logo for the selected client
                    const selectedClient = allClients.find(c => c.client_uuid === newClientId);
                    if (selectedClient && typeof window.updateHeaderLogo === 'function') {
                        window.updateHeaderLogo(selectedClient.logo_url, selectedClient.header_color);
                    }
                    
                    currentProjectName = null; // Reset project when client changes
                    currentDataSourceId = null; // Reset data source when client changes
                    currentQuestionRefKey = null; // Reset question when client changes
                    dimensionFilters = {}; // Clear dimension filters when client changes
                    saveState();
                    updateAddDataButton(); // Update Add button with new client
                    await loadClientProjects(currentClientId);
                    renderFavourites(); // Re-render favourites for new client
                };
                // Remove any existing listener
                select.removeEventListener('change', handleClientChange);
                select.addEventListener('change', handleClientChange);
                
                // Load projects for the selected client (only if not already loading from selectClientAndLaunch)
                // Create a combined state object with priority: URL params > current globals > saved state
                // This ensures values restored in handleAuthenticatedUser() are used
                const restoreState = {
                    projectName: urlProject || currentProjectName || (savedState && savedState.projectName) || null,
                    dataSourceId: urlSource || currentDataSourceId || (savedState && savedState.dataSourceId) || null,
                    questionRefKey: urlDimension || currentQuestionRefKey || (savedState && savedState.questionRefKey) || null
                };
                
                // Only auto-load projects if we're not already in the process of launching a client
                // (to prevent double loading when called from selectClientAndLaunch)
                // But allow loading if we're in the main view and not already initialized (page refresh scenario)
                const mainContainer = document.getElementById('mainContainer');
                const isMainVisible = mainContainer && mainContainer.style.display !== 'none';
                const isInitialized = document.querySelector('.treemap-svg-container') !== null;
                // Load if: not auto-launched yet, OR main is not visible, OR (main is visible but not initialized - refresh scenario)
                const shouldAutoLoad = !hasAutoLaunched || !isMainVisible || (isMainVisible && !isInitialized);
                
                if (currentClientId && shouldAutoLoad) {
                    console.log(`Loading projects for client: ${currentClientId} with state:`, restoreState);
                    await loadClientProjects(currentClientId, restoreState);
                } else if (currentClientId) {
                    console.log('Skipping auto-load of projects (already loading from selectClientAndLaunch)');
                } else {
                    console.log('No client selected, skipping project load');
                }
                syncFilterTabState();
                
                // Set up Add button handler
                setupAddButton();
            } catch (error) {
                console.error('Error loading clients:', error);
                console.error('Error stack:', error.stack);
                const select = document.getElementById('clientSelect');
                select.innerHTML = '<option value="">Error loading clients</option>';
                syncFilterTabState();
            }
        }
        
        // Load projects for a specific client - wrapper that uses API module for fetching, handles DOM/state
        async function loadClientProjects(clientId, savedState = null) {
            console.log(`loadClientProjects() called for client: ${clientId}`);
            try {
                // Restore saved project name if available
                if (savedState && savedState.projectName) {
                    currentProjectName = savedState.projectName;
                    console.log(`Restoring saved project: ${currentProjectName}`);
                }
                
                // Fetch projects using API module
                clientProjects = await window.dataSourcesApiLoadProjects(clientId, getAuthHeaders);
                console.log(`Loaded ${clientProjects.length} projects:`, clientProjects);
                
                const select = document.getElementById('projectSelect');
                console.log('Project select element:', select);
                if (!select) {
                    console.error('Project select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (clientProjects.length === 0) {
                    console.log('No projects available');
                    select.innerHTML = '<option value="">No projects available</option>';
                    currentProjectName = null;
                } else {
                    console.log('Populating project dropdown...');
                    clientProjects.forEach((project) => {
                        const option = document.createElement('option');
                        option.value = project.project_name;
                        option.textContent = project.project_name || 'Unknown Project';
                        select.appendChild(option);
                    });
                    
                    // Validate that the saved project name exists in the list
                    if (currentProjectName) {
                        const projectExists = clientProjects.some(p => p.project_name === currentProjectName);
                        if (!projectExists) {
                            console.warn(`Saved project "${currentProjectName}" not found in available projects, defaulting to first`);
                            currentProjectName = null;
                        }
                    }
                    
                    // Default to first project if no saved selection
                    if (!currentProjectName && clientProjects.length > 0) {
                        currentProjectName = clientProjects[0].project_name;
                        console.log(`Defaulting to first project: ${currentProjectName}`);
                    }
                    
                    console.log(`Current project name after validation: ${currentProjectName}`);
                    
                    // Set the select value to match the current project
                    if (currentProjectName) {
                        select.value = currentProjectName;
                        console.log(`Set select value to: ${currentProjectName}`);
                    }
                }
                
                // Add change listener (only once)
                select.removeEventListener('change', handleProjectChange);
                select.addEventListener('change', handleProjectChange);
                console.log('Added change listener to project select');
                
                // Load sources for the selected client (and project if selected)
                if (currentClientId) {
                    console.log(`Loading sources for client: ${currentClientId}, project: ${currentProjectName || 'None'}`);
                    await loadClientSources(currentClientId, savedState);
                } else {
                    console.log('No client selected, skipping source load');
                }
                syncFilterTabState();
            } catch (error) {
                console.error('Error loading projects:', error);
                const select = document.getElementById('projectSelect');
                if (select) {
                    select.innerHTML = '<option value="">Error loading projects</option>';
                }
                syncFilterTabState();
            }
        }
        
        // Handle project selection change
        async function handleProjectChange(e) {
            currentProjectName = e.target.value || null; // Empty string becomes null
            currentDataSourceId = null; // Reset data source when project changes
            currentQuestionRefKey = null; // Reset question when project changes
            dimensionFilters = {}; // Clear dimension filters when project changes
            saveState();
            updateNavLinks(); // Update nav links after project changes
            await loadClientSources(currentClientId);
            renderFavourites(); // Re-render favourites for new project
        }
        
        // Load sources for a specific client - wrapper that uses API module for fetching, handles DOM/state
        async function loadClientSources(clientId, savedState = null) {
            console.log(`loadClientSources() called for client: ${clientId}, project: ${currentProjectName || 'None'}`);
            try {
                // Fetch sources using API module
                clientSources = await window.dataSourcesApiLoadSources(clientId, currentProjectName, getAuthHeaders);
                console.log(`Loaded ${clientSources.length} sources:`, clientSources);
                
                const select = document.getElementById('sourceSelect');
                console.log('Source select element:', select);
                if (!select) {
                    console.error('Source select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (clientSources.length === 0) {
                    console.log('No sources available');
                    select.innerHTML = '<option value="">No sources available</option>';
                    currentDataSourceId = null;
                } else {
                    console.log('Populating source dropdown...');
                    clientSources.forEach((source) => {
                        const option = document.createElement('option');
                        option.value = source.data_source;
                        option.textContent = source.data_source || 'Unknown Source';
                        select.appendChild(option);
                    });
                    
                    // Restore saved data source from savedState if it exists
                    if (savedState && savedState.dataSourceId) {
                        // Validate that the saved data source exists in the list
                        const sourceExists = clientSources.some(s => s.data_source === savedState.dataSourceId);
                        if (sourceExists) {
                            currentDataSourceId = savedState.dataSourceId;
                            console.log(`Restored saved data source: ${currentDataSourceId}`);
                        } else {
                            console.warn(`Saved data source "${savedState.dataSourceId}" not found in available sources, defaulting to first`);
                            currentDataSourceId = null;
                        }
                    }
                    
                    // Default to first source if no saved selection
                    if (!currentDataSourceId && clientSources.length > 0) {
                        currentDataSourceId = clientSources[0].data_source;
                        console.log(`Defaulting to first source: ${currentDataSourceId}`);
                    }
                    
                    console.log(`Current data source ID after validation: ${currentDataSourceId}`);
                    
                    // Set the select value to match the current data source
                    if (currentDataSourceId) {
                        select.value = currentDataSourceId;
                        console.log(`Set select value to: ${currentDataSourceId}`);
                    }
                }
                
                // Add change listener (only once)
                select.removeEventListener('change', handleSourceChange);
                select.addEventListener('change', handleSourceChange);
                console.log('Added change listener to source select');
                syncFilterTabState();
                
                // Load data for the selected source
                console.log(`About to load data: client=${clientId}, source=${currentDataSourceId || 'None'}`);
                await loadDataSource(clientId, currentDataSourceId, savedState);
                console.log('loadDataSource completed');
            } catch (error) {
                console.error('Error loading sources:', error);
                const select = document.getElementById('sourceSelect');
                select.innerHTML = '<option value="">Error loading sources</option>';
                syncFilterTabState();
            }
        }
        
        // Handle source selection change
        async function handleSourceChange(e) {
            currentDataSourceId = e.target.value || null; // Empty string becomes null
            currentQuestionRefKey = null; // Reset question when source changes
            dimensionFilters = {}; // Clear dimension filters when data source changes
            saveState();
            updateNavLinks(); // Update nav links after source changes
            await loadDataSource(currentClientId, currentDataSourceId);
        }
        
        // Update treemap title with question text if available
        function updateTreemapTitle() {
            const treemapTitleEl = document.querySelector('.treemap-title');
            if (!treemapTitleEl || !fullRawData || fullRawData.length === 0) {
                return;
            }
            
            let questionText = null;
            
            // Only show question_text when a specific dimension is selected
            // This avoids confusion when "All Dimensions" is selected (multiple questions possible)
            if (currentQuestionRefKey) {
                const dimensionRow = fullRawData.find(row => 
                    row.dimension_ref === currentQuestionRefKey && 
                    row.question_text && 
                    row.question_text.trim() !== ''
                );
                if (dimensionRow) {
                    questionText = dimensionRow.question_text;
                }
            }
            
            // Update the title
            if (questionText) {
                treemapTitleEl.textContent = questionText;
            } else {
                treemapTitleEl.textContent = 'Topic Distribution';
            }
        }
        
        // Update breadcrumb display
        function updateBreadcrumb(questionRefKey) {
            const client = allClients.find(c => c.client_uuid === currentClientId);
            const source = currentDataSourceId ? clientSources.find(s => s.data_source === currentDataSourceId) : null;
            
            if (client) {
                let breadcrumb = `${client.client_name || 'Unknown Client'}`;
                
                // Add project to breadcrumb if selected
                if (currentProjectName) {
                    breadcrumb += ` > ${currentProjectName}`;
                }
                
                // Add source to breadcrumb if selected
                if (source) {
                    breadcrumb += ` > ${source.data_source || 'Unknown Source'}`;
                }
                
                // Add question to breadcrumb if specified
                if (questionRefKey) {
                    const questionLabel = questionRefKey.replace('ref_', 'Q');
                    breadcrumb += ` > ${questionLabel}`;
                }
                
                // Update header subtitle if it exists
                const headerP = document.querySelector('.header p');
                if (headerP && !headerP.classList.contains('breadcrumb-display')) {
                    headerP.innerHTML = `Topic visualization and analysis<br><span class="breadcrumb-display">${breadcrumb}</span>`;
                }
            }
        }
        
        // Toggle skeleton loading states
        function setLoading(isLoading) {
            const treemapContainer = document.querySelector('.treemap-svg-container');
            const charts = document.querySelectorAll('.chart');
            if (treemapContainer) {
                treemapContainer.classList.toggle('is-loading', isLoading);
            }
            charts.forEach(c => c.classList.toggle('is-loading', isLoading));
        }

        // Group process_voc rows by respondent_id and merge topics
        function groupProcessVocRows(processVocRows, dimensionRef = null) {
            console.log(`Grouping ${processVocRows.length} rows${dimensionRef ? ` for dimension ${dimensionRef}` : ' (all dimensions)'}`);
            
            // Filter by dimension if specified
            let filteredRows = dimensionRef 
                ? processVocRows.filter(row => row.dimension_ref === dimensionRef)
                : processVocRows;
            
            console.log(`Filtered to ${filteredRows.length} rows`);
            
            // When "All Dimensions" is selected, we need to preserve dimension context with topics
            // to avoid mixing verbatims from different dimensions
            if (!dimensionRef) {
                // Group by respondent_id AND dimension_ref to keep topics separate
                const grouped = {};
                let totalTopics = 0;
                let rowsWithoutTopics = 0;
                
                filteredRows.forEach(row => {
                    const key = `${row.respondent_id}::${row.dimension_ref}`;
                    if (!grouped[key]) {
                        // Build metadata object from survey_metadata
                        // Handle both structures: survey_metadata.metadata (nested) or survey_metadata (direct)
                        // The database stores metadata directly in survey_metadata, not nested under 'metadata'
                        const surveyMetadata = row.survey_metadata?.metadata || row.survey_metadata || {};
                        
                        // Merge survey metadata with other fields that aren't part of survey_metadata
                        // (These are always needed regardless of survey_metadata)
                        // Note: dimension_name is removed from metadata as requested
                        const metadata = {
                            ref_key: row.dimension_ref,
                            source_type: row.data_source || '',
                            created_at: row.created,
                            sentiment: row.overall_sentiment || 'neutral',
                            // Merge in all fields from survey_metadata (handles both nested and direct structures)
                            ...surveyMetadata
                        };
                        
                        grouped[key] = {
                            row_id: row.respondent_id,
                            text: row.value || '',
                            topics: [],
                            sentiment: row.overall_sentiment || 'neutral',
                            metadata: metadata,
                            dimension_ref: row.dimension_ref // Preserve dimension for topic matching
                        };
                    }
                    
                    // Add topics with dimension context
                    if (row.topics && Array.isArray(row.topics)) {
                        // Attach dimension_ref to each topic so we can match verbatims correctly
                        const topicsWithDimension = row.topics.map(topic => ({
                            ...topic,
                            _dimension_ref: row.dimension_ref // Internal field for matching
                        }));
                        grouped[key].topics.push(...topicsWithDimension);
                        totalTopics += row.topics.length;
                    } else {
                        rowsWithoutTopics++;
                    }
                    
                    // Use first non-empty value as text
                    if (!grouped[key].text && row.value) {
                        grouped[key].text = row.value;
                    }
                });
                
                const result = Object.values(grouped);
                console.log(`Grouped into ${result.length} unique respondent-dimension combinations with ${totalTopics} total topics`);
                if (rowsWithoutTopics > 0) {
                    console.log(`Note: ${rowsWithoutTopics} row(s) without topics (expected behavior - some dimensions may not have topics)`);
                }
                if (result.length > 0) {
                }
                
                return result;
            } else {
                // Single dimension: group by respondent_id only (original behavior)
                const grouped = {};
                let totalTopics = 0;
                let rowsWithoutTopics = 0;
                
                filteredRows.forEach(row => {
                    const respondentId = row.respondent_id;
                    if (!grouped[respondentId]) {
                        // Build metadata object from survey_metadata
                        // Handle both structures: survey_metadata.metadata (nested) or survey_metadata (direct)
                        // The database stores metadata directly in survey_metadata, not nested under 'metadata'
                        const surveyMetadata = row.survey_metadata?.metadata || row.survey_metadata || {};
                        
                        // Merge survey metadata with other fields that aren't part of survey_metadata
                        // (These are always needed regardless of survey_metadata)
                        // Note: dimension_name is removed from metadata as requested
                        const metadata = {
                            ref_key: dimensionRef || row.dimension_ref,
                            source_type: row.data_source || '',
                            created_at: row.created,
                            sentiment: row.overall_sentiment || 'neutral',
                            // Merge in all fields from survey_metadata (handles both nested and direct structures)
                            ...surveyMetadata
                        };
                        
                        grouped[respondentId] = {
                            row_id: respondentId,
                            text: row.value || '',
                            topics: [],
                            sentiment: row.overall_sentiment || 'neutral',
                            metadata: metadata
                        };
                    }
                    
                    // Merge topics from this dimension
                    if (row.topics && Array.isArray(row.topics)) {
                        grouped[respondentId].topics.push(...row.topics);
                        totalTopics += row.topics.length;
                    } else {
                        // Track rows without topics (expected for some dimensions)
                        rowsWithoutTopics++;
                    }
                    
                    // Use first non-empty value as text
                    if (!grouped[respondentId].text && row.value) {
                        grouped[respondentId].text = row.value;
                    }
                });
                
                const result = Object.values(grouped);
                console.log(`Grouped into ${result.length} unique respondents with ${totalTopics} total topics`);
                if (rowsWithoutTopics > 0) {
                    console.log(`Note: ${rowsWithoutTopics} row(s) without topics${dimensionRef ? ` for dimension ${dimensionRef}` : ''} (expected behavior - some dimensions may not have topics)`);
                }
                if (result.length > 0) {
                }
                
                return result;
            }
        }

        // Load a specific data source - wrapper that uses API module for fetching, handles DOM/state
        async function loadDataSource(clientUuid, dataSource, savedState = null) {
            console.log(`loadDataSource() called: client=${clientUuid}, project=${currentProjectName || 'None'}, source=${dataSource || 'None'}`);
            try {
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loading').innerHTML = 'Loading data...';
                setLoading(true);
                
                // Fetch VOC data using API module
                const processVocRows = await window.vocDataApiLoadVocData(clientUuid, currentProjectName, dataSource, getAuthHeaders);
                console.log(`Loaded ${processVocRows.length} process_voc rows`);
                
                // Store raw process_voc rows
                fullRawData = processVocRows;
                
                // Update treemap title with question text if available
                updateTreemapTitle();
                
                // Update breadcrumb
                updateBreadcrumb();
                
                // Detect if this is survey data with multiple questions
                // This will set up the question filter and call filterByQuestion which groups and renders
                await detectAndSetupQuestionFilter(savedState);
                
                // If detectAndSetupQuestionFilter didn't set up questions (no dimensions found),
                // or if it returned early, we need to group and render the data ourselves
                // filterByQuestion should have been called if questions were found, but as a fallback:
                if (!rawData || rawData.length === 0) {
                    console.log('No data grouped yet, grouping now...');
                    const groupedData = groupProcessVocRows(fullRawData, null);
                    rawData = groupedData;
                    dimensionFilteredData = groupedData; // Set to grouped data (has text field)
                    
                    // Extract and setup category filter
                    extractAvailableFilterOptions(rawData);
                    filterRules = []; // Reset filters when loading new data
                    updateFilterUI();
                    
                    // Process and render
                    processData();
                    renderTreemap(hierarchyData);
                    renderBarChart();
                    renderTopicsChart();
                }
                // Otherwise, filterByQuestion already handled grouping and rendering
                
                document.getElementById('loading').style.display = 'none';
                setLoading(false);
            } catch (error) {
                console.error('Error in loadDataSource:', error);
                document.getElementById('loading').innerHTML = 
                    '<div class="error">Error loading data: ' + error.message + '</div>';
                setLoading(false);
            }
        }
        
        // Load dimension names from API - wrapper that uses API module for fetching, handles DOM/state
        async function loadDimensionNames() {
            if (!currentDataSourceId) return;
            
            try {
                const dimensionNames = await window.vocDataApiLoadDimensionNames(currentDataSourceId, getAuthHeaders);
                
                // Update dimension names map
                if (dimensionNames && dimensionNames.length > 0) {
                    dimensionNamesMap = {};
                    dimensionNames.forEach(dn => {
                        dimensionNamesMap[dn.ref_key] = dn.custom_name;
                    });
                    // Sync to module state so getDimensionDisplayName works
                    if (window.apiCacheSetDimensionNamesMap) {
                        window.apiCacheSetDimensionNamesMap(dimensionNamesMap);
                    }
                }
            } catch (error) {
                console.error('Error loading dimension names:', error);
            }
        }
        
        // Get display name for a dimension - wrapper that uses format module
        function getDimensionDisplayName(refKey) {
            const map = window.apiCacheGetDimensionNamesMap();
            return window.formatGetDimensionDisplayName(refKey, map);
        }
        
        // Get question type for current dimension
        function getCurrentQuestionType() {
            if (!currentQuestionRefKey) return null;
            return questionTypesMap[currentQuestionRefKey] || null;
        }
        
        // Detect survey format and setup question filter
        async function detectAndSetupQuestionFilter(savedState = null) {
            const questionSelect = document.getElementById('questionSelect');
            const dimensionNameEditor = document.getElementById('dimensionNameEditor');
            
            // Validate we have client and data source
            if (!currentClientId || !currentDataSourceId) {
                console.warn('No client or data source selected');
                questionSelect.style.display = 'none';
                document.getElementById('questionLabel').style.display = 'none';
                dimensionNameEditor.style.display = 'none';
                // Hide AI Insights tab when no data source
                if (window.AIInsightsPanel) {
                    window.AIInsightsPanel.setCurrentDimension('');
                }
                syncFilterTabState();
                return;
            }
            
            try {
                // Load questions from API using module
                const questions = await window.vocDataApiLoadQuestions(currentClientId, currentDataSourceId, currentProjectName, getAuthHeaders);
                
                // Build dimension names map and question types map from API response first
                dimensionNamesMap = {};
                questionTypesMap = {};
                questions.forEach(q => {
                    if (q.dimension_name) {
                        dimensionNamesMap[q.dimension_ref] = q.dimension_name;
                    }
                    if (q.question_type) {
                        questionTypesMap[q.dimension_ref] = q.question_type;
                    }
                });
                
                // Sync to module state so getDimensionDisplayName works
                if (window.apiCacheSetDimensionNamesMap) {
                    window.apiCacheSetDimensionNamesMap(dimensionNamesMap);
                }
                
                // Filter to only dimensions that have topics (response_count > 0)
                availableQuestions = questions
                    .filter(q => q.response_count > 0)
                    .map(q => q.dimension_ref);
                
                // Sort dimensions alphabetically by display name
                availableQuestions.sort((a, b) => {
                    const nameA = (getDimensionDisplayName(a) || '').toLowerCase();
                    const nameB = (getDimensionDisplayName(b) || '').toLowerCase();
                    return nameA.localeCompare(nameB);
                });
                
                console.log(`Found ${availableQuestions.length} dimensions with data`);
                
                if (availableQuestions.length === 0) {
                    // Hide question selector if no questions
                    questionSelect.style.display = 'none';
                    document.getElementById('questionLabel').style.display = 'none';
                    dimensionNameEditor.style.display = 'none';
                    // Hide AI Insights tab when no dimensions available
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension('');
                    }
                    syncFilterTabState();
                    return;
                }
                
                // Populate question selector
                questionSelect.innerHTML = '';
                availableQuestions.forEach(refKey => {
                    const option = document.createElement('option');
                    option.value = refKey;
                    option.textContent = getDimensionDisplayName(refKey);
                    questionSelect.appendChild(option);
                });
                
                // Add "All Dimensions" option at the bottom
                const allDimensionsOption = document.createElement('option');
                allDimensionsOption.value = '';
                allDimensionsOption.textContent = 'All Dimensions';
                questionSelect.appendChild(allDimensionsOption);
                
                // Show question selector
                questionSelect.style.display = 'inline';
                document.getElementById('questionLabel').style.display = 'inline';
                syncFilterTabState();
                
                // Add change listener
                questionSelect.onchange = function() {
                    const selectedRefKey = this.value;
                    const previousRefKey = currentQuestionRefKey; // Save old value before updating
                    currentQuestionRefKey = selectedRefKey;
                    saveState();
                    filterByQuestion(selectedRefKey, previousRefKey);
                    
                    // Update navigation links to include the new dimension
                    updateNavLinks();
                    
                    // Update AI Insights panel with current dimension (will show/hide tab)
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(selectedRefKey);
                    }
                    
                    // Re-render insights table so pinning updates for the new dimension
                    if (typeof renderInsights === 'function') {
                        renderInsights();
                    }
                    
                    // Show/hide dimension name editor based on selection
                    if (selectedRefKey && selectedRefKey !== '') {
                        dimensionNameEditor.style.display = 'none'; // Hidden for now
                    } else {
                        dimensionNameEditor.style.display = 'none';
                    }
                };
                
                // Setup inline dimension editor
                setupInlineDimensionEditor();
                
                // Restore saved question or default to first dimension
                let questionToSelect = null;
                if (savedState && savedState.questionRefKey !== undefined) {
                    // Allow empty string for "All Dimensions" or specific dimension
                    if (savedState.questionRefKey === '' || availableQuestions.includes(savedState.questionRefKey)) {
                        questionToSelect = savedState.questionRefKey;
                    }
                }
                // Default to first dimension if nothing was restored (but not if "All Dimensions" was explicitly saved)
                if (questionToSelect === null && availableQuestions.length > 0) {
                    questionToSelect = availableQuestions[0];
                }
                
                // Apply the selection (questionToSelect can be empty string for "All Dimensions" or a dimension ref)
                if (questionToSelect !== null) {
                    const previousRefKey = currentQuestionRefKey; // Save old value before updating
                    currentQuestionRefKey = questionToSelect;
                    questionSelect.value = questionToSelect;
                    filterByQuestion(questionToSelect, previousRefKey);
                    dimensionNameEditor.style.display = 'none';
                    // Update AI Insights panel with restored dimension
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(questionToSelect);
                    }
                }
                syncFilterTabState();
            } catch (error) {
                console.error('Error loading questions:', error);
                // Hide question selector on error
                questionSelect.style.display = 'none';
                document.getElementById('questionLabel').style.display = 'none';
                dimensionNameEditor.style.display = 'none';
                availableQuestions = [];
                // Hide AI Insights tab on error
                if (window.AIInsightsPanel) {
                    window.AIInsightsPanel.setCurrentDimension('');
                }
                syncFilterTabState();
            }
        }
        
        // Filter data by selected question
        // Helper functions to serialize/deserialize filter rules (Sets need special handling)
        function serializeFilterRules(rules) {
            return rules.map(rule => ({
                type: rule.type,
                mode: rule.mode,
                values: Array.from(rule.values), // Convert Set to Array
                metadataField: rule.metadataField
            }));
        }
        
        function deserializeFilterRules(serializedRules) {
            if (!serializedRules) return [];
            return serializedRules.map(rule => ({
                type: rule.type,
                mode: rule.mode,
                values: new Set(rule.values), // Convert Array back to Set
                metadataField: rule.metadataField
            }));
        }
        
        function saveFiltersForDimension(dimensionRef) {
            // Save current filters for the given dimension
            const key = dimensionRef || 'all';
            dimensionFilters[key] = serializeFilterRules(filterRules);
            console.log(`Saved filters for dimension ${key}:`, dimensionFilters[key]);
        }
        
        function loadFiltersForDimension(dimensionRef) {
            // Load saved filters for the given dimension, or return empty array
            const key = dimensionRef || 'all';
            const savedFilters = dimensionFilters[key];
            if (savedFilters) {
                filterRules = deserializeFilterRules(savedFilters);
                console.log(`Loaded filters for dimension ${key}:`, filterRules);
            } else {
                filterRules = [];
                console.log(`No saved filters for dimension ${key}, using empty filters`);
            }
        }
        
        function filterByQuestion(refKey, previousRefKey = null) {
            // Save current filters for the previous dimension before switching
            // Use previousRefKey if provided (from onchange handler), otherwise use currentQuestionRefKey
            const oldRefKey = previousRefKey !== null ? previousRefKey : currentQuestionRefKey;
            if (oldRefKey !== null) {
                saveFiltersForDimension(oldRefKey);
            } else if (oldRefKey === null && refKey !== null && refKey !== '') {
                // Switching from "all dimensions" to a specific dimension
                saveFiltersForDimension(null);
            }
            
            // Group process_voc rows with optional dimension filter
            const groupedData = groupProcessVocRows(fullRawData, refKey || null);
            
            // Set rawData to the grouped and filtered data
            rawData = groupedData;
            dimensionFilteredData = groupedData; // Keep grouped data for re-filtering (has text field)
            
            console.log(`Filtered to ${rawData.length} grouped rows for question: ${refKey || 'all'}`);
            
            // Extract available filter options from the filtered data (dimension-specific)
            extractAvailableFilterOptions(rawData);
            
            // Load saved filters for the new dimension (or empty if none)
            loadFiltersForDimension(refKey || null);
            
            updateFilterUI();
            
            // Update breadcrumb to show question selection
            updateBreadcrumb(refKey);
            
            // Update treemap title with question text if available
            updateTreemapTitle();
            
            // Re-render visualizations (this will apply the restored filters)
            applyFiltersAndRender();
        }
        
        // Initialize
        async function init() {
            // Prevent multiple simultaneous initializations
            if (isInitializing) {
                console.log('init() already in progress, skipping...');
                return;
            }
            isInitializing = true;
            console.log('init() called');
            try {
                console.log('Loading dimension options...');
                // Load dimension options from localStorage
                loadDimensionOptions();
                
                console.log('Setting up container dimensions...');
                // Set dimensions based on container
                // Only set dimensions if container is visible, otherwise wait for view switch
                const container = document.querySelector('.treemap-svg-container');
                const vizSection = document.getElementById('visualizations-section');
                const isVizSectionVisible = vizSection && (vizSection.classList.contains('active') || vizSection.style.display !== 'none');
                
                if (container && isVizSectionVisible) {
                    width = container.clientWidth;
                    height = container.clientHeight;
                    console.log('Container dimensions set:', { width, height });
                } else {
                    // Container is hidden, use defaults but they'll be recalculated when section becomes visible
                    console.log('Container is hidden, using default dimensions (will recalculate when visible)');
                    width = 800;
                    height = 600;
                }
                
                console.log('Loading clients...');
                // Load clients from API (which will cascade to sources and data)
                await loadClients();
                
                // Setup advanced filter UI
                setupFilterUI();
                
                // Initialize favourites section
                renderFavourites();
            } catch (error) {
                document.getElementById('loading').innerHTML = 
                    '<div class="error">Error initializing: ' + error.message + '</div>';
            } finally {
                isInitializing = false;
            }
        }

        // Advanced Multi-Filter Functions
        function extractAvailableFilterOptions(data) {
            const categories = new Set();
            const topics = new Set();
            const metadataFields = {}; // Map of fieldName -> Set of values
            
            data.forEach(row => {
                if (row && row.topics) {
                    row.topics.forEach(topic => {
                        if (topic && topic.category) {
                            categories.add(topic.category);
                        }
                        if (topic && topic.label) {
                            topics.add(topic.label);
                        }
                    });
                }
                if (row && row.metadata) {
                    // Extract all metadata fields as-is from raw metadata (no computation, no mapping)
                    // This ensures ALL fields from survey_metadata.metadata are available for filtering
                    Object.keys(row.metadata).forEach(key => {
                        if (!metadataFields[key]) {
                            metadataFields[key] = new Set();
                        }
                        const value = row.metadata[key];
                        if (value !== null && value !== undefined) {
                            // Convert to string for consistency (including empty strings)
                            const strValue = String(value);
                            // Always add trimmed value (including empty string if original was empty)
                            // Empty strings will be filtered out later when building availableMetadataFields
                            const trimmedValue = strValue.trim();
                            // Store the normalized value - this is what we'll compare against during filtering
                            metadataFields[key].add(trimmedValue);
                        }
                    });
                }
                // Also check row-level sentiment (in case it's not in metadata)
                if (row && row.sentiment) {
                    if (!metadataFields['sentiment']) {
                        metadataFields['sentiment'] = new Set();
                    }
                    metadataFields['sentiment'].add(row.sentiment);
                }
            });
            
            availableCategories = Array.from(categories).sort();
            availableTopics = Array.from(topics).sort();
            availableLocations = []; // No longer computed, kept for backwards compatibility
            
            // Convert metadata field Sets to sorted arrays
            // Exclude sentiment and dimension_name from metadata fields (sentiment is top-level, dimension_name removed)
            availableMetadataFields = {};
            let sentimentValues = [];
            Object.keys(metadataFields).forEach(key => {
                // Skip dimension_name (removed from UI)
                if (key === 'dimension_name') return;
                
                // Store sentiment separately for top-level filter
                if (key === 'sentiment') {
                    sentimentValues = Array.from(metadataFields[key]).sort();
                } else {
                    // Filter out empty strings and get only non-empty values
                    const nonEmptyValues = Array.from(metadataFields[key])
                        .filter(val => val !== null && val !== undefined && String(val).trim() !== '')
                        .sort();
                    
                    // Only include the field if it has at least one non-empty value
                    if (nonEmptyValues.length > 0) {
                        availableMetadataFields[key] = nonEmptyValues;
                    }
                }
            });
            
            // Populate filter type list dynamically after extracting options
            populateFilterTypeList(sentimentValues);
        }
        
        function populateFilterTypeList(sentimentValues = []) {
            const filterTypeList = document.getElementById('filterTypeList');
            if (!filterTypeList) return;
            
            filterTypeList.innerHTML = '';
            
            // Always show Category and Topic
            const staticFilters = [
                {
                    type: 'category',
                    label: 'Category',
                    description: 'Filter by conversation categories'
                },
                {
                    type: 'topic',
                    label: 'Topic',
                    description: 'Filter by specific topics'
                }
            ];
            
            // Add Sentiment as top-level filter if available
            if (sentimentValues && sentimentValues.length > 0) {
                staticFilters.push({
                    type: 'sentiment',
                    label: 'Sentiment',
                    description: 'Filter by sentiment (positive, negative, neutral)'
                });
                // Store sentiment values in availableMetadataFields for getAvailableItemsForType
                availableMetadataFields['sentiment'] = sentimentValues;
            }
            
            // Add Metadata as a top-level option that opens the metadata field selection view
            const metadataFieldCount = Object.keys(availableMetadataFields)
                .filter(key => key !== 'sentiment' && key !== 'dimension_name')
                .length;
            
            if (metadataFieldCount > 0) {
                staticFilters.push({
                    type: 'metadata',
                    label: 'Metadata',
                    description: `Filter by ${metadataFieldCount} metadata field${metadataFieldCount !== 1 ? 's' : ''}`
                });
            }
            
            // Create filter type options (only top-level: Category, Topic, Sentiment, Metadata)
            staticFilters.forEach(filter => {
                const option = document.createElement('div');
                option.className = 'filter-type-option';
                option.dataset.type = filter.type;
                option.style.cssText = 'padding: 12px; margin: 4px 0; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; transition: background 0.2s;';
                option.onmouseover = () => option.style.background = '#f5f5f5';
                option.onmouseout = () => option.style.background = 'transparent';
                option.onclick = () => {
                    currentFilterType = filter.type;
                    currentFilterSelections.clear();
                    if (filter.type === 'metadata') {
                        // Metadata opens the metadata field selection view (second level)
                        currentMetadataField = null;
                        showMetadataFieldView();
                    } else {
                        // Category, Topic, or Sentiment - go directly to value selection
                        currentMetadataField = null;
                        showFilterSelectionView();
                    }
                };
                
                option.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 14px; color: #333;">${filter.label}</strong>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${filter.description}</div>
                        </div>
                        <span style="font-size: 18px;"></span>
                    </div>
                `;
                
                filterTypeList.appendChild(option);
            });
        }

        function applyFiltersAndRender() {
            let filteredData = dimensionFilteredData;
            
            // Debug: Check if dimensionFilteredData is empty
            if (!dimensionFilteredData || dimensionFilteredData.length === 0) {
                console.warn('dimensionFilteredData is empty! Cannot apply filters.');
                return;
            }
            
            console.log(`Applying filters to ${dimensionFilteredData.length} rows`);
            
            // Apply all filter rules - all rules must pass (AND logic)
            if (filterRules.length > 0) {
                filterRules.forEach((r, idx) => {
                    console.log(`Filter rule ${idx + 1}:`, {
                        type: r.type,
                        mode: r.mode,
                        metadataField: r.metadataField,
                        values: Array.from(r.values),
                        valuesCount: r.values.size,
                        fullRule: r
                    });
                });
                
                // Log sample of first row to see what metadata looks like
                if (filteredData.length > 0) {
                }
                
                // Reset debug flags for all rules
                filterRules.forEach(rule => {
                    rule._debugLogged = false;
                });
                let firstRowLogged = false;
                
                filteredData = filteredData.filter(row => {
                    if (!row) return false;
                    
                    // Check each rule - all must pass
                    const ruleResults = filterRules.map(rule => {
                        if (rule.values.size === 0) {
                            return { rule, passed: true, reason: 'empty values', matches: true }; // Skip empty rules
                        }
                        
                        let matches = false;
                        let matchDetails = '';
                        
                        if (rule.type === 'category') {
                            // Check if row has any topics matching the category filter
                            if (row.topics && row.topics.length > 0) {
                                matches = row.topics.some(topic => 
                                    topic && topic.category && rule.values.has(topic.category)
                                );
                            }
                        } else if (rule.type === 'topic') {
                            // Check if row has any topics matching the topic filter
                            if (row.topics && row.topics.length > 0) {
                                matches = row.topics.some(topic => 
                                    topic && topic.label && rule.values.has(topic.label)
                                );
                            }
                        } else if (rule.type === 'sentiment') {
                            // Check sentiment from metadata or row-level sentiment
                            const sentiment = row.metadata?.sentiment || row.sentiment || 'neutral';
                            matches = rule.values.has(sentiment);
                        } else if (rule.type === 'location') {
                            // Location filtering is now handled via metadata field filters
                            // This is kept for backwards compatibility but should use metadata type instead
                            matches = false; // Legacy location type - use metadata filters instead
                        } else if (rule.type === 'metadata' && rule.metadataField) {
                            // Get metadata field value directly from metadata
                            const fieldValue = row.metadata?.[rule.metadataField];
                            
                            if (fieldValue !== null && fieldValue !== undefined && fieldValue !== '') {
                                // Normalize value for comparison - convert to string and trim
                                // This MUST match exactly how values are stored in extractAvailableFilterOptions
                                // (line 7621: const trimmedValue = strValue.trim(); metadataFields[key].add(trimmedValue);)
                                const normalizedValue = String(fieldValue).trim();
                                
                                // Direct Set lookup - this should work if values are stored the same way
                                matches = rule.values.has(normalizedValue);
                                
                                // If direct lookup fails, try case-insensitive and other variations
                                if (!matches) {
                                    const filterValuesArray = Array.from(rule.values);
                                    matches = filterValuesArray.some(fv => {
                                        const fvStr = String(fv).trim();
                                        // Exact match
                                        if (fvStr === normalizedValue) return true;
                                        // Case-insensitive match
                                        if (fvStr.toLowerCase() === normalizedValue.toLowerCase()) return true;
                                        // Match with original value (handles number-to-string conversion)
                                        if (String(fieldValue).trim() === fvStr) return true;
                                        return false;
                                    });
                                }
                            } else {
                                // If field is null/undefined/empty, it doesn't match any non-empty filter values
                                // Only match if empty string is explicitly in the filter values
                                matches = rule.values.has('');
                            }
                        }
                        
                        // Apply include/exclude logic
                        const passed = rule.mode === 'include' ? matches : !matches;
                        
                        
                        return { rule, passed, matches, matchDetails };
                    });
                    
                    // Check if all rules passed
                    const allPassed = ruleResults.every(r => r.passed);
                    return allPassed;
                }).map(row => {
                    // Ensure we preserve all row properties including text
                    if (!row) return null;
                    
                    // Filter topics within rows based on category and topic rules
                    if (row.topics && row.topics.length > 0) {
                        const filteredTopics = row.topics.filter(topic => {
                            // Check if this topic passes all category and topic filters
                            return filterRules.every(rule => {
                                if (rule.values.size === 0) return true;
                                
                                if (rule.type === 'category') {
                                    const matches = topic && topic.category && rule.values.has(topic.category);
                                    return rule.mode === 'include' ? matches : !matches;
                                } else if (rule.type === 'topic') {
                                    const matches = topic && topic.label && rule.values.has(topic.label);
                                    return rule.mode === 'include' ? matches : !matches;
                                }
                                return true; // Location filters don't affect individual topics
                            });
                        });
                        
                        if (filteredTopics.length === 0) return null;
                        
                        // Preserve all original row properties
                        return {
                            ...row,
                            text: row.text || '', // Explicitly preserve text
                            topics: filteredTopics
                        };
                    }
                    // If row has no topics, preserve it as-is (for location-only filters)
                    return {
                        ...row,
                        text: row.text || '' // Explicitly preserve text
                    };
                }).filter(row => row !== null);
            }
            
            console.log(`After filtering: ${filteredData.length} rows`);
            
            if (filteredData.length === 0) {
                console.warn('No data remaining after applying filters!');
                // Still try to render to show empty state
            }
            
            rawData = filteredData;
            console.log(` Updated rawData to filtered data: ${rawData.length} rows`);
            
            // Get current question type and render accordingly
            const questionType = getCurrentQuestionType();
            
            if (questionType === 'multi_choice' || questionType === 'numeric') {
                // Update chart title with question text if available
                const chartTitleEl = document.querySelector('.chart[aria-label="Topics by Category"] .chart__title');
                if (chartTitleEl) {
                    let questionText = null;
                    if (currentQuestionRefKey && fullRawData && fullRawData.length > 0) {
                        const dimensionRow = fullRawData.find(row => 
                            row.dimension_ref === currentQuestionRefKey && 
                            row.question_text && 
                            row.question_text.trim() !== ''
                        );
                        if (dimensionRow) {
                            questionText = dimensionRow.question_text;
                        }
                    }
                    chartTitleEl.textContent = questionText || 'Topics by Category';
                }
                
                // Render horizontal bar chart for multi_choice and numeric
                const data = questionType === 'multi_choice' 
                    ? processMultiChoiceData() 
                    : processNumericData();
                renderHorizontalBarChart(data.values, 'barChart', data.totalCount, questionType === 'multi_choice');
                // Update footer count
                const totalCountEl = document.getElementById('totalCount');
                if (totalCountEl) totalCountEl.textContent = data.totalCount;
                // Hide other visualizations
                const topicsChartLabels = document.getElementById('topicsChartLabels');
                const topicsChartBars = document.getElementById('topicsChartBars');
                if (topicsChartLabels) topicsChartLabels.innerHTML = '';
                if (topicsChartBars) topicsChartBars.innerHTML = '';
                const treemap = document.getElementById('treemap');
                if (treemap) treemap.innerHTML = '';
                // Hide treemap section
                const treemapSection = document.querySelector('.treemap-section');
                if (treemapSection) treemapSection.style.display = 'none';
                // Show visualizations grid with full width layout
                const visualizationsGrid = document.querySelector('.visualizations-grid');
                if (visualizationsGrid) {
                    visualizationsGrid.style.display = 'grid';
                    visualizationsGrid.classList.add('chart-fullwidth');
                }
                // Hide the second chart column (All Topics chart)
                const topicsChart = document.querySelector('.chart[aria-label="All Topics"]');
                if (topicsChart) topicsChart.style.display = 'none';
            } else if (questionType === 'geo') {
                // Render geo map
                const data = processGeoData();
                renderGeoMap(data);
                // Hide other visualizations
                const barChartLabels = document.getElementById('barChartLabels');
                const barChartBars = document.getElementById('barChartBars');
                if (barChartLabels) barChartLabels.innerHTML = '';
                if (barChartBars) barChartBars.innerHTML = '';
                const topicsChartLabels = document.getElementById('topicsChartLabels');
                const topicsChartBars = document.getElementById('topicsChartBars');
                if (topicsChartLabels) topicsChartLabels.innerHTML = '';
                if (topicsChartBars) topicsChartBars.innerHTML = '';
                // Show treemap section (which contains the map)
                const treemapSection = document.querySelector('.treemap-section');
                if (treemapSection) treemapSection.style.display = 'block';
                // Hide visualizations grid
                const visualizationsGrid = document.querySelector('.visualizations-grid');
                if (visualizationsGrid) visualizationsGrid.style.display = 'none';
            } else {
                // Default: open_text or unknown - use existing visualizations
                // Reset chart title to default
                const chartTitleEl = document.querySelector('.chart[aria-label="Topics by Category"] .chart__title');
                if (chartTitleEl) {
                    chartTitleEl.textContent = 'Topics by Category';
                }
                
                // Show all visualization sections for open_text first
                const treemapSection = document.querySelector('.treemap-section');
                if (treemapSection) treemapSection.style.display = 'block';
                const visualizationsGrid = document.querySelector('.visualizations-grid');
                if (visualizationsGrid) {
                    visualizationsGrid.style.display = 'grid';
                    visualizationsGrid.classList.remove('chart-fullwidth'); // Remove full width class
                }
                // Show the second chart column (All Topics chart)
                const topicsChart = document.querySelector('.chart[aria-label="All Topics"]');
                if (topicsChart) topicsChart.style.display = '';
                
                // Process data
                processData();
                
                // Wait for layout to recalculate before rendering treemap
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // Double RAF ensures layout has completed after display change
                        renderTreemap(hierarchyData);
                        renderBarChart();
                        renderTopicsChart();
                    });
                });
                
                // Update available options from unfiltered data so excluded items remain visible
                // Use dimensionFilteredData (unfiltered by category/topic/metadata) instead of rawData (filtered)
                extractAvailableFilterOptions(dimensionFilteredData);
                updateFilterUI();
            }
        }
        
        let currentFilterType = null;
        let currentFilterSelections = new Set();
        let currentFilterSearchTerm = '';
        
        // Set up Add button handler (extracted to function so it can be called independently)
        function setupAddButton() {
            const addDataBtn = document.getElementById('addDataBtn');
            if (addDataBtn) {
                // Remove existing listeners to avoid duplicates
                const newBtn = addDataBtn.cloneNode(true);
                addDataBtn.parentNode.replaceChild(newBtn, addDataBtn);
                
                newBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (currentClientId) {
                        // Save full visualization state before navigating
                        saveState();
                        // Also save to a separate key for navigation return
                        try {
                            const navState = {
                                client_uuid: currentClientId,
                                clientId: currentClientId,
                                projectName: currentProjectName,
                                dataSourceId: currentDataSourceId,
                                questionRefKey: currentQuestionRefKey,
                                returnUrl: '/choose-data-source.html',
                                timestamp: Date.now()
                            };
                            localStorage.setItem('vizualizd_nav_state', JSON.stringify(navState));
                        } catch (error) {
                            console.error('Error saving navigation state:', error);
                        }
                        window.location.href = `/choose-data-source.html?client_uuid=${currentClientId}`;
                    } else {
                        alert('Please select a client first');
                    }
                });
                
                // Update button visibility
                updateAddDataButton();
            }
        }
        
        // Update Add button visibility and href
        function updateAddDataButton() {
            const addDataBtn = document.getElementById('addDataBtn');
            if (addDataBtn) {
                if (currentClientId) {
                    addDataBtn.href = `/choose-data-source.html?client_uuid=${currentClientId}`;
                    // addDataBtn.style.display = 'inline-block'; // Hidden for now
                }
                // Always hide the button for now
                addDataBtn.style.display = 'none';
            }
        }
        
        // Flag to track if filter UI is already set up
        let filterUISetup = false;
        
        function setupFilterUI() {
            // Prevent duplicate setup
            if (filterUISetup) {
                return;
            }
            filterUISetup = true;
            
            const filterBtn = document.getElementById('filterBtn');
            const filterDropdown = document.getElementById('filterDropdown');
            const filterTypeView = document.getElementById('filterTypeView');
            const filterSelectionView = document.getElementById('filterSelectionView');
            const backToFilterType = document.getElementById('backToFilterType');
            const clearAllFilters = document.getElementById('clearAllFilters');
            const applyFilter = document.getElementById('applyFilter');
            const selectAllItems = document.getElementById('selectAllItems');
            const clearAllItems = document.getElementById('clearAllItems');
            const filterSelectionSearch = document.getElementById('filterSelectionSearch');
            
            if (!filterBtn || !filterDropdown) {
                console.warn('Filter UI elements not found');
                filterUISetup = false; // Reset flag if elements not found
                return;
            }
            
            if (filterSelectionSearch) {
                filterSelectionSearch.addEventListener('input', (event) => {
                    currentFilterSearchTerm = event.target.value || '';
                    populateFilterSelectionList();
                    updateFilterSelectionSearchClearButton();
                });
            }
            
            // Toggle dropdown
            filterBtn.onclick = (e) => {
                e.stopPropagation();
                const isVisible = filterDropdown.style.display !== 'none';
                filterDropdown.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    updateFilterUI();
                }
            };
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!filterBtn.contains(e.target) && !filterDropdown.contains(e.target)) {
                    filterDropdown.style.display = 'none';
                }
            });
            
            // Filter type selection is now handled dynamically in populateFilterTypeList()
            // This code is kept for backwards compatibility but will be overridden by dynamic handlers
            
            // Back from metadata field view
            const backFromMetadataField = document.getElementById('backFromMetadataField');
            backFromMetadataField.onclick = () => {
                showFilterTypeView();
            };
            
            // Back button (handles both metadata field view and filter type view)
            backToFilterType.onclick = () => {
                if (currentFilterType === 'metadata' && currentMetadataField) {
                    // If we're in metadata value selection, go back to field selection
                    showMetadataFieldView();
                } else {
                    // Otherwise go back to filter type selection
                    showFilterTypeView();
                }
            };
            
            // Clear all filters
            clearAllFilters.onclick = () => {
                filterRules = [];
                // Save cleared filters for current dimension
                saveFiltersForDimension(currentQuestionRefKey);
                applyFiltersAndRender();
                updateFilterUI();
            };
            
            // Apply filter button
            applyFilter.onclick = () => {
                const mode = document.querySelector('input[name="filterMode"]:checked').value;
                
                // For include mode, require at least one selection
                // For exclude mode, 0 selections means "exclude nothing" (remove exclusion filter)
                if (mode === 'include' && currentFilterSelections.size === 0) {
                    alert('Please select at least one item to filter by.');
                    return;
                }
                
                // Validate metadata field is set for metadata filters
                if (currentFilterType === 'metadata' && !currentMetadataField) {
                    alert('Please select a metadata field first.');
                    return;
                }
                
                // If in exclude mode with 0 selections, remove the filter rule entirely
                if (mode === 'exclude' && currentFilterSelections.size === 0) {
                    if (currentFilterType === 'metadata' && currentMetadataField) {
                        // Remove metadata filter rule
                        const existingRuleIndex = filterRules.findIndex(r => 
                            r.type === 'metadata' && r.metadataField === currentMetadataField
                        );
                        if (existingRuleIndex >= 0) {
                            filterRules.splice(existingRuleIndex, 1);
                        }
                    } else {
                        // Remove filter rule for this type
                        const existingRuleIndex = filterRules.findIndex(r => r.type === currentFilterType);
                        if (existingRuleIndex >= 0) {
                            filterRules.splice(existingRuleIndex, 1);
                        }
                    }
                } else {
                    // Add or update filter rule for this type
                    if (currentFilterType === 'metadata' && currentMetadataField) {
                        // For metadata filters, check by metadataField
                        const existingRuleIndex = filterRules.findIndex(r => 
                            r.type === 'metadata' && r.metadataField === currentMetadataField
                        );
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            filterRules[existingRuleIndex].mode = mode;
                            filterRules[existingRuleIndex].values = new Set(currentFilterSelections);
                        } else {
                            // Add new rule
                            filterRules.push({
                                type: 'metadata',
                                mode: mode,
                                values: new Set(currentFilterSelections),
                                metadataField: currentMetadataField
                            });
                        }
                    } else {
                        // For other filter types (category, topic, sentiment)
                        const existingRuleIndex = filterRules.findIndex(r => r.type === currentFilterType);
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            filterRules[existingRuleIndex].mode = mode;
                            filterRules[existingRuleIndex].values = new Set(currentFilterSelections);
                        } else {
                            // Add new rule
                            filterRules.push({
                                type: currentFilterType,
                                mode: mode,
                                values: new Set(currentFilterSelections)
                            });
                        }
                    }
                }
                
                // Save filters for current dimension after applying
                saveFiltersForDimension(currentQuestionRefKey);
                
                // Stay in the filter selection view instead of going back to top level
                // Refresh the view to show updated selections
                showFilterSelectionView();
                applyFiltersAndRender();
            };
            
            // Select all items
            selectAllItems.onclick = () => {
                const items = getVisibleFilterItems();
                if (items.length === 0) return;
                items.forEach(item => currentFilterSelections.add(item));
                populateFilterSelectionList();
            };
            
            // Clear all items
            clearAllItems.onclick = () => {
                currentFilterSelections.clear();
                populateFilterSelectionList();
            };
        }
        
        function showFilterTypeView() {
            document.getElementById('filterTypeView').style.display = 'block';
            document.getElementById('filterSelectionView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'none';
            currentFilterType = null;
            currentFilterSelections.clear();
            currentMetadataField = null;
            resetFilterSelectionSearch();
            updateFilterUI(); // Refresh the active filters list
        }
        
        function showMetadataFieldView() {
            document.getElementById('filterTypeView').style.display = 'none';
            document.getElementById('filterSelectionView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'block';
            resetFilterSelectionSearch();
            currentFilterSelections.clear();
            populateMetadataFieldList();
        }
        
        function showFilterSelectionView() {
            console.log('=== showFilterSelectionView() called ===');
            console.log('currentFilterType:', currentFilterType);
            console.log('currentMetadataField:', currentMetadataField);
            
            document.getElementById('filterTypeView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'none';
            document.getElementById('filterSelectionView').style.display = 'block';
            
            const title = document.getElementById('filterSelectionTitle');
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput && searchInput.value !== currentFilterSearchTerm) {
                searchInput.value = currentFilterSearchTerm;
            }

            if (currentFilterType === 'metadata' && currentMetadataField) {
                // Format field name nicely (e.g., "user_type" -> "User Type")
                const fieldLabel = currentMetadataField
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                title.textContent = `Select ${fieldLabel} Values`;
            } else {
                const typeLabels = {
                    'category': 'Categories',
                    'topic': 'Topics',
                    'sentiment': 'Sentiment',
                    'location': 'Locations' // Kept for backwards compatibility
                };
                title.textContent = `Select ${typeLabels[currentFilterType] || 'Items'}`;
            }
            
            // Validate that metadataField is set for metadata filters
            if (currentFilterType === 'metadata' && !currentMetadataField) {
                console.error('currentMetadataField is not set for metadata filter!');
                // Try to recover by going back to field selection
                showMetadataFieldView();
                return;
            }
            
            // Load existing selections if there's a rule for this type/field
            let existingRule;
            if (currentFilterType === 'metadata' && currentMetadataField) {
                existingRule = filterRules.find(r => 
                    r.type === 'metadata' && r.metadataField === currentMetadataField
                );
            } else {
                existingRule = filterRules.find(r => r.type === currentFilterType);
            }
            
            if (existingRule) {
                console.log('Found existing rule:', {
                    type: existingRule.type,
                    mode: existingRule.mode,
                    values: Array.from(existingRule.values)
                });
                currentFilterSelections = new Set(existingRule.values);
                console.log('Set currentFilterSelections to:', Array.from(currentFilterSelections));
                // Set the mode radio button
                const modeInput = document.querySelector(`input[name="filterMode"][value="${existingRule.mode}"]`);
                if (modeInput) {
                    modeInput.checked = true;
                    console.log('Set mode radio to:', existingRule.mode);
                } else {
                    console.warn('Mode radio input not found for value:', existingRule.mode);
                }
            } else {
                console.log('No existing rule found for type:', currentFilterType);
                currentFilterSelections.clear();
                document.querySelector('input[name="filterMode"][value="include"]').checked = true;
                // When mode is "include" and no existing rule, select all items by default
                const mode = document.querySelector('input[name="filterMode"]:checked')?.value || 'include';
                if (mode === 'include') {
                    const items = getAvailableItemsForType(currentFilterType);
                    currentFilterSelections = new Set(items);
                    console.log('Set currentFilterSelections to all items:', Array.from(currentFilterSelections));
                }
            }
            
            // Add event listeners for mode changes
            const modeInputs = document.querySelectorAll('input[name="filterMode"]');
            modeInputs.forEach(input => {
                // Remove existing listeners to avoid duplicates
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
                
                newInput.addEventListener('change', () => {
                    if (newInput.value === 'include') {
                        // When switching to include mode, select all items by default
                        const items = getAvailableItemsForType(currentFilterType);
                        currentFilterSelections = new Set(items);
                        populateFilterSelectionList();
                    } else {
                        // When switching to exclude mode, clear selections
                        currentFilterSelections.clear();
                        populateFilterSelectionList();
                    }
                });
            });
            
            populateFilterSelectionList();
            updateFilterSelectionSearchClearButton();
            console.log('=== showFilterSelectionView() completed ===');
        }
        
        function getAvailableItemsForType(type) {
            console.log('getAvailableItemsForType called with type:', type);
            let items;
            if (type === 'category') {
                items = availableCategories;
                console.log('availableCategories:', items);
            } else if (type === 'topic') {
                items = availableTopics;
                console.log('availableTopics:', items);
            } else if (type === 'sentiment') {
                items = availableMetadataFields['sentiment'] || [];
                console.log('availableSentiment:', items);
            } else if (type === 'location') {
                items = availableLocations; // Kept for backwards compatibility
                console.log('availableLocations:', items);
            } else if (type === 'metadata' && currentMetadataField) {
                items = availableMetadataFields[currentMetadataField] || [];
                console.log('availableMetadata for', currentMetadataField, ':', items);
            } else {
                items = [];
                console.log('No items found for type:', type);
            }
            console.log('Returning items:', items);
            return items;
        }
        
        function populateMetadataFieldList() {
            const fieldList = document.getElementById('metadataFieldList');
            fieldList.innerHTML = '';
            
            // Get all metadata fields, excluding sentiment (top-level) and dimension_name (removed)
            const fields = Object.keys(availableMetadataFields)
                .filter(key => key !== 'sentiment' && key !== 'dimension_name')
                .sort();
            
            if (fields.length === 0) {
                fieldList.innerHTML = '<div style="padding: 12px; color: #999; text-align: center;">No metadata fields found</div>';
                return;
            }
            
            fields.forEach(fieldName => {
                const values = availableMetadataFields[fieldName];
                const valueCount = values.length;
                
                // Format field name nicely (e.g., "user_type" -> "User Type")
                const fieldLabel = fieldName
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                
                const fieldItem = document.createElement('div');
                fieldItem.style.cssText = 'padding: 12px; margin: 4px 0; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; transition: background 0.2s;';
                fieldItem.onmouseover = () => fieldItem.style.background = '#f5f5f5';
                fieldItem.onmouseout = () => fieldItem.style.background = 'transparent';
                fieldItem.onclick = () => {
                    currentMetadataField = fieldName;
                    resetFilterSelectionSearch();
                    showFilterSelectionView();
                };
                
                fieldItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 14px; color: #333;">${fieldLabel}</strong>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${valueCount} ${valueCount === 1 ? 'value' : 'values'} available</div>
                        </div>
                        <span style="font-size: 18px;"></span>
                    </div>
                `;
                
                fieldList.appendChild(fieldItem);
            });
        }
        
        function getVisibleFilterItems() {
            const items = getAvailableItemsForType(currentFilterType) || [];
            if (!items || items.length === 0) return [];
            
            const searchTerm = currentFilterSearchTerm ? currentFilterSearchTerm.trim().toLowerCase() : '';
            if (!searchTerm) return items;
            
            return items.filter(item => {
                if (item === null || item === undefined) return false;
                return String(item).toLowerCase().includes(searchTerm);
            });
        }
        
        function populateFilterSelectionList() {
            console.log('=== populateFilterSelectionList() called ===');
            console.log('currentFilterType:', currentFilterType);
            
            const filterList = document.getElementById('filterSelectionList');
            if (!filterList) {
                console.error('filterSelectionList element not found!');
                return;
            }
            filterList.innerHTML = '';
            
            const items = getVisibleFilterItems();
            console.log('Visible items:', items);
            console.log('Number of visible items:', items.length);
            
            if (items.length === 0) {
                const message = currentFilterSearchTerm && currentFilterSearchTerm.trim().length > 0
                    ? 'No items match your search'
                    : 'No items found';
                filterList.innerHTML = `<div style="padding: 12px; color: #999; text-align: center;">${message}</div>`;
                console.log('No items to display');
                return;
            }
            
            let checkedCount = 0;
            items.forEach(item => {
                const isChecked = currentFilterSelections.has(item);
                if (isChecked) checkedCount++;
                
                console.log(`Item: "${item}", isChecked: ${isChecked}`);
                
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; padding: 8px 12px; cursor: pointer; border-radius: 4px; transition: background 0.2s;';
                label.onmouseover = () => label.style.background = '#f5f5f5';
                label.onmouseout = () => label.style.background = 'transparent';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        currentFilterSelections.add(item);
                    } else {
                        currentFilterSelections.delete(item);
                    }
                };
                
                const text = document.createElement('span');
                text.textContent = item;
                text.style.cssText = 'font-size: 13px; flex: 1;';
                
                label.appendChild(checkbox);
                label.appendChild(text);
                filterList.appendChild(label);
            });
            console.log(`Total items: ${items.length}, Checked items: ${checkedCount}`);
            console.log('=== populateFilterSelectionList() completed ===');
        }
        
        function updateFilterUI() {
            console.log('=== updateFilterUI() called ===');
            console.log('Current filterRules:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                type: r.type,
                mode: r.mode,
                values: Array.from(r.values)
            })))));
            console.log('filterRules.length:', filterRules.length);
            
            // Update active filters list
            const activeFiltersList = document.getElementById('activeFiltersList');
            activeFiltersList.innerHTML = '';
            
            if (filterRules.length === 0) {
                activeFiltersList.innerHTML = '<div style="padding: 8px; color: #999; text-align: center; font-size: 12px;">No active filters</div>';
            } else {
                filterRules.forEach((rule, index) => {
                    const filterItem = document.createElement('div');
                    filterItem.style.cssText = 'padding: 8px 12px; margin: 4px 0; background: white; border: 1px solid #e0e0e0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;';
                    
                    let typeLabel;
                    if (rule.type === 'metadata' && rule.metadataField) {
                        // Format metadata field name nicely
                        const fieldLabel = rule.metadataField
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        typeLabel = `Metadata: ${fieldLabel}`;
                    } else {
                        const typeLabels = {
                            'category': 'Category',
                            'topic': 'Topic',
                            'sentiment': 'Sentiment',
                            'location': 'Location' // Kept for backwards compatibility
                        };
                        typeLabel = typeLabels[rule.type] || rule.type;
                    }
                    
                    const modeLabel = rule.mode === 'include' ? 'Include' : 'Exclude';
                    const count = rule.values.size;
                    const itemsPreview = Array.from(rule.values).slice(0, 2).join(', ');
                    const moreText = count > 2 ? ` +${count - 2} more` : '';
                    
                    filterItem.innerHTML = `
                        <div style="flex: 1;">
                            <div style="font-size: 12px; font-weight: 600; color: #333;">${typeLabel} (${modeLabel})</div>
                            <div style="font-size: 11px; color: #666; margin-top: 2px;">${itemsPreview}${moreText}</div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button class="edit-filter-btn" data-index="${index}" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Edit</button>
                            <button class="remove-filter-btn" data-index="${index}" style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                        </div>
                    `;
                    
                    const editBtn = filterItem.querySelector('.edit-filter-btn');
                    editBtn.onclick = () => {
                        currentFilterType = rule.type;
                        resetFilterSelectionSearch();
                        if (rule.type === 'metadata' && rule.metadataField) {
                            currentMetadataField = rule.metadataField;
                            showFilterSelectionView();
                        } else if (rule.type === 'sentiment' || rule.type === 'category' || rule.type === 'topic') {
                            // Top-level filters (sentiment, category, topic) - go directly to value selection
                            currentMetadataField = null;
                            showFilterSelectionView();
                        } else {
                            showFilterSelectionView();
                        }
                    };
                    
                    const removeBtn = filterItem.querySelector('.remove-filter-btn');
                    removeBtn.onclick = () => {
                        filterRules.splice(index, 1);
                        // Save updated filters for current dimension
                        saveFiltersForDimension(currentQuestionRefKey);
                        applyFiltersAndRender();
                    };
                    
                    activeFiltersList.appendChild(filterItem);
                });
            }
            
            // Update badge - show total count of items across all filter rules
            const badge = document.getElementById('filterBadge');
            console.log('Badge element:', badge);
            if (filterRules.length === 0) {
                if (badge) {
                    badge.style.display = 'none';
                    console.log('Badge hidden (no filters)');
                }
            } else {
                if (badge) {
                    // Calculate total number of items across all filter rules
                    const totalItems = filterRules.reduce((sum, rule) => sum + rule.values.size, 0);
                    badge.style.display = 'flex';
                    badge.textContent = totalItems;
                    console.log('Badge updated to:', totalItems, 'Badge textContent:', badge.textContent, 'filterRules.length:', filterRules.length);
                    // Force a reflow to ensure the DOM updates
                    void badge.offsetWidth;
                } else {
                    console.error('Badge element not found!');
                }
            }
            console.log('=== updateFilterUI() completed ===');
        }

        // Process raw data into hierarchy
        // Now works with normalized data format
        function processData() {
            const categoryMap = new Map();
            
            console.log(`Processing ${rawData.length} rows for visualization...`);
            console.log(`First row sample:`, rawData.length > 0 ? {
                row_id: rawData[0].row_id,
                hasTopics: !!rawData[0].topics,
                topicsCount: rawData[0].topics?.length || 0,
                metadataKeys: Object.keys(rawData[0].metadata || {})
            } : 'No data');
            let rowsWithTopics = 0;
            let topicsFound = 0;

            rawData.forEach(row => {
                // Skip null/undefined rows or rows with no topics
                if (!row || !row.topics || row.topics.length === 0) {
                    if (rawData.length > 0 && rawData.length <= 10) {
                        // Log for small datasets to help debug
                        console.log(`Skipping row ${row?.row_id || 'unknown'}: hasTopics=${!!row?.topics}, topicsLength=${row?.topics?.length || 0}`);
                    }
                    return;
                }
                
                // Normalized format: {row_id, text, topics[], sentiment, metadata{}}
                const topics = row.topics;
                const rowDimensionRef = row.dimension_ref || row.metadata?.ref_key;
                
                rowsWithTopics++;
                
                topics.forEach(topic => {
                    if (!topic || !topic.category) return;
                    topicsFound++;

                    // When "All Dimensions" is selected, only add verbatim to topic if dimensions match
                    // This prevents verbatims from one dimension being added to topics from another dimension
                    if (rowDimensionRef && topic._dimension_ref && topic._dimension_ref !== rowDimensionRef) {
                        return; // Skip this topic - it's from a different dimension
                    }

                    // Get or create category
                    if (!categoryMap.has(topic.category)) {
                        categoryMap.set(topic.category, {
                            name: topic.category,
                            children: new Map()
                        });
                    }

                    const category = categoryMap.get(topic.category);

                    // Get or create topic
                    if (!category.children.has(topic.label)) {
                        category.children.set(topic.label, {
                            name: topic.label,
                            code: topic.code,
                            verbatims: []
                        });
                    }

                    // Add verbatim - include all metadata fields dynamically
                    const topicData = category.children.get(topic.label);
                    topicData.verbatims.push({
                        text: row.text || '',
                        sentiment: row.sentiment || 'neutral',
                        index: row.row_id,
                        // Preserve commonly used fields for backward compatibility
                        country: row.metadata?.country || '',
                        city: row.metadata?.city || '',
                        date: row.metadata?.created_at || '',
                        source_type: row.metadata?.source_type || 'unknown',
                        // Include all other metadata fields
                        ...(row.metadata || {})
                    });
                });
            });

            // Convert to D3 hierarchy format
            hierarchyData = {
                name: 'Root',
                children: Array.from(categoryMap.values()).map(cat => ({
                    name: cat.name,
                    children: Array.from(cat.children.values()).map(topic => ({
                        name: topic.name,
                        code: topic.code,
                        value: topic.verbatims.length,
                        verbatims: topic.verbatims
                    }))
                }))
            };
            
            console.log(`Found ${rowsWithTopics} rows with topics, ${topicsFound} total topics`);
            console.log(`Categories: ${categoryMap.size}, Hierarchy children: ${hierarchyData.children.length}`);
            
            // Log a sample row for debugging
            if (rawData.length > 0) {
            }
        }

        // Helper function to collect all verbatims from all topics in a category
        function collectCategoryVerbatims(categoryData) {
            if (!categoryData) return [];
            const allVerbatims = [];
            if (categoryData.children && Array.isArray(categoryData.children)) {
                categoryData.children.forEach(topic => {
                    if (topic && topic.verbatims && Array.isArray(topic.verbatims)) {
                        allVerbatims.push(...topic.verbatims);
                    }
                });
            }
            return allVerbatims;
        }

        // Helper function to collect all verbatims from the entire dimension
        function collectAllDimensionVerbatims() {
            if (!hierarchyData || !hierarchyData.children) return [];
            const allVerbatims = [];
            hierarchyData.children.forEach(category => {
                if (category && category.children && Array.isArray(category.children)) {
                    category.children.forEach(topic => {
                        if (topic && topic.verbatims && Array.isArray(topic.verbatims)) {
                            allVerbatims.push(...topic.verbatims);
                        }
                    });
                }
            });
            return allVerbatims;
        }

        // Helper function to find a category in hierarchyData by name
        function findCategoryInHierarchy(categoryName) {
            if (!hierarchyData || !hierarchyData.children) return null;
            return hierarchyData.children.find(cat => cat.name === categoryName) || null;
        }

        // Helper function to find a topic in a category by name
        function findTopicInCategory(categoryData, topicName) {
            if (!categoryData || !categoryData.children) return null;
            return categoryData.children.find(topic => topic.name === topicName) || null;
        }

        // Helper function to extract all verbatims from a data structure and return clean array with only text and id
        function extractCleanVerbatims(data) {
            if (!data) return [];
            
            // Helper function to extract all verbatims from the data structure
            function extractAllVerbatims(obj) {
                const verbatims = [];
                
                if (Array.isArray(obj)) {
                    obj.forEach(item => {
                        verbatims.push(...extractAllVerbatims(item));
                    });
                } else if (obj && typeof obj === 'object') {
                    // If this object has verbatims directly
                    if (obj.verbatims && Array.isArray(obj.verbatims)) {
                        verbatims.push(...obj.verbatims);
                    }
                    // If this object has children (like a category with topics)
                    if (obj.children && Array.isArray(obj.children)) {
                        obj.children.forEach(child => {
                            verbatims.push(...extractAllVerbatims(child));
                        });
                    }
                }
                
                return verbatims;
            }
            
            // Extract all verbatims
            const allVerbatims = extractAllVerbatims(data);
            
            // Create clean array with only text and id
            const cleanVerbatims = allVerbatims.map(v => {
                // Use row_id if available, otherwise use index, otherwise null
                const uniqueId = v.row_id !== undefined ? v.row_id : (v.index !== undefined ? v.index : null);
                
                return {
                    text: v.text || '',
                    id: uniqueId
                };
            }).filter(v => v.text); // Remove any verbatims without text
            
            return cleanVerbatims;
        }

        // Helper function to extract all verbatims from aggregated summary (hierarchyData)
        function extractVerbatimsFromAggregatedSummary() {
            if (!hierarchyData || !hierarchyData.children) {
                return [];
            }
            
            const allVerbatims = [];
            
            // Iterate through all categories and topics to collect all verbatims
            hierarchyData.children.forEach(category => {
                if (category && category.children && Array.isArray(category.children)) {
                    category.children.forEach(topic => {
                        if (topic && topic.verbatims && Array.isArray(topic.verbatims)) {
                            topic.verbatims.forEach(verbatim => {
                                // Extract clean verbatim with text and id
                                const uniqueId = verbatim.row_id !== undefined ? verbatim.row_id : (verbatim.index !== undefined ? verbatim.index : null);
                                if (verbatim.text) {
                                    allVerbatims.push({
                                        text: verbatim.text,
                                        id: uniqueId
                                    });
                                }
                            });
                        }
                    });
                }
            });
            
            return allVerbatims;
        }

        function getCurrentQuestionTextForOverview() {
            let questionText = null;
            if (currentQuestionRefKey) {
                const dimensionRow = fullRawData.find(row =>
                    row.dimension_ref === currentQuestionRefKey &&
                    row.question_text &&
                    row.question_text.trim() !== ''
                );
                if (dimensionRow) {
                    questionText = dimensionRow.question_text;
                }
            }
            if (questionText) return questionText;
            if (currentQuestionRefKey) {
                return getDimensionDisplayName(currentQuestionRefKey);
            }
            return 'All Dimensions';
        }

        function buildOverviewSummaryFromHierarchy() {
            if (!hierarchyData || !hierarchyData.children) {
                throw new Error('Hierarchy data is not available');
            }

            const categoryTotals = new Map();
            let totalTopicCount = 0;

            hierarchyData.children.forEach(category => {
                let categoryCount = 0;
                (category.children || []).forEach(topic => {
                    const topicCount = Number(topic.value ?? topic.verbatims?.length ?? 0);
                    categoryCount += topicCount;
                    totalTopicCount += topicCount;
                });
                categoryTotals.set(category.name, categoryCount);
            });

            const toPercent = (count, total) => {
                if (!total) return 0;
                return Math.round((count / total) * 1000) / 10;
            };

            const categories = hierarchyData.children.map(category => {
                const categoryCount = categoryTotals.get(category.name) || 0;
                const topics = (category.children || []).map(topic => {
                    const topicCount = Number(topic.value ?? topic.verbatims?.length ?? 0);
                    const verbatims = (topic.verbatims || [])
                        .map(verbatim => ({
                            id: verbatim.row_id ?? verbatim.index ?? null,
                            text: verbatim.text || ''
                        }))
                        .filter(verbatim => verbatim.text);

                    const topVerbatims = verbatims
                        .sort((a, b) => (b.text.length || 0) - (a.text.length || 0))
                        .slice(0, 5);

                    return {
                        name: topic.name,
                        count: topicCount,
                        percentage: toPercent(topicCount, totalTopicCount),
                        top_verbatims: topVerbatims
                    };
                });

                return {
                    name: category.name,
                    count: categoryCount,
                    percentage: toPercent(categoryCount, totalTopicCount),
                    topics
                };
            });

            return {
                question: getCurrentQuestionTextForOverview(),
                total_topic_count: totalTopicCount,
                categories
            };
        }

        // Helper function to get full data structure for context (category or topic with verbatims)
        function getFullDataForContext(contextData) {
            if (!contextData) return null;
            
            const categoryName = contextData.category;
            const topicName = contextData.topic_label;
            const type = contextData.type;
            
            if (!categoryName) return null;
            
            // Try treemap data first (hierarchyData)
            if (hierarchyData && hierarchyData.children) {
                const categoryData = findCategoryInHierarchy(categoryName);
                if (categoryData) {
                    if (type === 'topic' && topicName) {
                        // Get specific topic
                        const topicData = findTopicInCategory(categoryData, topicName);
                        if (topicData) {
                            // Return a clean copy of the topic data
                            return {
                                name: topicData.name,
                                code: topicData.code || null,
                                value: topicData.value || null,
                                verbatims: topicData.verbatims || []
                            };
                        }
                    } else if (type === 'category') {
                        // Return full category with all topics
                        return {
                            name: categoryData.name,
                            children: (categoryData.children || []).map(topic => ({
                                name: topic.name,
                                code: topic.code || null,
                                value: topic.value || null,
                                verbatims: topic.verbatims || []
                            }))
                        };
                    }
                }
            }
            
            // Try bar chart data as fallback
            try {
                const { categories } = processBarChartData();
                const categoryData = categories.find(cat => cat.name === categoryName);
                if (categoryData) {
                    if (type === 'topic' && topicName) {
                        // Get specific topic
                        const topicData = categoryData.topics.find(topic => topic.name === topicName);
                        if (topicData) {
                            return {
                                name: topicData.name,
                                count: topicData.count,
                                percent: topicData.percent,
                                verbatims: topicData.verbatims || []
                            };
                        }
                    } else if (type === 'category') {
                        // Return full category with all topics
                        return {
                            name: categoryData.name,
                            count: categoryData.count,
                            percent: categoryData.percent,
                            topics: (categoryData.topics || []).map(topic => ({
                                name: topic.name,
                                count: topic.count,
                                percent: topic.percent,
                                verbatims: topic.verbatims || []
                            }))
                        };
                    }
                }
            } catch (error) {
                console.error('Error accessing bar chart data:', error);
            }
            
            return null;
        }

        // Render treemap - uses treemap renderer module
        function renderTreemap(data) {
            window.treemapRendererRenderTreemap(data, {
                colorSchemes,
                currentProjectName,
                currentDataSourceId,
                currentQuestionRefKey,
                getDimensionDisplayName,
                showVerbatims,
                showContextMenu,
                handleNodeClick,
                hierarchyData
            });
        }

        // Handle node click for drill-down
        function handleNodeClick(node) {
            // Check if this is a topic with verbatims (leaf node)
            if (node.data.verbatims && node.data.verbatims.length > 0) {
                // Show verbatims for this topic
                const categoryName = node.parent ? node.parent.data.name : 'Unknown Category';
                viewStack.push({ type: 'topic', data: node.data, parent: categoryName });
                showVerbatims(node.data.verbatims, node.data.name, categoryName);
            } else if (node.children || (node.data.children && node.data.children.length > 0)) {
                // This is a category - collect all verbatims from all topics
                const allVerbatims = collectCategoryVerbatims(node.data);
                if (allVerbatims.length > 0) {
                    // Show all verbatims for this category
                    viewStack.push({ type: 'category', data: node.data });
                    showVerbatims(allVerbatims, node.data.name, node.data.name);
                } else {
                    // No verbatims, drill down (fallback behavior)
                    viewStack.push({ type: 'category', data: node.data });
                    renderTreemap(node.data);
                }
            }
        }

        // escapeHtml function - now imported from js/utils/dom.js module
        // Available globally via window.escapeHtml

        // Highlight search terms in text - uses format module
        function highlightSearchTerms(text, searchTerm) {
            return window.formatHighlightSearchTerms(text, searchTerm, window.escapeHtml);
        }

        // Render verbatims cards - uses verbatims renderer module
        function renderVerbatims(verbatims, topicName, categoryName) {
            window.verbatimsRendererRenderVerbatims(verbatims, topicName, categoryName, verbatimSearchTerm, currentCategoryName);
        }

        // Show verbatims in slideout panel
        function showVerbatims(verbatims, topicName, categoryName) {
            // Use the slideout panel instead of the overlay
            if (window.SlideoutPanel) {
                window.SlideoutPanel.openVerbatims(verbatims, topicName, categoryName);
            }
        }
        
        // Helper functions for slideout settings
        
        function toggleSlideoutSettings() {
            const panel = document.getElementById('slideoutSettingsPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function updateSlideoutSettings() {
            // Re-render verbatims with new settings
            if (window.SlideoutPanel && window.SlideoutPanel.currentMode === 'verbatims') {
                window.SlideoutPanel.renderVerbatims(
                    window.SlideoutPanel.currentVerbatimsData,
                    window.SlideoutPanel.currentTopicName,
                    window.SlideoutPanel.currentCategoryName
                );
            }
        }

        // Store current verbatims data for re-rendering
        let currentVerbatimsData = null;
        let currentTopicName = null;
        let currentCategoryName = null;
        let verbatimSearchTerm = '';
        let favouritesSearchTerm = '';
        
        function clearVerbatimSearch() {
            const searchInput = document.getElementById('verbatimSearch');
            if (searchInput) {
                searchInput.value = '';
                verbatimSearchTerm = '';
                if (currentVerbatimsData) {
                    renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
                }
                updateVerbatimSearchClearButton();
            }
        }
        
        function updateVerbatimSearchClearButton() {
            const searchInput = document.getElementById('verbatimSearch');
            const clearButton = document.getElementById('verbatimSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.style.display = 'flex';
                } else {
                    clearButton.style.display = 'none';
                }
            }
        }

        function clearFavouritesSearch() {
            const searchInput = document.getElementById('favouritesSearch');
            if (searchInput) {
                searchInput.value = '';
                favouritesSearchTerm = '';
                renderFavourites();
                updateFavouritesSearchClearButton();
            }
        }

        function updateFavouritesSearchClearButton() {
            const searchInput = document.getElementById('favouritesSearch');
            const clearButton = document.getElementById('favouritesSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.classList.add('active');
                } else {
                    clearButton.classList.remove('active');
                }
            }
        }

        // Treemap search functionality
        function handleTreemapSearch() {
            const searchInput = document.getElementById('treemapSearch');
            const clearBtn = document.getElementById('treemapSearchClear');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim();
            
            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = searchTerm ? 'flex' : 'none';
            }
            
            // Update search-active class based on search term and slideout state
            if (searchContainer) {
                const slideoutOpen = document.body.classList.contains('slideout-open');
                if (searchTerm && slideoutOpen) {
                    searchContainer.classList.add('search-active');
                } else {
                    searchContainer.classList.remove('search-active');
                }
            }
            
            // If search is empty, don't do anything (user can continue viewing treemap)
            if (!searchTerm) {
                return;
            }
            
            // Collect all verbatims from the dimension
            const allVerbatims = collectAllDimensionVerbatims();
            
            if (allVerbatims.length === 0) {
                return;
            }
            
            // Filter verbatims based on search (multi-word: all words must match)
            const searchWords = searchTerm.toLowerCase().split(/\s+/).filter(word => word.length > 0);
            const filteredVerbatims = allVerbatims.filter(v => {
                const verbatimText = (v.text || '').toLowerCase();
                // Check if all search words appear in the verbatim text
                return searchWords.every(word => verbatimText.includes(word));
            });
            
            // Display filtered verbatims
            if (filteredVerbatims.length > 0) {
                showVerbatims(filteredVerbatims, `Search: "${searchTerm}"`, 'All Categories');
            } else {
                // Show empty state in verbatims panel
                showVerbatims([], `Search: "${searchTerm}"`, 'All Categories');
            }
            
            // Set the search term in the slideout panel AFTER openVerbatims completes
            // (openVerbatims clears it, so we need to set it after and re-render)
            if (window.SlideoutPanel) {
                window.SlideoutPanel.verbatimSearchTerm = searchTerm;
                // Re-render verbatims with the search term for highlighting
                if (window.SlideoutPanel.currentMode === 'verbatims' && window.SlideoutPanel.currentVerbatimsData) {
                    window.SlideoutPanel.renderVerbatims(
                        window.SlideoutPanel.currentVerbatimsData,
                        window.SlideoutPanel.currentTopicName,
                        window.SlideoutPanel.currentCategoryName
                    );
                }
            }
        }
        
        function clearTreemapSearch() {
            const searchInput = document.getElementById('treemapSearch');
            const clearBtn = document.getElementById('treemapSearchClear');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (searchInput) {
                searchInput.value = '';
                if (clearBtn) {
                    clearBtn.style.display = 'none';
                }
                // Focus the search input after clearing
                searchInput.focus();
            }
            
            // Remove search-active class
            if (searchContainer) {
                searchContainer.classList.remove('search-active');
            }
            
            // Clear the slideout search term if it was set from treemap search
            if (window.SlideoutPanel) {
                // Only clear if the slideout is showing search results
                const currentTitle = document.getElementById('slideoutTitle');
                if (currentTitle && currentTitle.textContent.includes('Search:')) {
                    window.SlideoutPanel.verbatimSearchTerm = '';
                }
            }
            
            // Close verbatims panel if it was opened by search
            if (window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                // Only close if the current view is from search
                const currentTitle = document.getElementById('slideoutTitle');
                if (currentTitle && currentTitle.textContent.includes('Search:')) {
                    window.SlideoutPanel.close();
                }
            }
        }

        // Update search bar z-index based on slideout state and search term
        function updateTreemapSearchZIndex() {
            const searchInput = document.getElementById('treemapSearch');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (!searchContainer || !searchInput) return;
            
            const searchTerm = searchInput.value.trim();
            const slideoutOpen = document.body.classList.contains('slideout-open');
            
            if (searchTerm && slideoutOpen) {
                searchContainer.classList.add('search-active');
            } else {
                searchContainer.classList.remove('search-active');
            }
        }

        // Toggle chart visibility - uses UI controller module
        function toggleChart(button) {
            return window.uiControllerToggleChart(button);
        }

        // Toggle treemap visibility - uses UI controller module
        function toggleTreemap(button) {
            return window.uiControllerToggleTreemap(button);
        }

        // Load metadata settings from localStorage
        function loadMetadataSettings() {
            const defaultSettings = {
                showSentiment: true,
                showLocation: true,
                showIndex: true
            };
            
            const saved = localStorage.getItem('verbatimMetadataSettings');
            if (saved) {
                try {
                    return { ...defaultSettings, ...JSON.parse(saved) };
                } catch (e) {
                    return defaultSettings;
                }
            }
            return defaultSettings;
        }

        // Save metadata settings to localStorage
        function saveMetadataSettings(settings) {
            localStorage.setItem('verbatimMetadataSettings', JSON.stringify(settings));
        }

        // Favorites management functions
        function getFavouriteKey(verbatim) {
            // Create a unique key based on index (row_id) and first 50 chars of text
            const textPrefix = (verbatim.text || '').substring(0, 50).replace(/\s+/g, ' ').trim();
            return `${verbatim.index || 'unknown'}_${textPrefix}`;
        }

        // Favourites storage - uses storage module
        function getFavouritesStorageKey() {
            const clientId = currentClientId || 'no-client';
            const projectName = currentProjectName || 'all-projects';
            return window.storageGetFavouritesStorageKey(clientId, projectName);
        }

        function getFavourites() {
            const clientId = currentClientId || 'no-client';
            const projectName = currentProjectName || 'all-projects';
            return window.storageGetFavourites(clientId, projectName);
        }

        function saveFavourites(favourites) {
            const clientId = currentClientId || 'no-client';
            const projectName = currentProjectName || 'all-projects';
            window.storageSaveFavourites(clientId, projectName, favourites);
        }

        function isFavourite(verbatim) {
            const favourites = getFavourites();
            const key = getFavouriteKey(verbatim);
            return favourites.some(fav => fav.key === key);
        }

        function handleFavouriteClick(button) {
            const verbatimData = button.getAttribute('data-verbatim');
            if (!verbatimData) return;
            
            try {
                // Decode base64 encoded JSON with Unicode-safe decoding
                const verbatimJson = decodeURIComponent(escape(atob(verbatimData)));
                const verbatim = JSON.parse(verbatimJson);
                toggleFavourite(verbatim);
            } catch (e) {
                console.error('Error parsing verbatim data:', e);
            }
        }

        function createInsightFromVerbatim(button) {
            const verbatimData = button.getAttribute('data-verbatim');
            if (!verbatimData) {
                console.error('No verbatim data found');
                return;
            }

            if (!currentClientId) {
                alert('No client selected');
                return;
            }

            try {
                // Decode base64 encoded JSON with Unicode-safe decoding
                const verbatimJson = decodeURIComponent(escape(atob(verbatimData)));
                const verbatim = JSON.parse(verbatimJson);

                // Extract category and topic from verbatim
                const category = verbatim.category || null;
                const topic = verbatim.topic || null;

                // Determine type: use 'topic' if both category and topic exist, 'category' if only category
                const type = (category && topic) ? 'topic' : (category ? 'category' : 'category');

                // Build context data similar to right-click context menu
                const contextData = {
                    type: type,
                    category: category,
                    topic_label: topic,
                    project_name: currentProjectName || null,
                    data_source: currentDataSourceId || null,
                    dimension_ref: currentQuestionRefKey || null,
                    dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                };

                // Store the verbatim to pre-pin in the insight creation panel
                if (window.SlideoutPanel) {
                    window.SlideoutPanel.prePinnedVerbatim = verbatim;
                    window.SlideoutPanel.openCreateInsight(contextData);
                } else {
                    console.error('SlideoutPanel not available');
                    alert('Error: Unable to open insight creation panel');
                }
            } catch (e) {
                console.error('Error parsing verbatim data:', e);
                alert('Error: Failed to create insight from verbatim');
            }
        }

        function toggleFavourite(verbatim) {
            const favourites = getFavourites();
            const key = getFavouriteKey(verbatim);
            const index = favourites.findIndex(fav => fav.key === key);
            
            if (index >= 0) {
                // Remove from favourites
                favourites.splice(index, 1);
            } else {
                // Add to favourites - include category and topic from current context
                // If verbatim already has category/topic (from favorites section), preserve them
                // Otherwise use current context
                const category = verbatim.category || currentCategoryName || null;
                const topic = verbatim.topic || currentTopicName || null;
                
                favourites.push({
                    key: key,
                    verbatim: {
                        text: verbatim.text,
                        sentiment: verbatim.sentiment,
                        index: verbatim.index,
                        country: verbatim.country,
                        city: verbatim.city,
                        date: verbatim.date,
                        source_type: verbatim.source_type,
                        category: category,
                        topic: topic
                    }
                });
            }
            
            saveFavourites(favourites);
            renderFavourites();
            
            // Re-render verbatims if they're currently displayed to update favorite buttons
            // Check both old overlay and new slideout panel
            if (currentVerbatimsData) {
                renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
            }
            
            // Also re-render slideout panel if it's showing verbatims
            if (window.SlideoutPanel && window.SlideoutPanel.currentMode === 'verbatims' && window.SlideoutPanel.currentVerbatimsData) {
                window.SlideoutPanel.renderVerbatims(
                    window.SlideoutPanel.currentVerbatimsData,
                    window.SlideoutPanel.currentTopicName,
                    window.SlideoutPanel.currentCategoryName
                );
            }
        }

        // Handle breadcrumb category click - show all verbatims from category
        function handleBreadcrumbCategoryClick(categoryName) {
            const categoryData = findCategoryInHierarchy(categoryName);
            if (categoryData) {
                const allVerbatims = collectCategoryVerbatims(categoryData);
                if (allVerbatims.length > 0) {
                    showVerbatims(allVerbatims, categoryName, categoryName);
                }
            }
        }

        // Handle breadcrumb topic click - show all verbatims from topic
        function handleBreadcrumbTopicClick(categoryName, topicName) {
            const categoryData = findCategoryInHierarchy(categoryName);
            if (categoryData) {
                const topicData = findTopicInCategory(categoryData, topicName);
                if (topicData && topicData.verbatims && topicData.verbatims.length > 0) {
                    showVerbatims(topicData.verbatims, topicName, categoryName);
                }
            }
        }

        // Render favourites section
        function renderFavourites() {
            const container = document.getElementById('favouritesContainer');
            if (!container) return;
            
            const favourites = getFavourites();
            
            // Filter favourites based on search term
            const searchTerm = favouritesSearchTerm.toLowerCase().trim();
            const filteredFavourites = searchTerm === '' 
                ? favourites 
                : favourites.filter(fav => {
                    const v = fav.verbatim;
                    const text = (v.text || '').toLowerCase();
                    const city = (v.city || '').toLowerCase();
                    const country = (v.country || '').toLowerCase();
                    const sentiment = (v.sentiment || '').toLowerCase();
                    const index = String(v.index || '').toLowerCase();
                    const category = (v.category || '').toLowerCase();
                    const topic = (v.topic || '').toLowerCase();
                    
                    return text.includes(searchTerm) || 
                           city.includes(searchTerm) || 
                           country.includes(searchTerm) || 
                           sentiment.includes(searchTerm) ||
                           index.includes(searchTerm) ||
                           category.includes(searchTerm) ||
                           topic.includes(searchTerm);
                });
            
            if (favourites.length === 0) {
                const skeletonCards = Array.from({ length: 6 }).map(() => `
                    <div class="skeleton-card">
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </div>
                `).join('');

                container.innerHTML = `
                    <div class="favourites-empty">
                        <div class="favourites-empty-grid">
                            ${skeletonCards}
                        </div>
                    </div>
                `;
                return;
            }
            
            // Show message if search returns no results
            if (filteredFavourites.length === 0 && searchTerm !== '') {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999; font-size: 14px;">No favourites match your search</div>';
                return;
            }
            
            // Render favourite verbatims
            container.innerHTML = '';
            const settings = loadMetadataSettings();
            
            filteredFavourites.forEach(fav => {
                const v = fav.verbatim;
                const card = document.createElement('div');
                card.className = 'verbatim-card';
                
                const sentimentClass = v.sentiment ? `sentiment-${v.sentiment}` : 'sentiment-neutral';
                // Highlight search terms if there's a search
                const highlightedText = searchTerm ? highlightSearchTerms(v.text || 'No text available', favouritesSearchTerm) : escapeHtml(v.text || 'No text available');
                const escapedCity = v.city ? escapeHtml(v.city) : '';
                const escapedCountry = v.country ? escapeHtml(v.country) : '';
                
                // Build breadcrumb HTML if category and topic are available
                let breadcrumbHTML = '';
                if (v.category && v.topic) {
                    const escapedCategory = escapeHtml(v.category);
                    const escapedTopic = escapeHtml(v.topic);
                    breadcrumbHTML = `
                        <div class="verbatim-breadcrumb" style="margin-top: 16px; margin-bottom: 12px; font-size: 13px; color: #666;">
                            <span class="breadcrumb-link breadcrumb-category" 
                                  style="color: #0066cc; cursor: pointer; text-decoration: underline;" 
                                  data-category="${escapedCategory}">
                                ${escapedCategory}
                            </span>
                            <span style="margin: 0 6px; color: #999;">&gt;</span>
                            <span class="breadcrumb-link breadcrumb-topic" 
                                  style="color: #0066cc; cursor: pointer; text-decoration: underline;" 
                                  data-category="${escapedCategory}"
                                  data-topic="${escapedTopic}">
                                ${escapedTopic}
                            </span>
                        </div>
                    `;
                }
                
                // Build metadata HTML based on settings
                const metaItems = [];
                
                if (settings.showSentiment) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Sentiment:</span>
                            <span class="sentiment ${sentimentClass}">${v.sentiment || 'neutral'}</span>
                        </div>
                    `);
                }
                
                if (settings.showLocation && v.country) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Location:</span>
                            <span>${escapedCity ? escapedCity + ', ' : ''}${escapedCountry}</span>
                        </div>
                    `);
                }
                
                if (settings.showIndex) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Index:</span>
                            <span>#${v.index}</span>
                        </div>
                    `);
                }
                
                const metaHTML = metaItems.length > 0 ? `
                    <div class="verbatim-meta">
                        ${metaItems.join('')}
                    </div>
                ` : '';
                
                // Use base64 encoding with Unicode-safe encoding
                const verbatimJson = JSON.stringify(v);
                const verbatimData = btoa(unescape(encodeURIComponent(verbatimJson)));
                
                card.innerHTML = `
                    <div class="verbatim-card-header">
                        <div class="verbatim-text" style="flex: 1; margin-bottom: 0; padding-right: 8px;">${highlightedText}</div>
                        <button class="create-insight-button" data-verbatim="${verbatimData}" onclick="createInsightFromVerbatim(this)" title="Create insight from this verbatim" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; color: oklch(0.556 0 0); transition: all 0.2s ease;" onmouseover="this.style.color='#B9F040'" onmouseout="this.style.color='oklch(0.556 0 0)'">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 5v14M5 12h14"/>
                            </svg>
                        </button>
                    </div>
                    ${breadcrumbHTML}
                    ${metaHTML ? `<div style="margin-top: 16px;">${metaHTML}</div>` : ''}
                `;
                
                // Add click handlers for breadcrumbs
                if (v.category && v.topic) {
                    const categoryLink = card.querySelector('.breadcrumb-category');
                    const topicLink = card.querySelector('.breadcrumb-topic');
                    
                    if (categoryLink) {
                        categoryLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const categoryName = categoryLink.getAttribute('data-category');
                            handleBreadcrumbCategoryClick(categoryName);
                        });
                    }
                    
                    if (topicLink) {
                        topicLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const categoryName = topicLink.getAttribute('data-category');
                            const topicName = topicLink.getAttribute('data-topic');
                            handleBreadcrumbTopicClick(categoryName, topicName);
                        });
                    }
                }
                
                container.appendChild(card);
            });
        }

        // Initialize settings checkboxes on page load
        function initializeMetadataSettings() {
            const settings = loadMetadataSettings();
            document.getElementById('showSentiment').checked = settings.showSentiment;
            document.getElementById('showLocation').checked = settings.showLocation;
            document.getElementById('showIndex').checked = settings.showIndex;
        }

        // Toggle settings panel - uses UI controller module
        function toggleSettingsPanel() {
            return window.uiControllerToggleSettingsPanel();
        }

        // Update metadata settings and refresh cards
        function updateMetadataSettings() {
            const settings = {
                showSentiment: document.getElementById('showSentiment').checked,
                showLocation: document.getElementById('showLocation').checked,
                showIndex: document.getElementById('showIndex').checked
            };
            
            saveMetadataSettings(settings);
            
            // Re-render verbatims if they're currently displayed
            if (currentVerbatimsData) {
                renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
            }
        }

        // Close settings panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('settingsPanel');
            const button = document.querySelector('.settings-button');
            
            if (panel && button && !panel.contains(e.target) && !button.contains(e.target)) {
                panel.classList.remove('active');
                button.classList.remove('active');
            }
        });

        // Close overlay
        function closeOverlay() {
            const overlay = document.getElementById('overlay');
            const container = document.getElementById('verbatims');
            const panel = document.getElementById('settingsPanel');
            const button = document.querySelector('.settings-button');
            
            // Reset search term when closing overlay
            verbatimSearchTerm = '';
            const searchInput = document.getElementById('verbatimSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            updateVerbatimSearchClearButton();
            
            overlay.classList.remove('active');
            container.style.display = 'none';
            if (panel) panel.classList.remove('active');
            if (button) button.classList.remove('active');
            viewStack = [];
            currentVerbatimsData = null;
        }

        // Close overlay when clicking on backdrop
        document.addEventListener('DOMContentLoaded', () => {
            setupFilterTabs();
            // Auto-size selects after a short delay to ensure everything is rendered
            setTimeout(() => {
                autoSizeFilterSelects();
            }, 100);
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize metadata settings
            initializeMetadataSettings();
            
            // Initialize favourites section
            renderFavourites();
            
            // Setup verbatim search input event listener
            const verbatimSearchInput = document.getElementById('verbatimSearch');
            if (verbatimSearchInput) {
                verbatimSearchInput.addEventListener('input', (e) => {
                    verbatimSearchTerm = e.target.value;
                    if (currentVerbatimsData) {
                        renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
                    }
                    updateVerbatimSearchClearButton();
                });
            }
            
            // Setup favourites search input event listener
            const favouritesSearchInput = document.getElementById('favouritesSearch');
            if (favouritesSearchInput) {
                favouritesSearchInput.addEventListener('input', (e) => {
                    favouritesSearchTerm = e.target.value;
                    renderFavourites();
                    updateFavouritesSearchClearButton();
                });
            }
            
            // Setup treemap search input event listener
            const treemapSearchInput = document.getElementById('treemapSearch');
            if (treemapSearchInput) {
                // Use debounce to avoid too many searches while typing
                let treemapSearchTimeout;
                treemapSearchInput.addEventListener('input', (e) => {
                    clearTimeout(treemapSearchTimeout);
                    treemapSearchTimeout = setTimeout(() => {
                        handleTreemapSearch();
                    }, 300); // Wait 300ms after user stops typing
                });
                
                // Also handle Enter key for immediate search
                treemapSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        clearTimeout(treemapSearchTimeout);
                        handleTreemapSearch();
                    }
                });
            }
            
            // Fix mobile viewport height issues
            function setViewportHeight() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
            
            setViewportHeight();
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', setViewportHeight);
            
            const overlay = document.getElementById('overlay');
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeOverlay();
                }
            });
            
            // Close overlay with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay.classList.contains('active')) {
                    closeOverlay();
                }
            });
        });


        // Bar Chart functionality - uses chart-renderer module
        function generateCategoryColorPalette() {
            return window.chartRendererGenerateCategoryColorPalette();
        }

        function adjustColorLightness(color, percent) {
            return window.chartRendererAdjustColorLightness(color, percent);
        }

        function processBarChartData() {
            return window.chartRendererProcessBarChartData(rawData);
        }

        function renderBarChart() {
            window.chartRendererRenderBarChart({
                rawData,
                showVerbatims,
                showContextMenu,
                getDimensionDisplayName,
                currentProjectName,
                currentDataSourceId,
                currentQuestionRefKey
            });
        }

        function processTopicsData() {
            return window.chartRendererProcessTopicsData(rawData);
        }

        function toggleCategory(categoryId, toggleButton) {
            window.chartRendererToggleCategory(categoryId, toggleButton);
        }

        function renderHorizontalBarChart(data, containerId, totalCount, isMultiChoice = false) {
            window.chartRendererRenderHorizontalBarChart(data, containerId, totalCount, isMultiChoice);
        }

        function renderTopicsChart() {
            window.chartRendererRenderTopicsChart({
                rawData,
                showVerbatims,
                showContextMenu,
                getDimensionDisplayName,
                currentProjectName,
                currentDataSourceId,
                currentQuestionRefKey
            });
        }

        // Chart functions extracted to js/renderers/chart-renderer.js module
        // See renderBarChart, renderTopicsChart, renderHorizontalBarChart, toggleCategory

        // Process data for multi_choice question type
        function processMultiChoiceData() {
            const valueMap = new Map();
            let totalCount = 0;

            const rowsToProcess = rawData;
            
            rowsToProcess.forEach(row => {
                const value = (row.text || row.value || '').trim();
                if (!value) return;

                totalCount++;
                
                if (!valueMap.has(value)) {
                    valueMap.set(value, {
                        value: value,
                        count: 0
                    });
                }
                valueMap.get(value).count++;
            });

            const values = Array.from(valueMap.values())
                .map(item => ({
                    value: item.value,
                    count: item.count,
                    percent: totalCount > 0 ? (item.count / totalCount) * 100 : 0
                }))
                .sort((a, b) => b.count - a.count);

            return { values, totalCount };
        }

        // Process data for numeric question type
        function processNumericData() {
            const valueMap = new Map();
            let totalCount = 0;

            const rowsToProcess = currentQuestionRefKey 
                ? fullRawData.filter(row => row.dimension_ref === currentQuestionRefKey)
                : fullRawData;
            
            rowsToProcess.forEach(row => {
                const value = row.value ? row.value.trim() : null;
                if (!value) return;

                const numValue = parseFloat(value);
                if (isNaN(numValue)) return;

                totalCount++;

                if (!valueMap.has(value)) {
                    valueMap.set(value, {
                        value: value,
                        numericValue: numValue,
                        count: 0
                    });
                }
                valueMap.get(value).count++;
            });

            const values = Array.from(valueMap.values())
                .map(item => ({
                    value: item.value,
                    numericValue: item.numericValue,
                    count: item.count,
                    percent: totalCount > 0 ? (item.count / totalCount) * 100 : 0
                }))
                .sort((a, b) => b.count - a.count);

            return { values, totalCount };
        }

        // Process data for geo question type
        function processGeoData() {
            const stateMap = new Map();
            let totalCount = 0;

            const rowsToProcess = currentQuestionRefKey 
                ? fullRawData.filter(row => row.dimension_ref === currentQuestionRefKey)
                : fullRawData;
            
            rowsToProcess.forEach(row => {
                const value = row.value ? row.value.trim() : null;
                if (!value) return;

                totalCount++;
                const stateCode = getStateCode(value);
                
                if (!stateCode) {
                    if (!stateMap.has(value)) {
                        stateMap.set(value, {
                            stateName: value,
                            stateCode: null,
                            count: 0
                        });
                    }
                    stateMap.get(value).count++;
                } else {
                    if (!stateMap.has(stateCode)) {
                        stateMap.set(stateCode, {
                            stateName: value,
                            stateCode: stateCode,
                            count: 0
                        });
                    }
                    stateMap.get(stateCode).count++;
                }
            });

            const states = Array.from(stateMap.values())
                .map(item => ({
                    stateName: item.stateName,
                    stateCode: item.stateCode,
                    count: item.count,
                    percent: totalCount > 0 ? (item.count / totalCount) * 100 : 0
                }))
                .sort((a, b) => b.count - a.count);

            return { states, totalCount };
        }

        // Render US state choropleth map for geo question type
        async function renderGeoMap(data) {
            const container = document.querySelector('.treemap-svg-container');
            const svg = d3.select('#treemap');
            
            if (!container || !svg.node()) {
                console.error('Map container not found');
                return;
            }
            
            svg.selectAll('*').remove();
            
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;
            
            svg.attr('width', width).attr('height', height);
            
            const stateDataMap = new Map();
            data.states.forEach(state => {
                if (state.stateCode) {
                    stateDataMap.set(state.stateCode, state.count);
                }
            });
            
            const counts = Array.from(stateDataMap.values());
            const minCount = counts.length > 0 ? Math.min(...counts) : 0;
            const maxCount = counts.length > 0 ? Math.max(...counts) : 1;
            
            const colorScale = d3.scaleSequential()
                .domain([minCount, maxCount])
                .interpolator(d3.interpolateRgb('#fff7bc', '#d73027'));
            
            try {
                const us = await d3.json('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json');
                
                const projection = d3.geoAlbersUsa()
                    .scale(1070)
                    .translate([width / 2, height / 2]);
                
                const path = d3.geoPath().projection(projection);
                
                const states = topojson.feature(us, us.objects.states);
                
                svg.append('g')
                    .selectAll('path')
                    .data(states.features)
                    .enter()
                    .append('path')
                    .attr('d', path)
                    .attr('fill', d => {
                        const fipsCode = String(d.id);
                        const stateCode = fipsToStateCode[fipsCode];
                        const count = stateCode ? (stateDataMap.get(stateCode) || 0) : 0;
                        return count > 0 ? colorScale(count) : '#f0f0f0';
                    })
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 0.5)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        d3.select(this)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 2);
                        
                        const fipsCode = String(d.id);
                        const stateCode = fipsToStateCode[fipsCode];
                        const state = stateCode ? data.states.find(s => s.stateCode === stateCode) : null;
                        const count = state ? state.count : 0;
                        const percent = state ? state.percent : 0;
                        const stateName = state ? state.stateName : (d.properties?.name || fipsCode);
                        
                        const tooltip = d3.select('body').append('div')
                            .attr('class', 'geo-tooltip')
                            .style('opacity', 0)
                            .style('position', 'absolute')
                            .style('background', 'rgba(0, 0, 0, 0.8)')
                            .style('color', 'white')
                            .style('padding', '8px 12px')
                            .style('border-radius', '4px')
                            .style('pointer-events', 'none')
                            .style('font-size', '12px')
                            .style('z-index', '10000');
                        
                        tooltip.html(`
                            <strong>${stateName}</strong><br>
                            Count: ${count}<br>
                            ${percent.toFixed(1)}%
                        `)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px')
                            .transition()
                            .duration(200)
                            .style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 0.5);
                        
                        d3.selectAll('.geo-tooltip').remove();
                    });
                
                const legendWidth = 200;
                const legendHeight = 20;
                const legendX = width - legendWidth - 20;
                const legendY = height - legendHeight - 20;
                
                const legend = svg.append('g')
                    .attr('transform', `translate(${legendX}, ${legendY})`);
                
                const gradientId = 'geo-legend-gradient';
                const defs = svg.append('defs');
                const gradient = defs.append('linearGradient')
                    .attr('id', gradientId)
                    .attr('x1', '0%')
                    .attr('x2', '100%');
                
                const numStops = 10;
                for (let i = 0; i <= numStops; i++) {
                    const value = minCount + (maxCount - minCount) * (i / numStops);
                    gradient.append('stop')
                        .attr('offset', `${(i / numStops) * 100}%`)
                        .attr('stop-color', colorScale(value));
                }
                
                legend.append('rect')
                    .attr('width', legendWidth)
                    .attr('height', legendHeight)
                    .style('fill', `url(#${gradientId})`)
                    .style('stroke', '#ccc')
                    .style('stroke-width', 1);
                
                legend.append('text')
                    .attr('x', 0)
                    .attr('y', -5)
                    .style('font-size', '11px')
                    .style('fill', '#666')
                    .text(`${minCount}`);
                
                legend.append('text')
                    .attr('x', legendWidth)
                    .attr('y', -5)
                    .style('font-size', '11px')
                    .style('fill', '#666')
                    .style('text-anchor', 'end')
                    .text(`${maxCount}`);
                
            } catch (error) {
                console.error('Error loading US states map:', error);
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#999')
                    .text('Error loading map data');
            }
        }

        // Inline Dimension Editor Functions
        
        let currentEditingRefKey = null;
        
        function setupInlineDimensionEditor() {
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            const saveBtn = document.getElementById('saveDimensionBtn');
            const manageBtn = document.getElementById('manageOptionsBtn');
            
            // Handle dimension name select change
            nameSelect.onchange = function() {
                if (this.value === 'CUSTOM') {
                    customInput.style.display = 'block';
                    customInput.focus();
                } else {
                    customInput.style.display = 'none';
                    customInput.value = '';
                }
            };
            
            // Save button
            saveBtn.onclick = saveInlineDimensionName;
            
            // Manage options button
            manageBtn.onclick = manageOptions;
        }
        
        function updateInlineDimensionEditor(refKey) {
            currentEditingRefKey = refKey;
            
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            
            // Get current name for this dimension
            const currentName = dimensionNamesMap[refKey] || '';
            
            // Populate the dropdown
            let optionsHtml = '<option value="">-- Select --</option>';
            dimensionOptions.forEach(opt => {
                const selected = opt === currentName ? 'selected' : '';
                optionsHtml += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            
            // Check if current name is custom
            const isCustom = currentName && !dimensionOptions.includes(currentName);
            optionsHtml += `<option value="CUSTOM" ${isCustom ? 'selected' : ''}>Custom...</option>`;
            
            nameSelect.innerHTML = optionsHtml;
            
            // Show custom input if needed
            if (isCustom) {
                customInput.style.display = 'block';
                customInput.value = currentName;
            } else {
                customInput.style.display = 'none';
                customInput.value = '';
            }
        }
        
        async function saveInlineDimensionName() {
            if (!currentEditingRefKey) return;
            
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            const statusEl = document.getElementById('saveStatusInline');
            const saveBtn = document.getElementById('saveDimensionBtn');
            
            let customName = '';
            
            if (nameSelect.value === 'CUSTOM') {
                customName = customInput.value.trim();
            } else if (nameSelect.value) {
                customName = nameSelect.value;
            }
            
            if (!customName) {
                statusEl.textContent = 'Please select or enter a name';
                statusEl.style.color = '#C62828';
                setTimeout(() => statusEl.textContent = '', 2000);
                return;
            }
            
            statusEl.textContent = 'Saving...';
            statusEl.style.color = '#666';
            saveBtn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/data-sources/${currentDataSourceId}/dimension-names`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        ref_key: currentEditingRefKey,
                        custom_name: customName
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save dimension name');
                }
                
                // Update local map
                dimensionNamesMap[currentEditingRefKey] = customName;
                
                // Sync to module state
                if (window.apiCacheSetDimensionNamesMap) {
                    window.apiCacheSetDimensionNamesMap(dimensionNamesMap);
                }
                
                // Update the dimension dropdown to show the new name
                const questionSelect = document.getElementById('questionSelect');
                const selectedOption = questionSelect.querySelector(`option[value="${currentEditingRefKey}"]`);
                if (selectedOption) {
                    selectedOption.textContent = customName;
                }
                
                statusEl.textContent = 'Saved!';
                statusEl.style.color = '#2E7D32';
                
                setTimeout(() => statusEl.textContent = '', 2000);
                
            } catch (error) {
                console.error('Error saving dimension name:', error);
                statusEl.textContent = 'Error saving';
                statusEl.style.color = '#C62828';
            } finally {
                saveBtn.disabled = false;
            }
        }
        
        // Old overlay editor functions (keeping for backwards compatibility)
        
        function handleDimensionSelectChange(selectElement, refKey) {
            const item = selectElement.closest('.dimension-editor-item');
            const customInput = item.querySelector('.dimension-custom-input');
            
            if (selectElement.value === 'CUSTOM') {
                customInput.classList.add('active');
                customInput.focus();
            } else {
                customInput.classList.remove('active');
                customInput.value = '';
            }
        }
        
        async function openDimensionEditor() {
            const overlay = document.getElementById('dimensionEditorOverlay');
            const container = document.getElementById('dimensionEditorContent');
            
            // Build editor UI
            container.innerHTML = `
                <div class="dimension-editor-header">
                    <div>
                        <h3 style="margin: 0; font-size: 16px; color: #333;">Customize Dimension Names</h3>
                        <p style="margin: 4px 0 0 0; font-size: 13px; color: #888;">
                            Select from predefined dimensions or create custom ones
                        </p>
                    </div>
                    <div class="dimension-editor-actions">
                        <button class="manage-options-btn" onclick="manageOptions()">Manage Options</button>
                        <span class="dimension-status" id="saveStatus"></span>
                        <button class="save-all-btn" onclick="saveAllDimensions()">Save All</button>
                    </div>
                </div>
                <div id="dimensionsList"></div>
            `;
            
            const list = document.getElementById('dimensionsList');
            
            // Create editor items for each dimension
            availableQuestions.forEach(refKey => {
                const item = document.createElement('div');
                item.className = 'dimension-editor-item';
                item.setAttribute('data-ref-key', refKey);
                
                const currentName = dimensionNamesMap[refKey] || '';
                
                // Determine if current name is in the predefined list or custom
                const isCustom = currentName && !dimensionOptions.includes(currentName);
                const selectedValue = isCustom ? 'CUSTOM' : currentName;
                
                // Build options HTML
                let optionsHtml = '<option value="">-- Select Dimension --</option>';
                dimensionOptions.forEach(opt => {
                    const selected = opt === currentName ? 'selected' : '';
                    optionsHtml += `<option value="${opt}" ${selected}>${opt}</option>`;
                });
                optionsHtml += '<option value="CUSTOM" ' + (isCustom ? 'selected' : '') + '>Custom...</option>';
                
                item.innerHTML = `
                    <div class="dimension-ref">${refKey.replace('ref_', 'Q')}</div>
                    <div class="dimension-controls">
                        <select 
                            class="dimension-select" 
                            data-ref-key="${refKey}"
                            onchange="handleDimensionSelectChange(this, '${refKey}')"
                        >
                            ${optionsHtml}
                        </select>
                        <input 
                            type="text" 
                            class="dimension-custom-input ${isCustom ? 'active' : ''}" 
                            placeholder="Enter custom dimension name"
                            value="${isCustom ? currentName : ''}"
                            data-ref-key="${refKey}"
                        />
                    </div>
                `;
                
                list.appendChild(item);
            });
            
            // Show overlay
            overlay.classList.add('active');
        }
        
        function closeDimensionEditor() {
            const overlay = document.getElementById('dimensionEditorOverlay');
            overlay.classList.remove('active');
        }
        
        async function saveAllDimensions() {
            const statusEl = document.getElementById('saveStatus');
            const saveBtn = document.querySelector('.save-all-btn');
            
            statusEl.textContent = 'Saving...';
            statusEl.className = 'dimension-status';
            saveBtn.disabled = true;
            
            try {
                // Collect all dimension names
                const items = document.querySelectorAll('.dimension-editor-item');
                const dimensionNames = [];
                
                items.forEach(item => {
                    const refKey = item.getAttribute('data-ref-key');
                    const select = item.querySelector('.dimension-select');
                    const customInput = item.querySelector('.dimension-custom-input');
                    
                    let customName = '';
                    
                    if (select.value === 'CUSTOM') {
                        customName = customInput.value.trim();
                    } else if (select.value) {
                        customName = select.value;
                    }
                    
                    if (customName) {
                        dimensionNames.push({
                            ref_key: refKey,
                            custom_name: customName
                        });
                    }
                });
                
                // Send batch update to API
                const response = await fetch(`${API_BASE_URL}/api/data-sources/${currentDataSourceId}/dimension-names/batch`, {
                    method: 'POST',
                    headers: {
                        ...getAuthHeaders(),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        dimension_names: dimensionNames
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save dimension names');
                }
                
                // Update local map
                await loadDimensionNames();
                
                // Update the dropdown
                await detectAndSetupQuestionFilter();
                
                statusEl.textContent = 'Saved successfully!';
                statusEl.className = 'dimension-status saved';
                
                setTimeout(() => {
                    closeDimensionEditor();
                }, 1500);
                
            } catch (error) {
                console.error('Error saving dimension names:', error);
                statusEl.textContent = 'Error saving. Please try again.';
                statusEl.className = 'dimension-status unsaved';
            } finally {
                saveBtn.disabled = false;
            }
        }
        
        function manageOptions() {
            const newOptions = prompt(
                'Manage Dimension Options\n\n' +
                'Current options:\n' + dimensionOptions.join('\n') + '\n\n' +
                'Enter new options (one per line, or leave blank to cancel):'
            );
            
            if (newOptions !== null && newOptions.trim()) {
                const lines = newOptions.trim().split('\n').map(line => line.trim()).filter(line => line);
                
                // Add new unique options
                lines.forEach(line => {
                    if (!dimensionOptions.includes(line)) {
                        dimensionOptions.push(line);
                    }
                });
                
                // Sort alphabetically
                dimensionOptions.sort();
                
                // Save to localStorage for persistence
                localStorage.setItem('dimensionOptions', JSON.stringify(dimensionOptions));
                
                alert('Options updated! Close and reopen the editor to see changes.');
            }
        }
        
        // Load dimension options from localStorage on startup
        function loadDimensionOptions() {
            const saved = localStorage.getItem('dimensionOptions');
            if (saved) {
                try {
                    dimensionOptions = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading dimension options:', e);
                }
            }
        }
        
        // Close dimension editor on backdrop click
        document.addEventListener('DOMContentLoaded', () => {
            const dimensionOverlay = document.getElementById('dimensionEditorOverlay');
            dimensionOverlay.addEventListener('click', (e) => {
                if (e.target === dimensionOverlay) {
                    closeDimensionEditor();
                }
            });
            
            // Close with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && dimensionOverlay.classList.contains('active')) {
                    closeDimensionEditor();
                }
            });
        });

        // SPA Routing Functions
        function navigateToView(viewName) {
            const vizSection = document.getElementById('visualizations-section');
            const insightsSection = document.getElementById('insights-section');
            const historySection = document.getElementById('history-section');
            const adsSection = document.getElementById('ads-section');
            const settingsSection = document.getElementById('settings-section');
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            const navHistory = document.getElementById('navHistory');
            const navAds = document.getElementById('navAds');
            const navSettings = document.getElementById('navSettings');
            const mainContainer = document.getElementById('mainContainer');
            
            // Store scroll position when leaving visualizations view
            if (vizSection && vizSection.classList.contains('active') && viewName !== 'visualizations') {
                window.visualizationsScrollPosition = window.scrollY;
            }
            
            // Hide all sections - CSS class will handle the hiding
            // Also ensure they're completely removed from layout flow
            if (vizSection) {
                vizSection.classList.remove('active');
                if (!vizSection.classList.contains('active')) {
                    vizSection.style.display = 'none';
                    vizSection.style.height = '0';
                    vizSection.style.minHeight = '0';
                    vizSection.style.maxHeight = '0';
                    vizSection.style.overflow = 'hidden';
                }
            }
            if (insightsSection) {
                insightsSection.classList.remove('active');
                if (!insightsSection.classList.contains('active')) {
                    insightsSection.style.display = 'none';
                    insightsSection.style.height = '0';
                    insightsSection.style.minHeight = '0';
                    insightsSection.style.maxHeight = '0';
                    insightsSection.style.overflow = 'hidden';
                }
            }
            if (historySection) {
                historySection.classList.remove('active');
                if (!historySection.classList.contains('active')) {
                    historySection.style.display = 'none';
                    historySection.style.height = '0';
                    historySection.style.minHeight = '0';
                    historySection.style.maxHeight = '0';
                    historySection.style.overflow = 'hidden';
                }
            }
            if (adsSection) {
                adsSection.classList.remove('active');
                if (!adsSection.classList.contains('active')) {
                    adsSection.style.display = 'none';
                    adsSection.style.height = '0';
                    adsSection.style.minHeight = '0';
                    adsSection.style.maxHeight = '0';
                    adsSection.style.overflow = 'hidden';
                }
            }
            if (settingsSection) {
                settingsSection.classList.remove('active');
                if (!settingsSection.classList.contains('active')) {
                    settingsSection.style.display = 'none';
                    settingsSection.style.height = '0';
                    settingsSection.style.minHeight = '0';
                    settingsSection.style.maxHeight = '0';
                    settingsSection.style.overflow = 'hidden';
                }
            }
            
            // Remove active class from all nav items
            if (navVisualizations) navVisualizations.classList.remove('active');
            if (navInsights) navInsights.classList.remove('active');
            if (navHistory) navHistory.classList.remove('active');
            if (navAds) navAds.classList.remove('active');
            if (navSettings) navSettings.classList.remove('active');
            
            // Show selected section and update nav - CSS class will handle the showing
            if (viewName === 'visualizations') {
                if (vizSection) {
                    vizSection.classList.add('active');
                    // Reset styles for active section
                    vizSection.style.display = '';
                    vizSection.style.height = '';
                    vizSection.style.minHeight = '';
                    vizSection.style.maxHeight = '';
                    vizSection.style.overflow = '';
                }
                if (navVisualizations) navVisualizations.classList.add('active');
                // Reset container min-height for visualizations (which may need full height)
                if (mainContainer) {
                    mainContainer.style.minHeight = '100vh';
                    mainContainer.removeAttribute('data-view');
                }
                
                // Re-render visualizations when switching to visualizations tab
                // This fixes issues where charts don't render correctly when the section was hidden
                if (typeof hierarchyData !== 'undefined' && hierarchyData && typeof rawData !== 'undefined' && rawData && rawData.length > 0) {
                    // Wait for DOM to update so container is visible before measuring
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Double RAF ensures layout has completed
                            const container = document.querySelector('.treemap-svg-container');
                            const barChartBars = document.getElementById('barChartBars');
                            const topicsChartBars = document.getElementById('topicsChartBars');
                            
                            // Check if visualizations need re-rendering
                            // This can happen if the section was hidden when data loaded
                            const treemapNeedsRender = container && (() => {
                                const newWidth = container.clientWidth;
                                const newHeight = container.clientHeight;
                                if (!newWidth || !newHeight || newWidth < 100 || newHeight < 100) return false;
                                const svg = document.getElementById('treemap');
                                if (!svg) return true;
                                // Check if treemap is empty or has wrong dimensions
                                const hasContent = svg.querySelector('g') !== null;
                                if (!hasContent) return true;
                                const currentWidth = parseInt(svg.getAttribute('width')) || 0;
                                const currentHeight = parseInt(svg.getAttribute('height')) || 0;
                                return Math.abs(newWidth - currentWidth) > 10 || Math.abs(newHeight - currentHeight) > 10;
                            })();
                            
                            const chartsNeedRender = (barChartBars && !barChartBars.hasChildNodes()) ||
                                                     (topicsChartBars && !topicsChartBars.hasChildNodes());
                            
                            if (treemapNeedsRender || chartsNeedRender) {
                                console.log('[navigateToView] Re-rendering visualizations:', {
                                    treemap: treemapNeedsRender,
                                    charts: chartsNeedRender
                                });
                                
                                if (treemapNeedsRender && typeof renderTreemap === 'function') {
                                    renderTreemap(hierarchyData);
                                }
                                if (chartsNeedRender) {
                                    if (typeof renderBarChart === 'function') {
                                        renderBarChart();
                                    }
                                    if (typeof renderTopicsChart === 'function') {
                                        renderTopicsChart();
                                    }
                                }
                            }
                        });
                    });
                }
                
                // Restore scroll position if it was previously saved
                if (window.visualizationsScrollPosition !== undefined) {
                    requestAnimationFrame(() => {
                        window.scrollTo({ top: window.visualizationsScrollPosition, behavior: 'auto' });
                    });
                }
            } else if (viewName === 'insights') {
                // Sync insightsCurrentClientId with currentClientId when navigating to insights
                if (currentClientId && insightsCurrentClientId !== currentClientId) {
                    insightsCurrentClientId = currentClientId;
                }
                
                if (insightsSection) {
                    insightsSection.classList.add('active');
                    // Reset styles for active section
                    insightsSection.style.display = '';
                    insightsSection.style.height = '';
                    insightsSection.style.minHeight = '';
                    insightsSection.style.maxHeight = '';
                    insightsSection.style.overflow = '';
                }
                if (navInsights) navInsights.classList.add('active');
                // Remove min-height constraint for insights to allow natural sizing
                if (mainContainer) {
                    mainContainer.style.minHeight = 'auto';
                    mainContainer.style.height = 'auto';
                    mainContainer.setAttribute('data-view', 'insights');
                }
                
                // Reload insights for the current client
                // Reset the initialized flag to force reload with current client data
                window.insightsInitialized = false;
                if (typeof initInsightsPage === 'function') {
                    initInsightsPage();
                } else {
                }
                
                // Scroll to top to ensure insights section is visible
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // Also scroll the container if it's scrollable
                if (mainContainer && mainContainer.scrollTop > 0) {
                    mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
                }
                // Initialize insights page if not already loaded
                if (typeof initInsightsPage === 'function' && !window.insightsInitialized) {
                    initInsightsPage();
                }
            } else if (viewName === 'history') {
                // Sync historyCurrentClientId with currentClientId when navigating to history
                if (currentClientId && historyCurrentClientId !== currentClientId) {
                    historyCurrentClientId = currentClientId;
                }
                
                if (historySection) {
                    historySection.classList.add('active');
                    // Reset styles for active section
                    historySection.style.display = '';
                    historySection.style.height = '';
                    historySection.style.minHeight = '';
                    historySection.style.maxHeight = '';
                    historySection.style.overflow = '';
                }
                if (navHistory) navHistory.classList.add('active');
                // Remove min-height constraint for history to allow natural sizing
                if (mainContainer) {
                    mainContainer.style.minHeight = 'auto';
                    mainContainer.style.height = 'auto';
                    mainContainer.setAttribute('data-view', 'history');
                }
                
                // Reload history for the current client
                // Reset the initialized flag to force reload with current client data
                window.historyInitialized = false;
                if (typeof initHistoryPage === 'function') {
                    initHistoryPage();
                }
                
                // Scroll to top to ensure history section is visible
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // Also scroll the container if it's scrollable
                if (mainContainer && mainContainer.scrollTop > 0) {
                    mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
                }
                // Initialize history page if not already loaded
                if (typeof initHistoryPage === 'function' && !window.historyInitialized) {
                    initHistoryPage();
                }
            } else if (viewName === 'ads') {
                if (adsSection) {
                    adsSection.classList.add('active');
                    // Reset styles for active section
                    adsSection.style.display = '';
                    adsSection.style.height = '';
                    adsSection.style.minHeight = '';
                    adsSection.style.maxHeight = '';
                    adsSection.style.overflow = '';
                }
                if (navAds) navAds.classList.add('active');
                // Remove min-height constraint for ads to allow natural sizing
                if (mainContainer) {
                    mainContainer.style.minHeight = 'auto';
                    mainContainer.style.height = 'auto';
                    mainContainer.setAttribute('data-view', 'ads');
                }
                
                // Initialize ads page
                window.adsInitialized = false;
                if (typeof initAdsPage === 'function') {
                    initAdsPage();
                }
                
                // Scroll to top to ensure ads section is visible
                window.scrollTo({ top: 0, behavior: 'smooth' });
                if (mainContainer && mainContainer.scrollTop > 0) {
                    mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
                }
            } else if (viewName === 'settings') {
                if (settingsSection) {
                    settingsSection.classList.add('active');
                    // Reset styles for active section
                    settingsSection.style.display = '';
                    settingsSection.style.height = '';
                    settingsSection.style.minHeight = '';
                    settingsSection.style.maxHeight = '';
                    settingsSection.style.overflow = '';
                }
                if (navSettings) navSettings.classList.add('active');
                // Remove min-height constraint for settings to allow natural sizing
                if (mainContainer) {
                    mainContainer.style.minHeight = 'auto';
                    mainContainer.style.height = 'auto';
                    mainContainer.setAttribute('data-view', 'settings');
                }
                
                // Initialize settings page
                window.settingsInitialized = false;
                if (typeof initSettingsPage === 'function') {
                    initSettingsPage();
                }
                
                // Scroll to top to ensure settings section is visible
                window.scrollTo({ top: 0, behavior: 'smooth' });
                if (mainContainer && mainContainer.scrollTop > 0) {
                    mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }
            
            // Update URL hash without reload
            const urlParams = new URLSearchParams(window.location.search);
            let hash = '#/';
            if (viewName === 'insights') {
                hash = '#/insights';
            } else if (viewName === 'history') {
                hash = '#/history';
            } else if (viewName === 'ads') {
                hash = '#/ads';
            } else if (viewName === 'settings') {
                hash = '#/settings';
            }
            const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '') + hash;
            window.history.pushState({ view: viewName }, '', newUrl);
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else if (hash === '#/history') {
                navigateToView('history');
            } else if (hash === '#/ads') {
                navigateToView('ads');
            } else if (hash === '#/settings') {
                navigateToView('settings');
            } else {
                navigateToView('visualizations');
            }
        });
        
        // Handle hash changes (for direct navigation)
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else if (hash === '#/history') {
                navigateToView('history');
            } else if (hash === '#/ads') {
                navigateToView('ads');
            } else if (hash === '#/settings') {
                navigateToView('settings');
            } else {
                navigateToView('visualizations');
            }
        });
        
        // Set active navigation item based on current route
        function setActiveNavItem() {
            const hash = window.location.hash;
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            const navHistory = document.getElementById('navHistory');
            const navSettings = document.getElementById('navSettings');
            
            // Remove active class from all items
            if (navVisualizations) navVisualizations.classList.remove('active');
            if (navInsights) navInsights.classList.remove('active');
            if (navHistory) navHistory.classList.remove('active');
            if (navSettings) navSettings.classList.remove('active');
            
            // Set active based on hash
            if (hash === '#/insights') {
                if (navInsights) navInsights.classList.add('active');
            } else if (hash === '#/history') {
                if (navHistory) navHistory.classList.add('active');
            } else if (hash === '#/settings') {
                if (navSettings) navSettings.classList.add('active');
            } else {
                // Default to visualizations
                if (navVisualizations) navVisualizations.classList.add('active');
            }
        }

        // Update navigation links to include current context
        function updateNavLinks() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientUuid = urlParams.get('client_uuid') || currentClientId;
            const authToken = getAuthToken() || localStorage.getItem('visualizd_auth_token');
            
            // Get current visualization state to preserve it in navigation
            const currentProject = urlParams.get('project') || currentProjectName;
            const currentSource = urlParams.get('source') || currentDataSourceId;
            const currentDimension = urlParams.get('dimension') || currentQuestionRefKey;
            
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            
            if (navVisualizations) {
                let vizUrl = '/';
                const vizParams = new URLSearchParams();
                if (clientUuid) {
                    vizParams.set('client_uuid', clientUuid);
                }
                if (authToken) {
                    vizParams.set('auth_token', authToken);
                }
                // Preserve visualization state when navigating back
                if (currentProject) {
                    vizParams.set('project', currentProject);
                }
                if (currentSource) {
                    vizParams.set('source', currentSource);
                }
                if (currentDimension) {
                    vizParams.set('dimension', currentDimension);
                }
                if (vizParams.toString()) {
                    vizUrl += `?${vizParams.toString()}`;
                }
                navVisualizations.href = vizUrl;
            }
            
            if (navInsights) {
                // Use SPA hash routing instead of separate page
                navInsights.href = '#';
                navInsights.onclick = (e) => {
                    e.preventDefault();
                    navigateToView('insights');
                    return false;
                };
            }
        }


        // Start the application - check auth first
        console.log('Starting application...');
        
        // Quick synchronous check - if no token, show login immediately to avoid flash
        const token = typeof Auth !== 'undefined' ? Auth.getAuthToken() : null;
        if (!token) {
            console.log('No token found, showing login immediately');
            if (typeof Auth !== 'undefined') {
                Auth.showLogin();
            } else {
                document.getElementById('loginOverlay').classList.remove('hidden');
            }
        }
        // If token exists, keep login hidden (it's already hidden by default)
        // and let async checkAuth() verify it
        
        // Initialize navigation when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setActiveNavItem();
                updateNavLinks();
                // Check hash on page load for routing
                const hash = window.location.hash;
                if (hash === '#/insights') {
                    navigateToView('insights');
                } else if (hash === '#/history') {
                    navigateToView('history');
                } else if (hash === '#/settings') {
                    navigateToView('settings');
                } else {
                    navigateToView('visualizations');
                }
            });
        } else {
            setActiveNavItem();
            updateNavLinks();
            // Check hash on page load for routing
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else if (hash === '#/history') {
                navigateToView('history');
            } else if (hash === '#/settings') {
                navigateToView('settings');
            } else {
                navigateToView('visualizations');
            }
        }

        // Insights Page JavaScript
        let insightsCurrentClientId = null;
        
        // Settings Page JavaScript
        // Uses state from /js/state/settings-state.js and API from /js/services/api-settings.js
        
        async function initSettingsPage() {
            // Get client ID from URL params or global state
            const urlParams = new URLSearchParams(window.location.search);
            let effectiveClientId = urlParams.get('client_uuid') || currentClientId;
            
            // If no client ID yet, wait for it (with timeout)
            if (!effectiveClientId) {
                let retryAttempts = 0;
                const maxAttempts = 20;
                
                while (!effectiveClientId && retryAttempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    effectiveClientId = currentClientId;
                    retryAttempts++;
                }
            }
            
            const currentSettingsClientId = window.settingsStateGetSettingsCurrentClientId();
            if (window.settingsStateGetSettingsInitialized() && currentSettingsClientId === effectiveClientId) {
                return;
            }
            
            window.settingsStateSetSettingsCurrentClientId(effectiveClientId);
            
            if (!effectiveClientId) {
                console.warn('[Settings] No client selected');
                return;
            }
            
            await loadClientSettings();
            window.settingsStateSetSettingsInitialized(true);
        }
        
        async function loadClientSettings() {
            const clientId = window.settingsStateGetSettingsCurrentClientId();
            if (!clientId) return;
            
            try {
                const client = await window.settingsApiFetchClientSettings(clientId);
                
                // Populate form fields
                const clientUrlEl = document.getElementById('settingsClientUrl');
                const logoUrlEl = document.getElementById('settingsLogoUrl');
                const headerColorEl = document.getElementById('settingsHeaderColor');
                const headerColorPickerEl = document.getElementById('settingsHeaderColorPicker');
                const businessSummaryEl = document.getElementById('settingsBusinessSummary');
                const toneOfVoiceEl = document.getElementById('settingsToneOfVoice');
                
                if (clientUrlEl) clientUrlEl.value = client.client_url || '';
                if (logoUrlEl) logoUrlEl.value = client.logo_url || '';
                if (headerColorEl) headerColorEl.value = client.header_color || '#FFFFFF';
                if (headerColorPickerEl) headerColorPickerEl.value = client.header_color || '#FFFFFF';
                if (businessSummaryEl) businessSummaryEl.value = client.business_summary || '';
                if (toneOfVoiceEl) toneOfVoiceEl.value = client.tone_of_voice || '';
                
                // Update logo preview
                updateLogoPreview(client.logo_url);
                
            } catch (error) {
                console.error('[Settings] Failed to load client settings:', error);
            }
        }
        
        function updateLogoPreview(logoUrl) {
            const preview = document.getElementById('settingsLogoPreview');
            if (!preview) return;
            
            if (logoUrl && logoUrl.trim()) {
                preview.innerHTML = `<img src="${logoUrl}" alt="Logo preview" onerror="this.parentElement.innerHTML='<span class=\\'settings-logo-placeholder\\'>Failed to load image</span>'">`;
            } else {
                preview.innerHTML = '<span class="settings-logo-placeholder">No logo set</span>';
            }
        }
        
        async function saveClientSettings() {
            const clientId = window.settingsStateGetSettingsCurrentClientId();
            if (!clientId) {
                showSettingsStatus('No client selected', true);
                return;
            }
            
            const saveBtn = document.getElementById('settingsSaveBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            try {
                const settingsData = {
                    client_url: document.getElementById('settingsClientUrl').value.trim() || null,
                    logo_url: document.getElementById('settingsLogoUrl').value.trim() || null,
                    header_color: document.getElementById('settingsHeaderColor').value.trim() || null,
                    business_summary: document.getElementById('settingsBusinessSummary').value.trim() || null,
                    tone_of_voice: document.getElementById('settingsToneOfVoice').value.trim() || null
                };
                
                const updatedClient = await window.settingsApiUpdateClientSettings(clientId, settingsData);
                
                // Update the logo preview
                updateLogoPreview(updatedClient.logo_url);
                
                // Update the header logo if visible
                updateHeaderLogo(updatedClient.logo_url, updatedClient.header_color);
                
                showSettingsStatus('Settings saved successfully');
                
            } catch (error) {
                console.error('[Settings] Failed to save settings:', error);
                showSettingsStatus(error.message || 'Failed to save settings', true);
            } finally {
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }
        
        function showSettingsStatus(message, isError = false) {
            const status = document.getElementById('settingsSaveStatus');
            if (!status) return;
            
            status.textContent = message;
            status.classList.toggle('error', isError);
            status.classList.add('visible');
            
            setTimeout(() => {
                status.classList.remove('visible');
            }, 3000);
        }
        
        function updateHeaderLogo(logoUrl, headerColor) {
            // Update the nav client logo if it exists
            const logoContainer = document.querySelector('.nav-client-logo-container');
            if (logoContainer && logoUrl) {
                const existingImg = logoContainer.querySelector('.nav-client-logo-image');
                if (existingImg) {
                    existingImg.src = logoUrl;
                }
            }
            
            // Update header background color if needed
            const nav = document.querySelector('.app-navigation');
            if (nav && headerColor) {
                nav.style.backgroundColor = headerColor;
            }
        }
        
        // Sync color picker with text input
        document.addEventListener('DOMContentLoaded', () => {
            const colorPicker = document.getElementById('settingsHeaderColorPicker');
            const colorText = document.getElementById('settingsHeaderColor');
            const logoUrlInput = document.getElementById('settingsLogoUrl');
            
            if (colorPicker && colorText) {
                colorPicker.addEventListener('input', (e) => {
                    colorText.value = e.target.value.toUpperCase();
                });
                
                colorText.addEventListener('input', (e) => {
                    const value = e.target.value;
                    if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                        colorPicker.value = value;
                    }
                });
            }
            
            // Update logo preview on URL change
            if (logoUrlInput) {
                logoUrlInput.addEventListener('blur', (e) => {
                    updateLogoPreview(e.target.value);
                });
            }
        });
        
        // History Page JavaScript
        let historyCurrentClientId = null;
        let historyAllActions = [];
        let historySearchTerm = '';
        let selectedHistoryIds = new Set();
        let historyCurrentSortBy = 'created_at';
        let historySortOrder = 'desc';
        window.historyInitialized = false;
        let insightsCurrentInsightId = null;
        let insightsFilters = []; // Changed to array to support multiple filters
        let insightsCurrentSortBy = 'name';
        let insightsSortOrder = 'asc';
        let insightsSearchTerm = '';
        let insightsAllInsights = [];
        let insightsCurrentInsightEditor = null;
        // Get storage key scoped by client ID for filter persistence
        function getFilterStorageKey() {
            const clientId = insightsCurrentClientId || currentClientId || 'global';
            return window.storageGetFilterStorageKey(clientId);
        }
        
        // Available filter fields
        const FILTER_FIELDS = [
            { id: 'status', label: 'Status', icon: '', type: 'select' },
            { id: 'type', label: 'Type', icon: '', type: 'select' },
            { id: 'application', label: 'Application', icon: '', type: 'select' },
            { id: 'project', label: 'Project', icon: '', type: 'select' },
            { id: 'data_source', label: 'Data Source', icon: '', type: 'select' },
            { id: 'created_at', label: 'Created', icon: '', type: 'date' }
        ];
        let insightsCurrentInsightNotesId = null;
        let insightsCurrentInsightData = null;
        let insightsSaveNotesTimeout = null;
        let insightsFieldSaveTimeout = null;
        let insightsEditorContextMenuHandlers = null;
        let selectedInsightIds = new Set();
        window.insightsInitialized = false;

        // getAuthHeadersSafe - now imported from js/services/auth-service.js module
        // Wrapper function that uses module
        function getAuthHeadersSafe() {
            return window.authServiceGetHeadersSafe();
        }

        async function initInsightsPage() {
            // Check if already initialized - this is reset to false when navigating to allow reload
            if (window.insightsInitialized) {
                return;
            }
            
            // Wait for auth to be available
            let attempts = 0;
            while (typeof getAuthHeaders === 'undefined' && attempts < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            const urlParams = new URLSearchParams(window.location.search);
            insightsCurrentClientId = urlParams.get('client_uuid') || currentClientId;
            
            const authTokenFromUrl = urlParams.get('auth_token');
            if (authTokenFromUrl) {
                localStorage.setItem('visualizd_auth_token', authTokenFromUrl);
            }

            if (!insightsCurrentClientId) {
                // Wait for currentClientId to be set (with timeout)
                let retryAttempts = 0;
                const maxRetries = 50; // 5 seconds max wait
                while (!currentClientId && retryAttempts < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retryAttempts++;
                }
                
                if (currentClientId) {
                    insightsCurrentClientId = currentClientId;
                } else {
                    const tbody = document.getElementById('insightsTableBody') || document.getElementById('insightsPageTableBody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>No client specified</h3><p style="font-size: 12px; color: #999;">Please select a client first</p></td></tr>';
                    }
                    window.insightsInitialized = true;
                    return;
                }
            }

            
            // Load filters from storage on initialization
            loadFiltersFromStorage();
            
            // Update filter UI to reflect loaded filters
            updateFilterChips();
            updateActiveFiltersDisplay();
            
            await loadInsightsPage();
            window.insightsInitialized = true;
        }
        
        // Close filter dropdown when clicking outside
        // Use a small delay to allow button click to process first
        document.addEventListener('click', (e) => {
            setTimeout(() => {
                // Get the dropdown and button from the insights-section
                const insightsSection = document.getElementById('insights-section');
                const dropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
                const btn = document.getElementById('filterMenuBtn');
                
                if (dropdown && btn) {
                    // Check if click is outside both dropdown and button
                    const clickedInsideDropdown = dropdown.contains(e.target);
                    const clickedInsideButton = btn.contains(e.target);
                    
                    // Check if dropdown is visible (either has 'active' class or display is not 'none')
                    const isDropdownVisible = dropdown.classList.contains('active') || 
                                             (dropdown.style.display !== 'none' && 
                                              window.getComputedStyle(dropdown).display !== 'none');
                    
                    if (!clickedInsideDropdown && !clickedInsideButton && isDropdownVisible) {
                        dropdown.classList.remove('active');
                        dropdown.style.display = 'none';
                    }
                }
                
                // Close inline filter dropdowns when clicking outside
                // But don't close if we just created one (give it a moment)
                document.querySelectorAll('.inline-filter-dropdown').forEach(inlineDropdown => {
                    // Check if this dropdown was just created (has a data-just-created attribute)
                    const justCreated = inlineDropdown.getAttribute('data-just-created') === 'true';
                    if (justCreated) {
                        // Remove the flag after a short delay
                        setTimeout(() => {
                            inlineDropdown.removeAttribute('data-just-created');
                        }, 100);
                        return; // Don't close it if it was just created
                    }
                    
                    if (!inlineDropdown.contains(e.target)) {
                        const header = inlineDropdown.querySelector('.inline-filter-header');
                        const options = inlineDropdown.querySelector('.inline-filter-options');
                        if (header && options && options.classList.contains('open')) {
                            header.classList.remove('open');
                            options.classList.remove('open');
                            options.style.display = 'none';
                        }
                    }
                });
            }, 10);
        });

        async function loadInsightsPage() {
            
            if (!insightsCurrentClientId) {
                return;
            }

            const tbody = document.getElementById('insightsPageTableBody');
            if (!tbody) {
                return;
            }
            
            tbody.innerHTML = '<tr><td colspan="9" class="loading">Loading insights...</td></tr>';

            try {
                // Map 'origin' to 'created_at' for backend sorting (backend doesn't support project sorting)
                // We'll sort by origin client-side after loading
                const backendSortBy = insightsCurrentSortBy === 'origin' ? 'created_at' : 
                                     insightsCurrentSortBy === 'name' ? 'name' : 
                                     insightsCurrentSortBy === 'created_at' ? 'created_at' : 'created_at';
                
                const params = new URLSearchParams({
                    page: '1',
                    page_size: '1000',
                    sort_by: backendSortBy,
                    sort_order: insightsSortOrder,
                });

                // Fetch insights using API module
                const data = await window.insightsApiLoadInsights(insightsCurrentClientId, {
                    page: '1',
                    page_size: '1000',
                    sort_by: backendSortBy,
                    sort_order: insightsSortOrder,
                    filters: insightsFilters
                }, getAuthHeadersSafe);
                
                insightsAllInsights = data.items || [];
                
                // Sort by origin client-side if needed (backend doesn't support project sorting)
                if (insightsCurrentSortBy === 'origin') {
                    insightsAllInsights.sort((a, b) => {
                        const aOrigin = a.origins?.[0] || {};
                        const bOrigin = b.origins?.[0] || {};
                        const aProject = aOrigin.project_name || '';
                        const bProject = bOrigin.project_name || '';
                        const aDimension = aOrigin.dimension_name || aOrigin.dimension_ref || '';
                        const bDimension = bOrigin.dimension_name || bOrigin.dimension_ref || '';
                        
                        // Sort by project first, then dimension
                        const projectCompare = aProject.localeCompare(bProject);
                        if (projectCompare !== 0) {
                            return insightsSortOrder === 'asc' ? projectCompare : -projectCompare;
                        }
                        const dimensionCompare = aDimension.localeCompare(bDimension);
                        return insightsSortOrder === 'asc' ? dimensionCompare : -dimensionCompare;
                    });
                }
                
                // Sync to module state so renderInsights() in visualizations panel has data
                if (window.insightsStateSetAllInsights) {
                    window.insightsStateSetAllInsights(insightsAllInsights);
                }
                
                // Restore visible filter dropdowns after loading insights (so we have data for dropdown options)
                restoreFilterDropdowns();
                
                renderInsightsPage();
            } catch (error) {
                console.error('Error loading insights:', error);
                const errorTbody = document.getElementById('insightsPageTableBody');
                if (errorTbody) {
                    const escapeHtmlFn = window.escapeHtml;
                    const errorMessage = error.message || 'Unknown error occurred';
                    errorTbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>Error loading insights</h3><p>' + escapeHtmlFn(errorMessage) + '</p></td></tr>';
                }
            }
        }

        function renderInsightsPage() {
            const escapeHtmlFn = window.escapeHtml;
            const tbody = document.getElementById('insightsPageTableBody');
            if (!tbody) {
                return;
            }
            
            let filtered = [...insightsAllInsights];
            
            // Apply search
            if (insightsSearchTerm) {
                const term = insightsSearchTerm.toLowerCase();
                filtered = filtered.filter(insight => 
                    insight.name?.toLowerCase().includes(term) ||
                    insight.description?.toLowerCase().includes(term)
                );
            }
            
            // Apply filters
            if (insightsFilters && insightsFilters.length > 0) {
                filtered = filtered.filter(insight => {
                    return insightsFilters.every(filter => {
                        let insightValue = null;
                        let isSpecialFilter = false;
                        
                        if (filter.field === 'status') {
                            insightValue = insight.status || 'Not Started';
                        } else if (filter.field === 'type') {
                            insightValue = insight.type || '-';
                        } else if (filter.field === 'application') {
                            // Application is an array - check if filter value is in the array
                            isSpecialFilter = true;
                            if (insight.application && Array.isArray(insight.application) && insight.application.length > 0) {
                                // Check if any application in the array matches the filter value
                                return insight.application.some(app => 
                                    app && app.trim().toLowerCase() === filter.value.toLowerCase()
                                );
                            }
                            return false;
                        } else if (filter.field === 'project' || filter.field === 'data_source') {
                            const firstOrigin = insight.origins?.[0] || {};
                            if (filter.field === 'project') {
                                insightValue = firstOrigin.project_name || '-';
                            } else if (filter.field === 'data_source') {
                                insightValue = firstOrigin.data_source || '-';
                            }
                        } else if (filter.field === 'created_at') {
                            isSpecialFilter = true;
                            const createdDate = new Date(insight.created_at);
                            const now = new Date();
                            let periodStart = null;
                            let periodEnd = null;
                            
                            if (filter.value === 'today') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
                            } else if (filter.value === 'yesterday') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                            } else if (filter.value === 'this_week') {
                                const dayOfWeek = now.getDay();
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek + 7);
                            } else if (filter.value === 'this_month') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);
                            } else if (filter.value === 'last_month') {
                                periodStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), 1);
                            }
                            
                            if (periodStart && periodEnd) {
                                return createdDate >= periodStart && createdDate < periodEnd;
                            }
                            return false;
                        }
                        
                        // For non-special filters, use the equals operator
                        if (!isSpecialFilter && filter.operator === 'equals') {
                            return String(insightValue) === String(filter.value);
                        }
                        return false;
                    });
                });
            }

            if (filtered.length === 0) {
                // Calculate colspan: 1 for checkbox + number of columns
                const columnCount = getColumnOrder().length;
                tbody.innerHTML = `<tr><td colspan="${columnCount + 1}" class="empty-state"><h3>No insights found</h3><p>Create your first insight to get started</p></td></tr>`;
                return;
            }

            const renderedHTML = filtered.map((insight, index) => {
                const currentStatus = insight.status || 'Not Started';
                const createdDate = new Date(insight.created_at).toLocaleDateString();
                const firstOrigin = insight.origins?.[0] || {};
                const projectName = firstOrigin.project_name || null;
                const dataSource = firstOrigin.data_source || null;
                const dimensionName = firstOrigin.dimension_name || null;
                const dimensionRef = firstOrigin.dimension_ref || null;
                const categoryName = firstOrigin.category || null;
                const topicName = firstOrigin.topic_label || null;
                const insightName = toPascalCase(insight.name || '');
                const highlightedInsightName = insightsSearchTerm ? highlightSearchTerms(insightName, insightsSearchTerm) : escapeHtmlFn(insightName);
                
                // Build origin breadcrumb pills with PascalCase formatting (excluding project)
                const originPills = [];
                if (dimensionName && dimensionRef) {
                    const pascalDimension = toPascalCase(dimensionName);
                    originPills.push(`<span class="tag tag-data-source insight-origin-pill" data-origin-type="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtmlFn(dimensionName)}" data-data-source="${dataSource || ''}" onclick="event.stopPropagation(); navigateToDimensionFromInsight('${dimensionRef}', '${escapeHtmlFn(dimensionName)}', '${dataSource || ''}')" style="cursor: pointer;">${escapeHtmlFn(pascalDimension)}</span>`);
                } else if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    originPills.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtmlFn(pascalDimension)}</span>`);
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    originPills.push(`<span class="tag tag-category insight-origin-pill" data-origin-type="category" data-category="${escapeHtmlFn(categoryName)}" data-topic="${topicName ? escapeHtmlFn(topicName) : ''}" data-data-source="${dataSource || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" onclick="event.stopPropagation(); navigateToCategoryFromInsight('${escapeHtmlFn(categoryName)}', '${topicName ? escapeHtmlFn(topicName) : ''}', '${dataSource || ''}', '${dimensionRef || ''}')" style="cursor: pointer;">${escapeHtmlFn(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    originPills.push(`<span class="tag tag-topic insight-origin-pill" data-origin-type="topic" data-category="${categoryName ? escapeHtmlFn(categoryName) : ''}" data-topic="${escapeHtmlFn(topicName)}" data-data-source="${dataSource || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" onclick="event.stopPropagation(); navigateToTopicFromInsight('${escapeHtmlFn(topicName)}', '${categoryName ? escapeHtmlFn(categoryName) : ''}', '${dataSource || ''}', '${dimensionRef || ''}')" style="cursor: pointer;">${escapeHtmlFn(pascalTopic)}</span>`);
                }
                
                const originContent = originPills.length > 0 
                    ? originPills.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '-';
                
                // Build cells in default order, we'll reorder them after rendering
                const cells = {
                    name: createEditableNameCell(insight.id, insightName, highlightedInsightName),
                    type: `<td data-column="type" onclick="event.stopPropagation();">${createMultiSelectCell(insight.id, 'type', normalizeFieldToArray(insight.type, 'type'), [])}</td>`,
                    application: `<td data-column="application" onclick="event.stopPropagation();">${createMultiSelectCell(insight.id, 'application', normalizeFieldToArray(insight.application, 'application'), [])}</td>`,
                    status: `<td data-column="status">
                        <select class="status-select" 
                                onclick="event.stopPropagation()"
                                data-insight-id="${insight.id}"
                                data-current-status="${insight.status || 'Not Started'}">
                            <option value="Not Started" ${(insight.status || 'Not Started') === 'Not Started' ? 'selected' : ''}>Not Started</option>
                            <option value="Queued" ${(insight.status || 'Not Started') === 'Queued' ? 'selected' : ''}>Queued</option>
                            <option value="Design" ${(insight.status || 'Not Started') === 'Design' ? 'selected' : ''}>Design</option>
                            <option value="Development" ${(insight.status || 'Not Started') === 'Development' ? 'selected' : ''}>Development</option>
                            <option value="QA" ${(insight.status || 'Not Started') === 'QA' ? 'selected' : ''}>QA</option>
                            <option value="Testing" ${(insight.status || 'Not Started') === 'Testing' ? 'selected' : ''}>Testing</option>
                            <option value="Win" ${(insight.status || 'Not Started') === 'Win' ? 'selected' : ''}> Win</option>
                            <option value="Disproved" ${(insight.status || 'Not Started') === 'Disproved' ? 'selected' : ''}>Disproved</option>
                        </select>
                    </td>`,
                    origin: `<td data-column="origin" style="white-space: nowrap;">
                        ${originContent}
                    </td>`,
                    created_at: `<td data-column="created_at">${createdDate}</td>`
                };
                
                // Get column order
                const columnOrder = getColumnOrder();
                
                // Build row HTML in the correct order
                const orderedCells = columnOrder.map(col => cells[col] || '').filter(cell => cell);
                const checkboxCell = `<td class="checkbox-cell" onclick="event.stopPropagation(); const checkbox = this.querySelector('.insight-checkbox'); if (checkbox && !event.target.matches('.insight-checkbox')) { checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change')); }">
                    <input type="checkbox" class="insight-checkbox" data-insight-id="${insight.id}" onchange="handleInsightCheckboxChange()" onclick="event.stopPropagation()">
                </td>`;
                
                return `<tr data-insight-id="${insight.id}" onclick="openInsightNotes('${insight.id}')" style="cursor: pointer;">${checkboxCell}${orderedCells.join('')}</tr>`;
            }).join('');
            
            tbody.innerHTML = renderedHTML;
            
            // Clear checkbox selections when table is re-rendered
            selectedInsightIds.clear();
            updateInsightsDeleteButton();
            updateSelectAllCheckbox();
            
            // Apply saved column order and initialize drag and drop
            setTimeout(() => {
                if (typeof applyColumnOrder === 'function') {
                    applyColumnOrder();
                }
                if (typeof initializeColumnDragAndDrop === 'function') {
                    initializeColumnDragAndDrop();
                }
                if (typeof applyColumnWidths === 'function') {
                    applyColumnWidths();
                }
            }, 0);
        }

        function sortBy(column) {
            // Update sort indicators
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('sorted');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            });
            
            const clickedTh = event.currentTarget;
            clickedTh.classList.add('sorted');
            const indicator = clickedTh.querySelector('.sort-indicator');
            
            if (insightsCurrentSortBy === column) {
                insightsSortOrder = insightsSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                insightsCurrentSortBy = column;
                insightsSortOrder = 'asc';
            }
            
            if (indicator) {
                indicator.textContent = insightsSortOrder === 'asc' ? '' : '';
            }
            
            loadInsightsPage();
        }

        // Helper function to convert text to PascalCase - wrapper that uses format module
        function toPascalCase(text) {
            return window.formatToPascalCase(text);
        }

        // Navigation functions for origin breadcrumb pills
        function navigateToProjectFromInsight(projectName) {
            console.log('[InsightOriginNav] Navigating to project:', projectName);
            // Navigate to visualizations view
            navigateToView('visualizations');
            
            // Set the project selector
            const projectSelect = document.getElementById('projectSelect');
            if (projectSelect && projectSelect.value !== projectName) {
                projectSelect.value = projectName;
                // Trigger change event to load sources
                const changeEvent = new Event('change', { bubbles: true });
                projectSelect.dispatchEvent(changeEvent);
            } else if (projectSelect) {
                // Project already selected, just ensure we're on visualizations
                currentProjectName = projectName;
            }
        }

        async function navigateToDimensionFromInsight(dimensionRef, dimensionName, dataSource) {
            console.log('[InsightOriginNav] Navigating to dimension:', dimensionRef, dimensionName, 'dataSource:', dataSource);
            
            // Navigate to visualizations view
            navigateToView('visualizations');
            
            // Ensure we're on the correct data source before selecting dimension
            if (dataSource) {
                await ensureContextForInsightNavigation(dataSource, dimensionRef);
            } else {
                // If no data source specified, just switch dimension
                const questionSelect = document.getElementById('questionSelect');
                if (questionSelect) {
                    const previousRefKey = currentQuestionRefKey;
                    questionSelect.value = dimensionRef;
                    currentQuestionRefKey = dimensionRef;
                    
                    // Filter by this dimension
                    filterByQuestion(dimensionRef, previousRefKey);
                    
                    // Update navigation links
                    updateNavLinks();
                    
                    // Update AI Insights panel with current dimension
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(dimensionRef);
                    }
                    
                    // Re-render insights table so pinning updates for the new dimension
                    if (typeof renderInsights === 'function') {
                        renderInsights();
                    }
                }
            }
        }

        // Helper function to ensure correct data source and dimension are selected before navigation
        async function ensureContextForInsightNavigation(dataSource, dimensionRef) {
            let needsDataSourceSwitch = false;
            let needsDimensionSwitch = false;
            
            // Check if data source needs to change
            if (dataSource && dataSource !== currentDataSourceId) {
                needsDataSourceSwitch = true;
            }
            
            // Check if dimension needs to change
            if (dimensionRef && dimensionRef !== currentQuestionRefKey) {
                needsDimensionSwitch = true;
            }
            
            // Switch data source if needed
            if (needsDataSourceSwitch) {
                console.log('[InsightOriginNav] Switching data source from', currentDataSourceId, 'to', dataSource);
                currentDataSourceId = dataSource;
                currentQuestionRefKey = null; // Reset dimension when switching data source
                dimensionFilters = {}; // Clear dimension filters
                saveState();
                updateNavLinks();
                
                // Update the data source dropdown UI
                const sourceSelect = document.getElementById('sourceSelect');
                if (sourceSelect) {
                    sourceSelect.value = dataSource;
                    console.log('[InsightOriginNav] Updated source dropdown to:', dataSource);
                }
                
                // Load the new data source - this will call detectAndSetupQuestionFilter
                // which loads availableQuestions, so we need to wait for it to complete
                await loadDataSource(currentClientId, currentDataSourceId);
                
                // Wait a bit for the question filter to be set up and availableQuestions to be populated
                // We'll check multiple times with a short delay
                let attempts = 0;
                const maxAttempts = 10;
                while (attempts < maxAttempts && (!availableQuestions || availableQuestions.length === 0)) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                // After loading, check if we still need to switch dimension
                if (dimensionRef) {
                    needsDimensionSwitch = true;
                }
            }
            
            // Switch dimension if needed
            if (needsDimensionSwitch && dimensionRef) {
                console.log('[InsightOriginNav] Switching dimension from', currentQuestionRefKey, 'to', dimensionRef);
                const questionSelect = document.getElementById('questionSelect');
                if (questionSelect) {
                    // Check if the dimension is available
                    // Wait a bit more if availableQuestions is not yet populated
                    let attempts = 0;
                    const maxAttempts = 10;
                    while (attempts < maxAttempts && (!availableQuestions || availableQuestions.length === 0)) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (availableQuestions && availableQuestions.includes(dimensionRef)) {
                        const previousRefKey = currentQuestionRefKey;
                        questionSelect.value = dimensionRef;
                        currentQuestionRefKey = dimensionRef;
                        filterByQuestion(dimensionRef, previousRefKey);
                        
                        // Update AI Insights panel
                        if (window.AIInsightsPanel) {
                            window.AIInsightsPanel.setCurrentDimension(dimensionRef);
                        }
                        
                        // Re-render insights table so pinning updates for the new dimension
                        if (typeof renderInsights === 'function') {
                            renderInsights();
                        }
                    } else {
                        console.warn('[InsightOriginNav] Dimension', dimensionRef, 'not available in current data source. Available:', availableQuestions);
                    }
                }
            }
        }

        async function navigateToCategoryFromInsight(categoryName, topicName, dataSource, dimensionRef) {
            console.log('[InsightOriginNav] Navigating to category:', categoryName, topicName, dataSource, dimensionRef);
            
            // Ensure we're in the correct context (data source and dimension)
            await ensureContextForInsightNavigation(dataSource, dimensionRef);
            
            // Use slideout to show chart view
            if (window.SlideoutPanel) {
                const dimensionName = dimensionRef ? getDimensionDisplayName(dimensionRef) : null;
                window.SlideoutPanel.navigateToChart(categoryName, topicName, null, dimensionName);
            }
        }

        async function navigateToTopicFromInsight(topicName, categoryName, dataSource, dimensionRef) {
            console.log('[InsightOriginNav] Navigating to topic:', topicName, categoryName, dataSource, dimensionRef);
            
            // Ensure we're in the correct context (data source and dimension)
            await ensureContextForInsightNavigation(dataSource, dimensionRef);
            
            // Use slideout to show verbatims directly
            if (window.SlideoutPanel) {
                // Get verbatims from chart data (now that we're in the correct context)
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                }
                
                console.log('[InsightOriginNav] Found', verbatims.length, 'verbatims for topic', topicName);
                
                // Navigate to verbatims view
                window.SlideoutPanel.openVerbatims(verbatims, topicName, categoryName);
            }
        }

        function handleSearch() {
            const searchInput = document.getElementById('searchInput');
            insightsSearchTerm = searchInput?.value.trim() || '';
            updateInsightsSectionSearchClearButton();
            renderInsightsPage();
        }

        function updateInsightsSectionSearchClearButton() {
            const searchInput = document.getElementById('searchInput');
            const clearButton = document.getElementById('insightsSectionSearchClear');
            if (!searchInput || !clearButton) return;

            clearButton.style.display = searchInput.value.trim() ? 'flex' : 'none';
        }

        function clearInsightsSectionSearch() {
            const searchInput = document.getElementById('searchInput');
            if (!searchInput) return;

            searchInput.value = '';
            insightsSearchTerm = '';
            updateInsightsSectionSearchClearButton();
            renderInsightsPage();
            searchInput.focus();
        }

        function updateFilterChips() {
            const chipsContainer = document.getElementById('filterChips');
            const badge = document.getElementById('insightsListFilterBadge');
            const hasFilters = insightsFilters && insightsFilters.length > 0;
            
            // Update filter badge
            if (badge) {
                if (hasFilters) {
                    badge.style.display = 'flex';
                    badge.textContent = insightsFilters.length;
                } else {
                    badge.style.display = 'none';
                }
            }
            
            // Don't render filter chips - filters are shown as checkboxes in the dropdown
            if (chipsContainer) {
                chipsContainer.innerHTML = '';
            }
        }

        function removeFilter(key) {
            // Legacy support - remove by field key
            insightsFilters = insightsFilters.filter(f => f.field !== key);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }

        function resetFilters() {
            insightsFilters = [];
            insightsSearchTerm = '';
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            updateInsightsSectionSearchClearButton();
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }

        // Load filters from localStorage (scoped by client ID)
        function loadFiltersFromStorage() {
            const clientId = insightsCurrentClientId || currentClientId || 'global';
            insightsFilters = window.storageLoadFiltersFromStorage(clientId);
        }
        
        // Save filters to localStorage (scoped by client ID)
        function saveFiltersToStorage() {
            const clientId = insightsCurrentClientId || currentClientId || 'global';
            window.storageSaveFiltersToStorage(clientId, insightsFilters);
        }
        
        // Restore visible filter dropdowns for active filters
        function restoreFilterDropdowns() {
            if (!insightsFilters || insightsFilters.length === 0) {
                return;
            }
            
            // Get unique field IDs from active filters
            const activeFieldIds = new Set(insightsFilters.map(f => f.field));
            
            // Create dropdown UI for each active filter field
            activeFieldIds.forEach(fieldId => {
                // Check if dropdown already exists
                const existingDropdown = document.getElementById(`inline-filter-${fieldId}`);
                if (!existingDropdown) {
                    // Create the dropdown UI - but start with it closed
                    const field = FILTER_FIELDS.find(f => f.id === fieldId);
                    if (!field) return;
                    
                    // Get unique values for this field from insights
                    const values = field.type === 'select' ? getUniqueFilterFieldValues(fieldId) : [];
                    
                    // Create inline filter dropdown
                    const filterChipsContainer = document.getElementById('filterChips');
                    if (!filterChipsContainer) return;
                    
                    const inlineFilter = document.createElement('div');
                    inlineFilter.className = 'inline-filter-dropdown';
                    inlineFilter.id = `inline-filter-${fieldId}`;
                    
                    let optionsHTML = '';
                    if (field.type === 'select') {
                        const escapeHtmlFn = window.escapeHtml;
                        optionsHTML = values.map(value => {
                            const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                            const escapedValue = escapeHtmlFn(value);
                            return `
                                <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                                     data-filter-value="${escapedValue}"
                                     onclick="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                                    <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} 
                                           data-filter-value="${escapedValue}"
                                           onclick="event.stopPropagation()" 
                                           onchange="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                                    <span>${escapedValue || '(empty)'}</span>
                                </div>
                            `;
                        }).join('');
                    } else if (field.type === 'date') {
                        const dateOptions = [
                            { value: 'today', label: 'Today' },
                            { value: 'yesterday', label: 'Yesterday' },
                            { value: 'this_week', label: 'This week' },
                            { value: 'this_month', label: 'This month' },
                            { value: 'last_month', label: 'Last month' }
                        ];
                        optionsHTML = dateOptions.map(opt => {
                            const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === opt.value);
                            return `
                                <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                                     onclick="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                                    <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation()" onchange="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                                    <span>${opt.label}</span>
                                </div>
                            `;
                        }).join('');
                    }
                    
                    // Create dropdown with closed state initially
                    inlineFilter.innerHTML = `
                        <div class="inline-filter-header" onclick="toggleInlineFilterDropdown('${fieldId}', event)">
                            <span class="inline-filter-icon">${field.icon}</span>
                            <span class="inline-filter-label">${field.label}</span>
                            <span class="inline-filter-chevron"></span>
                        </div>
                        <div class="inline-filter-options" style="display: none;">
                            ${optionsHTML}
                        </div>
                        <div class="inline-filter-remove" onclick="event.stopPropagation(); removeInlineFilter('${fieldId}')" title="Remove filter"></div>
                    `;
                    
                    // Insert before the filter button container
                    const filterButtonContainer = filterChipsContainer.nextElementSibling;
                    if (filterButtonContainer && filterButtonContainer.parentNode) {
                        filterButtonContainer.parentNode.insertBefore(inlineFilter, filterButtonContainer);
                    } else {
                        filterChipsContainer.parentNode.appendChild(inlineFilter);
                    }
                    
                    // Update header to show selected filter values
                    updateInlineFilterHeader(fieldId);
                } else {
                    // Update existing dropdown checkboxes to reflect current filter state
                    updateInlineFilterOptions(fieldId);
                }
            });
        }
        
        // Toggle filter menu
        function toggleFilterMenu(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            // Find the dropdown in the insights section (not the insights panel)
            const insightsSection = document.getElementById('insights-section');
            const dropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
            if (dropdown) {
                const wasActive = dropdown.classList.contains('active');
                // Close all other dropdowns first
                document.querySelectorAll('.filter-dropdown.active').forEach(d => {
                    if (d !== dropdown) {
                        d.classList.remove('active');
                        d.style.display = 'none';
                    }
                });
                
                // Toggle this dropdown
                if (wasActive) {
                    dropdown.classList.remove('active');
                    dropdown.style.display = 'none';
                } else {
                    dropdown.classList.add('active');
                    dropdown.style.display = 'block';
                    populateFilterOptions();
                    updateActiveFiltersDisplay();
                    // Focus search input
                    setTimeout(() => {
                        const searchInput = document.getElementById('filterSearchInput');
                        if (searchInput) searchInput.focus();
                    }, 100);
                }
            } else {
            }
        }
        
        // Populate filter options list
        function populateFilterOptions() {
            const list = document.getElementById('filterOptionsList');
            if (!list) return;
            
            list.innerHTML = FILTER_FIELDS.map(field => {
                return `
                    <div class="filter-option" onclick="event.stopPropagation(); event.preventDefault(); openFilterValueDialog('${field.id}')">
                        <div class="filter-option-icon">${field.icon}</div>
                        <div class="filter-option-text">${field.label}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Filter filter options based on search
        function filterFilterOptions() {
            const searchInput = document.getElementById('filterSearchInput');
            const list = document.getElementById('filterOptionsList');
            if (!searchInput || !list) return;
            
            const searchTerm = searchInput.value.toLowerCase();
            const options = list.querySelectorAll('.filter-option');
            
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchTerm) ? 'flex' : 'none';
            });
        }
        
        // Open filter value dialog - now creates inline dropdown
        function openFilterValueDialog(fieldId) {
            const field = FILTER_FIELDS.find(f => f.id === fieldId);
            if (!field) {
                return;
            }
            
            // Close the main filter menu first
            const insightsSection = document.getElementById('insights-section');
            const mainDropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
            if (mainDropdown) {
                mainDropdown.classList.remove('active');
                mainDropdown.style.display = 'none';
            }
            
            // Check if this filter dropdown already exists
            const existingDropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (existingDropdown) {
                // Toggle it if it already exists
                const header = existingDropdown.querySelector('.inline-filter-header');
                const options = existingDropdown.querySelector('.inline-filter-options');
                if (header && options) {
                    header.classList.toggle('open');
                    options.classList.toggle('open');
                    // Update checkbox states to reflect current filter state (in case filters were loaded from storage)
                    updateInlineFilterOptions(fieldId);
                }
                return;
            }
            
            // Get unique values for this field from insights
            const values = field.type === 'select' ? getUniqueFieldValues(fieldId) : [];
            
            // Create inline filter dropdown
            const filterChipsContainer = document.getElementById('filterChips');
            if (!filterChipsContainer) {
                return;
            }
            
            const inlineFilter = document.createElement('div');
            inlineFilter.className = 'inline-filter-dropdown';
            inlineFilter.id = `inline-filter-${fieldId}`;
            inlineFilter.setAttribute('data-just-created', 'true'); // Flag to prevent immediate closing
            
            let optionsHTML = '';
            if (field.type === 'select') {
                const escapeHtmlFn = window.escapeHtml;
                optionsHTML = values.map(value => {
                    const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                    const escapedValue = escapeHtmlFn(value);
                    return `
                        <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                             data-filter-value="${escapedValue}"
                             onclick="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                            <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} 
                                   data-filter-value="${escapedValue}"
                                   onclick="event.stopPropagation()" 
                                   onchange="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                            <span>${escapedValue || '(empty)'}</span>
                        </div>
                    `;
                }).join('');
            } else if (field.type === 'date') {
                const dateOptions = [
                    { value: 'today', label: 'Today' },
                    { value: 'yesterday', label: 'Yesterday' },
                    { value: 'this_week', label: 'This week' },
                    { value: 'this_month', label: 'This month' },
                    { value: 'last_month', label: 'Last month' }
                ];
                optionsHTML = dateOptions.map(opt => {
                    const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === opt.value);
                    return `
                        <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                             onclick="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                            <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation()" onchange="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                            <span>${opt.label}</span>
                        </div>
                    `;
                }).join('');
            }
            
            inlineFilter.innerHTML = `
                <div class="inline-filter-header open" onclick="toggleInlineFilterDropdown('${fieldId}', event)">
                    <span class="inline-filter-icon">${field.icon}</span>
                    <span class="inline-filter-label">${field.label}</span>
                    <span class="inline-filter-chevron"></span>
                </div>
                <div class="inline-filter-options open">
                    ${optionsHTML}
                </div>
                <div class="inline-filter-remove" onclick="event.stopPropagation(); removeInlineFilter('${fieldId}')" title="Remove filter"></div>
            `;
            
            // Update header to show selected filter values after creating dropdown
            setTimeout(() => {
                updateInlineFilterHeader(fieldId);
            }, 0);
            
            // Insert before the filter button container
            const filterButtonContainer = filterChipsContainer.nextElementSibling;
            if (filterButtonContainer) {
                filterChipsContainer.parentNode.insertBefore(inlineFilter, filterButtonContainer);
            } else {
                filterChipsContainer.parentNode.appendChild(inlineFilter);
            }
            
            // Ensure the dropdown is open after insertion
            // Use a longer delay to ensure click events have processed
            setTimeout(() => {
                const header = inlineFilter.querySelector('.inline-filter-header');
                const options = inlineFilter.querySelector('.inline-filter-options');
                
                if (header && options) {
                    // Force the classes to be set
                    header.classList.add('open');
                    options.classList.add('open');
                    // Also set style directly as backup
                    options.style.display = 'block';
                } else {
                }
            }, 50);
        }
        
        // Toggle inline filter dropdown
        function toggleInlineFilterDropdown(fieldId, e) {
            if (e) {
                e.stopPropagation();
            }
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (!dropdown) return;
            
            const header = dropdown.querySelector('.inline-filter-header');
            const options = dropdown.querySelector('.inline-filter-options');
            
            if (header && options) {
                const isOpen = options.classList.contains('open');
                
                if (isOpen) {
                    header.classList.remove('open');
                    options.classList.remove('open');
                    options.style.display = 'none';
                } else {
                    header.classList.add('open');
                    options.classList.add('open');
                    options.style.display = 'block';
                }
            }
        }
        
        // Toggle inline filter value
        function toggleInlineFilterValue(fieldId, value) {
            const existingIndex = insightsFilters.findIndex(f => f.field === fieldId && f.value === value);
            
            if (existingIndex >= 0) {
                // Remove filter
                insightsFilters.splice(existingIndex, 1);
            } else {
                // Add filter
                insightsFilters.push({ field: fieldId, operator: 'equals', value: value });
            }
            
            // Update the inline dropdown options to reflect current filter state
            updateInlineFilterOptions(fieldId);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Update inline filter header label to show selected filter values
        function updateInlineFilterHeader(fieldId) {
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (!dropdown) {
                return;
            }
            
            const header = dropdown.querySelector('.inline-filter-header');
            const labelElement = header ? header.querySelector('.inline-filter-label') : null;
            if (!labelElement) {
                return;
            }
            
            // Get all active filters for this field
            const activeFilters = insightsFilters.filter(f => f.field === fieldId);
            
            if (activeFilters.length === 0) {
                // No filters active, show default label
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                labelElement.textContent = field ? field.label : fieldId;
            } else if (activeFilters.length === 1) {
                // Single filter, show the value (or label for date filters)
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                let displayValue = activeFilters[0].value;
                
                // Special case: status filter with "Win" should display as " Wins"
                if (fieldId === 'status' && displayValue === 'Win') {
                    displayValue = ' Wins';
                }
                // For date filters, convert value to label
                else if (field && field.type === 'date') {
                    const dateOptions = [
                        { value: 'today', label: 'Today' },
                        { value: 'yesterday', label: 'Yesterday' },
                        { value: 'this_week', label: 'This week' },
                        { value: 'this_month', label: 'This month' },
                        { value: 'last_month', label: 'Last month' }
                    ];
                    const dateOption = dateOptions.find(opt => opt.value === displayValue);
                    if (dateOption) {
                        displayValue = dateOption.label;
                    }
                }
                
                labelElement.textContent = displayValue;
            } else {
                // Multiple filters, show first value + count
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                let firstValue = activeFilters[0].value;
                
                // Special case: status filter with "Win" should display as " Wins"
                if (fieldId === 'status' && firstValue === 'Win') {
                    firstValue = ' Wins';
                }
                // For date filters, convert value to label
                else if (field && field.type === 'date') {
                    const dateOptions = [
                        { value: 'today', label: 'Today' },
                        { value: 'yesterday', label: 'Yesterday' },
                        { value: 'this_week', label: 'This week' },
                        { value: 'this_month', label: 'This month' },
                        { value: 'last_month', label: 'Last month' }
                    ];
                    const dateOption = dateOptions.find(opt => opt.value === firstValue);
                    if (dateOption) {
                        firstValue = dateOption.label;
                    }
                }
                
                labelElement.textContent = `${firstValue} + ${activeFilters.length - 1} more`;
            }
        }
        
        // Update inline filter options display to sync checkbox states with filter state
        function updateInlineFilterOptions(fieldId) {
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (!dropdown) {
                return;
            }
            
            const options = dropdown.querySelectorAll('.inline-filter-option');
            
            options.forEach((option) => {
                const checkbox = option.querySelector('.inline-filter-checkbox');
                if (!checkbox) {
                    return;
                }
                
                // Get the filter value from data attribute (most reliable)
                let value = checkbox.getAttribute('data-filter-value') || option.getAttribute('data-filter-value');
                
                // Fallback: extract from function call in onchange attribute if data attribute not found
                if (!value) {
                    const onchangeAttr = checkbox.getAttribute('onchange');
                    const valueMatch = onchangeAttr ? onchangeAttr.match(/toggleInlineFilterValue\(['"]([^'"]+)['"],\s*['"]([^'"]+)['"]\)/) : null;
                    if (valueMatch && valueMatch[2]) {
                        value = valueMatch[2];
                    } else {
                        // Last resort: try onclick on parent
                        const onclickAttr = option.getAttribute('onclick');
                        const onclickMatch = onclickAttr ? onclickAttr.match(/toggleInlineFilterValue\(['"]([^'"]+)['"],\s*['"]([^'"]+)['"]\)/) : null;
                        if (onclickMatch && onclickMatch[2]) {
                            value = onclickMatch[2];
                        } else {
                            return; // Cannot determine value, skip this option
                        }
                    }
                }
                
                // Check if this value is currently in the filters
                const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                
                // Update checkbox state
                checkbox.checked = isSelected;
                
                // Update option selected class for styling
                if (isSelected) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
            
            // Update header label to show selected values
            updateInlineFilterHeader(fieldId);
        }
        
        // Remove inline filter
        function removeInlineFilter(fieldId) {
            // Remove all filters for this field
            insightsFilters = insightsFilters.filter(f => f.field !== fieldId);
            
            // Remove the dropdown element
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (dropdown) {
                dropdown.remove();
            }
            
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Get unique values for a filter field (handles special field mappings)
        function getUniqueFilterFieldValues(fieldId) {
            const values = new Set();
            
            insightsAllInsights.forEach(insight => {
                let value = null;
                
                if (fieldId === 'status') {
                    value = insight.status || 'Not Started';
                } else if (fieldId === 'type') {
                    value = insight.type;
                } else if (fieldId === 'application') {
                    // Application is an array, so we need to extract all unique values
                    if (insight.application && Array.isArray(insight.application) && insight.application.length > 0) {
                        insight.application.forEach(app => {
                            if (app && app.trim()) {
                                values.add(app.trim());
                            }
                        });
                    }
                    // Skip the rest of the logic for application since we've already added values
                    return;
                } else if (fieldId === 'project' || fieldId === 'data_source' || fieldId === 'dimension') {
                    const firstOrigin = insight.origins?.[0] || {};
                    if (fieldId === 'project') {
                        value = firstOrigin.project_name;
                    } else if (fieldId === 'data_source') {
                        value = firstOrigin.data_source;
                    } else if (fieldId === 'dimension') {
                        value = firstOrigin.dimension_name || firstOrigin.dimension_ref;
                    }
                }
                
                if (value && value !== '-') {
                    values.add(value);
                }
            });
            
            return Array.from(values).sort();
        }
        
        // Toggle filter value
        function toggleFilterValue(fieldId, value) {
            const existingIndex = insightsFilters.findIndex(f => f.field === fieldId && f.value === value);
            
            if (existingIndex >= 0) {
                // Remove filter
                insightsFilters.splice(existingIndex, 1);
            } else {
                // Add filter
                insightsFilters.push({ field: fieldId, operator: 'equals', value: value });
            }
            
            // Update dialog
            openFilterValueDialog(fieldId);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Add date filter
        function addDateFilter(fieldId, period) {
            // Remove existing date filters for this field
            insightsFilters = insightsFilters.filter(f => f.field !== fieldId);
            
            // Add new filter
            insightsFilters.push({ field: fieldId, operator: 'equals', value: period });
            
            // Update the inline dropdown if it exists
            updateInlineFilterOptions(fieldId);
            
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Close filter value dialog
        function closeFilterValueDialog() {
            const dialog = document.getElementById('filterValueDialog');
            const overlay = document.getElementById('filterDialogOverlay');
            if (dialog) dialog.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }
        
        // Update active filters display in dropdown
        function updateActiveFiltersDisplay() {
            const section = document.getElementById('activeFiltersSection');
            const list = document.getElementById('activeFiltersList');
            
            if (!section || !list) return;
            
            if (insightsFilters.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            const escapeHtmlFn = window.escapeHtml;
            list.innerHTML = insightsFilters.map((filter, index) => {
                const field = FILTER_FIELDS.find(f => f.id === filter.field);
                const label = field ? field.label : filter.field;
                return `
                    <div class="filter-active-item">
                        <span>${label}: ${escapeHtmlFn(String(filter.value))}</span>
                        <span class="filter-active-item-remove" onclick="removeFilterByIndex(${index})"></span>
                    </div>
                `;
            }).join('');
        }
        
        // Remove filter by index
        function removeFilterByIndex(index) {
            insightsFilters.splice(index, 1);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Legacy function name for compatibility
        function openFilterMenu() {
            toggleFilterMenu();
        }

        function openCreateModal() {
            console.log('[openCreateModal] Function called');
            console.log('[openCreateModal] Current file:', window.location.pathname);
            console.log('[openCreateModal] SlideoutPanel available:', typeof SlideoutPanel !== 'undefined');
            
            insightsCurrentInsightId = null;
            
            // Check if we should use slideout panel
            if (typeof SlideoutPanel !== 'undefined' && SlideoutPanel.openCreateInsight) {
                console.log('[openCreateModal] Using slideout panel method');
                
                const urlParams = new URLSearchParams(window.location.search);
                const contextData = {
                    dimension_ref: urlParams.get('dimension_ref') || null,
                    project_name: urlParams.get('project_name') || null,
                    data_source: urlParams.get('data_source') || null,
                    dimension_name: urlParams.get('dimension_name') || null,
                };
                
                console.log('[openCreateModal] Context data:', contextData);
                console.log('[openCreateModal] Calling SlideoutPanel.openCreateInsight');
                
                SlideoutPanel.openCreateInsight(contextData);
                return;
            }
            
            // Fallback to modal (for debugging)
            console.warn('[openCreateModal] SlideoutPanel not available, falling back to modal');
            const modal = document.getElementById('insightModal');
            const modalTitle = document.getElementById('modalTitle');
            const form = document.getElementById('insightForm');
            
            console.log('[openCreateModal] Modal elements:', { 
                modal: !!modal, 
                modalTitle: !!modalTitle, 
                form: !!form 
            });
            
            if (!modal || !modalTitle || !form) {
                console.error('[openCreateModal] Modal elements not found:', { modal, modalTitle, form });
                return;
            }
            
            modalTitle.textContent = 'Create Insight';
            form.reset();
            
            const urlParams = new URLSearchParams(window.location.search);
            window.insightOriginContext = {
                dimension_ref: urlParams.get('dimension_ref') || null,
                project_name: urlParams.get('project_name') || null,
                data_source: urlParams.get('data_source') || null,
                dimension_name: urlParams.get('dimension_name') || null,
            };
            
            console.log('[openCreateModal] Opening modal');
            modal.classList.add('active');
        }

        function closeModal() {
            const modal = document.getElementById('insightModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        async function saveInsight(event) {
            event.preventDefault();
            if (!insightsCurrentClientId) return;

            let token = null;
            if (typeof getAuthToken !== 'undefined') {
                token = getAuthToken();
            }
            if (!token) {
                token = localStorage.getItem('visualizd_auth_token');
            }
            if (!token && window.opener) {
                try {
                    token = window.opener.localStorage.getItem('visualizd_auth_token');
                    if (token) localStorage.setItem('visualizd_auth_token', token);
                } catch (e) {}
            }
            
            if (!token) {
                alert('You are not logged in. Please log in and try again.');
                return;
            }

            const originContext = window.insightOriginContext || {};
            const toNull = (val) => (val && val.trim()) ? val.trim() : null;
            
            const insightData = {
                name: document.getElementById('insightName').value.trim(),
                type: null,  // Type not available when creating from visualizations view
                application: null,  // Application not available when creating from visualizations view
                description: toNull(document.getElementById('insightDescription').value),
                origins: [{
                    origin_type: originContext.category ? 'category' : (originContext.topic_label ? 'topic' : 'category'),
                    project_name: toNull(originContext.project_name),
                    data_source: toNull(originContext.data_source),
                    dimension_ref: toNull(originContext.dimension_ref),
                    dimension_name: toNull(originContext.dimension_name),
                    category: toNull(originContext.category),
                    topic_label: toNull(originContext.topic_label),
                    process_voc_id: originContext.process_voc_id || null,
                }],
            };

            try {
                // Get auth headers
                const getAuthHeadersFn = () => {
                    const headers = {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    };
                    return headers;
                };
                
                // Save insight using API module
                if (insightsCurrentInsightId) {
                    await window.insightsApiUpdateInsight(insightsCurrentClientId, insightsCurrentInsightId, insightData, getAuthHeadersFn);
                } else {
                    await window.insightsApiCreateInsight(insightsCurrentClientId, insightData, getAuthHeadersFn);
                }
                
                closeModal();
                loadInsightsPage();
            } catch (error) {
                console.error('Error saving insight:', error);
                alert('Error saving insight: ' + error.message);
            }
        }

        async function editInsight(insightId) {
            console.log('[editInsight] Function called with insightId:', insightId);
            console.log('[editInsight] insightsCurrentClientId:', insightsCurrentClientId);
            
            if (!insightsCurrentClientId) {
                console.error('[editInsight] No client selected');
                return;
            }

            // Use the same function as opening insight notes (slideout panel)
            console.log('[editInsight] Calling openInsightNotes');
            openInsightNotes(insightId);
        }

        async function deleteInsight(insightId) {
            if (!insightsCurrentClientId) return;
            if (!confirm('Are you sure you want to delete this insight?')) return;

            try {
                // Delete insight using API module
                await window.insightsApiDeleteInsight(insightsCurrentClientId, insightId, getAuthHeadersSafe);
                loadInsightsPage();
            } catch (error) {
                console.error('Error deleting insight:', error);
                alert('Error deleting insight: ' + error.message);
            }
        }

        function handleInsightCheckboxChange() {
            selectedInsightIds.clear();
            const checkboxes = document.querySelectorAll('.insight-checkbox:checked');
            checkboxes.forEach(checkbox => {
                const insightId = checkbox.getAttribute('data-insight-id');
                if (insightId) {
                    selectedInsightIds.add(insightId);
                }
            });
            updateInsightsDeleteButton();
            updateSelectAllCheckbox();
        }

        function toggleSelectAllInsights(checked) {
            const checkboxes = document.querySelectorAll('.insight-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
                const insightId = checkbox.getAttribute('data-insight-id');
                if (checked && insightId) {
                    selectedInsightIds.add(insightId);
                } else if (insightId) {
                    selectedInsightIds.delete(insightId);
                }
            });
            updateInsightsDeleteButton();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('insightsSelectAll');
            if (!selectAllCheckbox) return;
            
            const checkboxes = document.querySelectorAll('.insight-checkbox');
            const checkedCount = document.querySelectorAll('.insight-checkbox:checked').length;
            selectAllCheckbox.checked = checkboxes.length > 0 && checkedCount === checkboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < checkboxes.length;
        }

        function updateInsightsDeleteButton() {
            // Try both button locations - insights section (main) and insights panel (in visualizations)
            const deleteBtn = document.getElementById('insightsSectionDeleteBtn') || document.getElementById('insightsDeleteBtn');
            if (!deleteBtn) return;
            
            const shouldShow = selectedInsightIds.size > 0;
            
            if (shouldShow) {
                // Remove the inline style attribute to clear the initial display:none
                deleteBtn.removeAttribute('style');
                deleteBtn.style.display = 'block';
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        async function deleteSelectedInsights() {
            if (!insightsCurrentClientId) return;
            if (selectedInsightIds.size === 0) return;

            const count = selectedInsightIds.size;
            const message = count === 1 
                ? 'Are you sure you want to delete this insight?'
                : `Are you sure you want to delete ${count} insights?`;
            
            if (!confirm(message)) return;

            try {
                const deletePromises = Array.from(selectedInsightIds).map(insightId =>
                    fetch(`${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`, {
                        method: 'DELETE',
                        headers: getAuthHeadersSafe()
                    }).then(response => {
                        if (!response.ok) throw new Error(`Failed to delete insight ${insightId}`);
                        return insightId;
                    })
                );

                await Promise.all(deletePromises);
                selectedInsightIds.clear();
                loadInsightsPage();
            } catch (error) {
                console.error('Error deleting insights:', error);
                alert('Error deleting insights: ' + error.message);
                // Reload page to sync state even if some deletes failed
                loadInsightsPage();
            }
        }

        async function updateInsightStatus(insightId, status) {
            
            if (!insightsCurrentClientId) {
                alert('Error: No client selected. Please refresh the page.');
                return;
            }
            
            if (!insightId) {
                alert('Error: No insight ID provided.');
                return;
            }
            
            if (!status) {
                alert('Error: No status value provided.');
                return;
            }
            
            
            try {
                const headers = getAuthHeadersSafe();
                
                const token = headers?.Authorization || headers?.authorization || localStorage.getItem('visualizd_auth_token');
                
                if (!token) {
                    throw new Error('Not authenticated');
                }
                
                const requestBody = { status: status };
                
                const requestHeaders = {
                    'Authorization': token.startsWith('Bearer') ? token : `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
                
                const url = `${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`;
                
                const fetchStartTime = Date.now();
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody)
                });
                const fetchDuration = Date.now() - fetchStartTime;
                
                
                if (!response.ok) {
                    const errorText = await response.text();
                    try {
                        const errorJson = JSON.parse(errorText);
                        throw new Error(errorJson.detail || `Failed to update status: ${response.status} ${response.statusText}`);
                    } catch (parseError) {
                        throw new Error(`Failed to update status: ${response.status} ${response.statusText}. ${errorText}`);
                    }
                }
                
                const responseData = await response.json();
                
                // Update local data without reloading
                const insightIndex = insightsAllInsights.findIndex(insight => insight.id === insightId);
                if (insightIndex !== -1) {
                    insightsAllInsights[insightIndex].status = status;
                }
                
                // Update the select element's data attribute and selected option
                const selectElement = document.querySelector(`select.status-select[data-insight-id="${insightId}"]`);
                if (selectElement) {
                    selectElement.setAttribute('data-current-status', status);
                    selectElement.value = status;
                }
            } catch (error) {
                alert('Error updating status: ' + error.message);
            }
        }

        // Generic function to update insight field
        async function updateInsightField(insightId, fieldName, value) {
            if (!insightsCurrentClientId || !insightId) {
                alert('Error: Invalid insight or client ID');
                return false;
            }

            try {
                const headers = getAuthHeadersSafe();
                const token = headers?.Authorization || headers?.authorization || localStorage.getItem('visualizd_auth_token');
                
                if (!token) {
                    throw new Error('Not authenticated');
                }

                const requestBody = { [fieldName]: value };
                const url = `${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`;
                
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': token.startsWith('Bearer') ? token : `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to update ${fieldName}: ${response.status} ${response.statusText}`);
                }

                const responseData = await response.json();
                
                // Update local data - normalize field value to array for both type and application
                const insightIndex = insightsAllInsights.findIndex(insight => insight.id === insightId);
                if (insightIndex !== -1) {
                    // Normalize the response value to array (backend returns string for type, array for application)
                    // Both need to be normalized to handle comma-separated strings correctly
                    const normalizedValue = normalizeFieldToArray(responseData[fieldName], fieldName);
                    insightsAllInsights[insightIndex][fieldName] = normalizedValue;
                }
                
                return true;
            } catch (error) {
                console.error(`Error updating ${fieldName}:`, error);
                alert(`Error updating ${fieldName}: ` + error.message);
                return false;
            }
        }

        // Helper function to normalize field value to array (for both type and application)
        function normalizeFieldToArray(fieldValue, fieldName) {
            if (!fieldValue) return [];
            if (Array.isArray(fieldValue)) return fieldValue;
            if (typeof fieldValue === 'string') {
                // For both type and application fields, split comma-separated strings
                // Backend stores type as a single string, but we send comma-separated values
                // So we need to split them when receiving from backend
                const values = fieldValue.split(',').map(v => v.trim()).filter(v => v);
                return values.length > 0 ? values : [];
            }
            return [];
        }

        // Collect all unique values for a field from all insights
        function getUniqueFieldValues(fieldName) {
            const values = new Set();
            insightsAllInsights.forEach(insight => {
                const fieldValue = insight[fieldName];
                if (fieldValue) {
                    if (Array.isArray(fieldValue)) {
                        fieldValue.forEach(v => v && values.add(v.trim()));
                    } else if (typeof fieldValue === 'string') {
                        // For both type and application, split comma-separated strings to get individual values
                        const splitValues = fieldValue.split(',').map(v => v.trim()).filter(v => v);
                        splitValues.forEach(v => values.add(v));
                    }
                }
            });
            return Array.from(values).sort();
        }

        // Create multi-select dropdown with pills
        function createMultiSelectCell(insightId, fieldName, currentValues, availableOptions) {
            const escapeHtmlFn = window.escapeHtml;
            const cellId = `multiselect-${fieldName}-${insightId}`;
            const selected = currentValues || [];
            
            // Generate pills for selected values with colors
            const pills = selected.map(value => {
                const style = getPillStyle(fieldName, value);
                // Escape single quotes and backslashes for JavaScript string in onclick handler
                const valueEscapedJs = String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                return `<span class="insight-pill" data-value="${escapeHtmlFn(value)}" style="${style}" onclick="if(!event.target.classList.contains('pill-remove')){event.stopPropagation(); openMultiSelect('${insightId}', '${fieldName}')}">
                    ${escapeHtmlFn(value)}
                    <button class="pill-remove" onclick="event.stopPropagation(); event.preventDefault(); removeMultiSelectValue('${insightId}', '${fieldName}', '${valueEscapedJs}')"></button>
                </span>`;
            }).join('');

            return `<div class="insight-multiselect-cell" id="${cellId}" data-insight-id="${insightId}" data-field="${fieldName}" onclick="event.stopPropagation(); openMultiSelect('${insightId}', '${fieldName}')">
                <div class="insight-pills-container">
                    ${pills || '<span class="empty-value">-</span>'}
                </div>
            </div>`;
        }

        // Open multi-select dropdown
        function openMultiSelect(insightId, fieldName) {
            // Close any existing dropdown
            closeMultiSelect();

            const cell = document.getElementById(`multiselect-${fieldName}-${insightId}`);
            if (!cell) return;

            const insight = insightsAllInsights.find(i => i.id === insightId);
            if (!insight) return;

            const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
            const availableOptions = getUniqueFieldValues(fieldName);
            
            // Add active class to show delete buttons
            cell.classList.add('dropdown-active');
            
            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'insight-multiselect-dropdown';
            dropdown.id = 'active-multiselect-dropdown';
            dropdown.onclick = (e) => e.stopPropagation();
            
            // Store context for later use
            dropdown.dataset.insightId = insightId;
            dropdown.dataset.fieldName = fieldName;
            
            // Search input
            dropdown.innerHTML = `
                <div class="multiselect-search-container">
                    <input type="text" 
                           class="multiselect-search" 
                           placeholder="Search or create new option..."
                           oninput="filterMultiSelectOptions()"
                           onkeydown="handleMultiSelectKeydown(event, '${insightId}', '${fieldName}')">
                </div>
                <div class="multiselect-options" id="multiselect-options-list"></div>
            `;
            
            // Initially append to cell for measurement
            cell.appendChild(dropdown);
            
            // Populate options
            renderMultiSelectOptions(availableOptions, currentValues, insightId, fieldName);
            
            // Move dropdown to body with fixed positioning to escape overflow constraints
            setTimeout(() => {
                const cellRect = cell.getBoundingClientRect();
                const dropdownRect = dropdown.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const spaceBelow = viewportHeight - cellRect.bottom;
                const spaceAbove = cellRect.top;
                const dropdownHeight = dropdownRect.height || 300; // fallback to max-height
                
                // Remove from cell and append to body
                dropdown.remove();
                document.body.appendChild(dropdown);
                
                // Switch to fixed positioning
                dropdown.style.position = 'fixed';
                dropdown.style.left = cellRect.left + 'px';
                dropdown.style.right = 'auto';
                // Use sensible fixed width instead of cell width
                dropdown.style.width = '320px';
                dropdown.style.minWidth = '280px';
                dropdown.style.maxWidth = '400px';
                
                // Position above or below based on available space
                if (spaceBelow < dropdownHeight && spaceAbove > dropdownHeight) {
                    dropdown.style.top = (cellRect.top - dropdownHeight - 4) + 'px';
                    dropdown.style.bottom = 'auto';
                } else {
                    dropdown.style.top = (cellRect.bottom + 4) + 'px';
                    dropdown.style.bottom = 'auto';
                }
            }, 0);
            
            // Focus search
            const searchInput = dropdown.querySelector('.multiselect-search');
            if (searchInput) {
                setTimeout(() => searchInput.focus(), 10);
            }
            
            // Click outside to close
            setTimeout(() => {
                document.addEventListener('click', closeMultiSelectOnClickOutside, true);
            }, 10);
        }

        function renderMultiSelectOptions(availableOptions, currentValues, insightId, fieldName) {
            console.log('[MULTISELECT_RENDER] renderMultiSelectOptions called');
            console.log('[MULTISELECT_RENDER] availableOptions:', availableOptions?.length, 'currentValues:', currentValues);
            
            const escapeHtmlFn = window.escapeHtml;
            const optionsList = document.getElementById('multiselect-options-list');
            if (!optionsList) {
                console.warn('[MULTISELECT_RENDER] Options list element not found');
                return;
            }

            const searchInput = document.querySelector('.multiselect-search');
            const searchTerm = searchInput?.value.toLowerCase().trim() || '';
            
            console.log('[MULTISELECT_RENDER] Search term:', JSON.stringify(searchTerm));
            
            // Filter options based on search
            const filteredOptions = availableOptions.filter(opt => 
                opt.toLowerCase().includes(searchTerm)
            );
            
            console.log('[MULTISELECT_RENDER] Filtered options count:', filteredOptions.length, 'from', availableOptions?.length);

            let html = '';
            
            // Show existing options
            filteredOptions.forEach(option => {
                const isSelected = currentValues.includes(option);
                // Escape single quotes and backslashes for JavaScript string in onchange handler
                const optionEscapedJs = String(option).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                html += `<div class="multiselect-option ${isSelected ? 'selected' : ''}" 
                              onclick="if(!event.target.closest('.multiselect-option-meatball, .multiselect-option-meatball-menu')) toggleMultiSelectOption('${insightId}', '${fieldName}', '${optionEscapedJs}')"
                              style="position: relative;">
                            <input type="checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation();" onchange="toggleMultiSelectOption('${insightId}', '${fieldName}', '${optionEscapedJs}')">
                            <span class="option-label">${escapeHtmlFn(option)}</span>
                            <button class="multiselect-option-meatball" onclick="event.stopPropagation(); toggleTagMeatballMenu(event, '${optionEscapedJs}', '${fieldName}')" title="Tag options">
                                
                            </button>
                            <div class="multiselect-option-meatball-menu" id="meatball-menu-${fieldName}-${escapeHtmlFn(option).replace(/[^a-zA-Z0-9]/g, '_')}">
                                <div class="tag-edit-input-container">
                                    <input type="text" class="tag-edit-input" value="${escapeHtmlFn(option)}" 
                                           data-original-value="${escapeHtmlFn(option)}"
                                           oninput="previewTagRename(event, '${optionEscapedJs}', '${fieldName}')"
                                           onkeydown="handleTagRenameKeydown(event, '${optionEscapedJs}', '${fieldName}')"
                                           onblur="saveTagRename(event, '${optionEscapedJs}', '${fieldName}')">
                                    <div class="tag-info-icon" title="Tag name">i</div>
                                </div>
                                <div class="meatball-menu-divider"></div>
                                <div class="meatball-menu-delete" onclick="bulkDeleteTag('${optionEscapedJs}', '${fieldName}')">
                                    <div class="meatball-menu-delete-icon">
                                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                            <path d="M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5ZM11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H2.506a.58.58 0 0 0-.01 0H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84L13.46 3.5H14.5a.5.5 0 0 0 0-1h-1.004a.58.58 0 0 0-.01 0H11ZM4.118 4 4.5 14.5a1 1 0 0 0 1 .5h6.23a1 1 0 0 0 .997-.5L13.118 4H4.118Z"/>
                                        </svg>
                                    </div>
                                    <span>Delete</span>
                                </div>
                                <div class="meatball-menu-divider"></div>
                                <div class="meatball-menu-colors-title">Colors</div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'default')">
                                    <div class="meatball-menu-color-swatch" style="background: #d1d1d1;"></div>
                                    <span class="meatball-menu-color-label">Default</span>
                                    <span class="meatball-menu-color-checkmark" style="display: block;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'gray')">
                                    <div class="meatball-menu-color-swatch" style="background: #9ca3af;"></div>
                                    <span class="meatball-menu-color-label">Gray</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'brown')">
                                    <div class="meatball-menu-color-swatch" style="background: #92400e;"></div>
                                    <span class="meatball-menu-color-label">Brown</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'orange')">
                                    <div class="meatball-menu-color-swatch" style="background: #f97316;"></div>
                                    <span class="meatball-menu-color-label">Orange</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'yellow')">
                                    <div class="meatball-menu-color-swatch" style="background: #eab308;"></div>
                                    <span class="meatball-menu-color-label">Yellow</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'green')">
                                    <div class="meatball-menu-color-swatch" style="background: #22c55e;"></div>
                                    <span class="meatball-menu-color-label">Green</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'blue')">
                                    <div class="meatball-menu-color-swatch" style="background: #3b82f6;"></div>
                                    <span class="meatball-menu-color-label">Blue</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'purple')">
                                    <div class="meatball-menu-color-swatch" style="background: #a855f7;"></div>
                                    <span class="meatball-menu-color-label">Purple</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'pink')">
                                    <div class="meatball-menu-color-swatch" style="background: #ec4899;"></div>
                                    <span class="meatball-menu-color-label">Pink</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                                <div class="meatball-menu-color-option" onclick="bulkChangeTagColor('${optionEscapedJs}', '${fieldName}', 'red')">
                                    <div class="meatball-menu-color-swatch" style="background: #ef4444;"></div>
                                    <span class="meatball-menu-color-label">Red</span>
                                    <span class="meatball-menu-color-checkmark" style="display: none;"></span>
                                </div>
                            </div>
                        </div>`;
            });

            // Show "Create new option" if search doesn't match any existing options
            if (searchTerm && !availableOptions.some(opt => opt.toLowerCase() === searchTerm)) {
                html += `<div class="multiselect-option create-new" 
                              onclick="addNewMultiSelectOption('${insightId}', '${fieldName}', '${escapeHtml(searchTerm)}')">
                            <span class="create-icon">+</span>
                            <span>Create "${escapeHtml(searchTerm)}"</span>
                        </div>`;
            }

            if (!html && !searchTerm) {
                html = '<div class="multiselect-empty">No options available. Start typing to create a new one.</div>';
            } else if (!html && searchTerm) {
                html = `<div class="multiselect-option create-new" 
                             onclick="addNewMultiSelectOption('${insightId}', '${fieldName}', '${escapeHtmlFn(searchTerm)}')">
                           <span class="create-icon">+</span>
                           <span>Create "${escapeHtmlFn(searchTerm)}"</span>
                       </div>`;
            }

            optionsList.innerHTML = html;
        }

        function toggleTagMeatballMenu(event, optionValue, fieldName) {
            event.stopPropagation();
            
            // Close all other meatball menus
            document.querySelectorAll('.multiselect-option-meatball-menu.show').forEach(menu => {
                if (menu.id !== `meatball-menu-${fieldName}-${optionValue.replace(/[^a-zA-Z0-9]/g, '_')}`) {
                    menu.classList.remove('show');
                }
            });
            
            // Toggle this menu
            const menuId = `meatball-menu-${fieldName}-${optionValue.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const menu = document.getElementById(menuId);
            if (menu) {
                const wasOpen = menu.classList.contains('show');
                
                // Close all menus first
                document.querySelectorAll('.multiselect-option-meatball-menu.show').forEach(m => m.classList.remove('show'));
                
                // If it wasn't open, open it and position it
                if (!wasOpen) {
                    const buttonRect = event.target.getBoundingClientRect();
                    menu.style.display = 'block';
                    menu.style.top = (buttonRect.bottom + 4) + 'px';
                    menu.style.right = (window.innerWidth - buttonRect.right) + 'px';
                    menu.classList.add('show');
                    
                    // Update color checkmarks based on current color
                    const colors = window.getTagColors();
                    const colorKey = `${fieldName}:${optionValue}`;
                    const currentColor = colors[colorKey] || 'default';
                    
                    menu.querySelectorAll('.meatball-menu-color-checkmark').forEach(check => {
                        check.style.display = 'none';
                    });
                    
                    menu.querySelectorAll('.meatball-menu-color-option').forEach(option => {
                        const colorName = option.getAttribute('onclick')?.match(/'([^']+)'\)$/)?.[1];
                        if (colorName === currentColor) {
                            const checkmark = option.querySelector('.meatball-menu-color-checkmark');
                            if (checkmark) {
                                checkmark.style.display = 'block';
                            }
                        }
                    });
                    
                    // Focus the input field and reset preview tracking
                    setTimeout(() => {
                        const input = menu.querySelector('.tag-edit-input');
                        if (input) {
                            // Reset preview tracking to original value
                            input.dataset.currentPreviewValue = optionValue;
                            input.focus();
                            input.select();
                        }
                    }, 0);
                    
                    // Close menu when clicking outside
                    setTimeout(() => {
                        const closeMenu = (e) => {
                            if (!menu.contains(e.target) && !event.target.contains(e.target)) {
                                menu.classList.remove('show');
                                menu.style.display = 'none';
                                document.removeEventListener('click', closeMenu);
                            }
                        };
                        document.addEventListener('click', closeMenu);
                    }, 0);
                } else {
                    menu.style.display = 'none';
                }
            }
        }

        function previewTagRename(event, oldValue, fieldName) {
            const escapeHtmlFn = window.escapeHtml;
            const input = event.target;
            const newValue = input.value;
            const originalValue = input.dataset.originalValue || oldValue;
            const currentPreviewValue = input.dataset.currentPreviewValue || originalValue;
            
            // Store current preview value for next iteration
            input.dataset.currentPreviewValue = newValue || originalValue;
            
            // Update the option label in the dropdown immediately
            const optionRow = input.closest('.multiselect-option');
            if (optionRow) {
                const labelSpan = optionRow.querySelector('.option-label');
                if (labelSpan) {
                    labelSpan.textContent = newValue || originalValue;
                }
            }
            
            // Find pills by matching the current preview value OR original value
            // This handles the case where we've already updated some pills
            const allPills = document.querySelectorAll('.insight-pill');
            const matchingPills = Array.from(allPills).filter(pill => {
                const pillCell = pill.closest('.insight-multiselect-cell');
                if (!pillCell || pillCell.dataset.field !== fieldName) return false;
                
                const pillDataValue = pill.getAttribute('data-value');
                // Match if pill value equals current preview OR original (for first update)
                return pillDataValue === currentPreviewValue || pillDataValue === originalValue;
            });
            
            // Update all matching pills
            matchingPills.forEach(pill => {
                pill.setAttribute('data-value', escapeHtmlFn(newValue || originalValue));
                
                // Find and update the text content - pills have structure: <span>text<button></button></span>
                const button = pill.querySelector('.pill-remove');
                if (button && button.previousSibling) {
                    // Update the text node before the button
                    if (button.previousSibling.nodeType === Node.TEXT_NODE) {
                        button.previousSibling.textContent = newValue || originalValue;
                    } else {
                        // If it's not a text node, create one
                        const textNode = document.createTextNode(newValue || originalValue);
                        pill.insertBefore(textNode, button);
                        if (button.previousSibling.previousSibling) {
                            button.previousSibling.previousSibling.remove();
                        }
                    }
                } else if (button) {
                    // Button exists but no text node before it, add one
                    pill.insertBefore(document.createTextNode(newValue || originalValue), button);
                } else {
                    // No button, just update text content
                    pill.textContent = newValue || originalValue;
                }
            });
        }

        function handleTagRenameKeydown(event, oldValue, fieldName) {
            const input = event.target;
            const originalValue = input.dataset.originalValue || oldValue;
            
            if (event.key === 'Enter') {
                event.preventDefault();
                saveTagRename(event, originalValue, fieldName);
            } else if (event.key === 'Escape') {
                // Revert to original value
                input.value = originalValue;
                input.dataset.currentPreviewValue = originalValue;
                previewTagRename(event, originalValue, fieldName);
                input.blur();
            }
        }

        async function saveTagRename(event, oldValue, fieldName) {
            const input = event.target;
            const originalValue = input.dataset.originalValue || oldValue;
            const newValue = input.value.trim();
            
            if (!newValue || newValue === originalValue) {
                // Revert to original if empty or unchanged
                input.value = originalValue;
                previewTagRename(event, originalValue, fieldName);
                return;
            }
            
            // Update the stored original value for future edits
            input.dataset.originalValue = newValue;
            
            // Find all insights that have this tag
            const insightsWithTag = insightsAllInsights.filter(insight => {
                const values = normalizeFieldToArray(insight[fieldName], fieldName);
                return values.includes(originalValue);
            });
            
            if (insightsWithTag.length === 0) {
                input.value = originalValue;
                previewTagRename(event, originalValue, fieldName);
                return;
            }
            
            // Migrate color preference if it exists
            const colors = window.getTagColors();
            const oldKey = `${fieldName}:${originalValue}`;
            const newKey = `${fieldName}:${newValue}`;
            if (colors[oldKey]) {
                colors[newKey] = colors[oldKey];
                delete colors[oldKey];
                window.setTagColor(fieldName, newValue, colors[newKey]);
            }
            
            // Update each insight
            let successCount = 0;
            for (const insight of insightsWithTag) {
                const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
                const updatedValues = currentValues.map(v => v === originalValue ? newValue : v);
                
                const success = await updateInsightField(insight.id, fieldName, updatedValues.join(', '));
                if (success) {
                    successCount++;
                }
            }
            
            // Refresh the table
            loadInsightsPage();
            
            // Close the menu
            document.querySelectorAll('.multiselect-option-meatball-menu.show').forEach(menu => {
                menu.classList.remove('show');
                menu.style.display = 'none';
            });
        }

        async function bulkDeleteTag(tagValue, fieldName) {
            if (!confirm(`Delete tag "${tagValue}" from all insights? This action cannot be undone.`)) {
                return;
            }
            
            // Find all insights that have this tag
            const insightsWithTag = insightsAllInsights.filter(insight => {
                const values = normalizeFieldToArray(insight[fieldName], fieldName);
                return values.includes(tagValue);
            });
            
            if (insightsWithTag.length === 0) {
                alert('No insights found with this tag.');
                return;
            }
            
            // Remove color preference
            window.setTagColor(fieldName, tagValue, 'default');
            
            // Update each insight
            let successCount = 0;
            for (const insight of insightsWithTag) {
                const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
                const updatedValues = currentValues.filter(v => v !== tagValue);
                
                const success = await updateInsightField(insight.id, fieldName, updatedValues.join(', '));
                if (success) {
                    successCount++;
                }
            }
            
            // Refresh the table
            loadInsightsPage();
            
            // Close the menu
            document.querySelectorAll('.multiselect-option-meatball-menu.show').forEach(menu => {
                menu.classList.remove('show');
                menu.style.display = 'none';
            });
            
            alert(`Successfully deleted tag from ${successCount} insight(s).`);
        }

        async function bulkChangeTagColor(tagValue, fieldName, colorName) {
            // Save the color preference
            window.setTagColor(fieldName, tagValue, colorName);
            
            // Update checkmarks in the menu
            const menuId = `meatball-menu-${fieldName}-${tagValue.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const menu = document.getElementById(menuId);
            if (menu) {
                // Remove all checkmarks
                menu.querySelectorAll('.meatball-menu-color-checkmark').forEach(check => {
                    check.style.display = 'none';
                });
                
                // Find and show checkmark for the selected color by matching the colorName in onclick attribute
                menu.querySelectorAll('.meatball-menu-color-option').forEach(option => {
                    const onclickAttr = option.getAttribute('onclick') || '';
                    // Match the color name in the onclick attribute: bulkChangeTagColor('...', '...', 'colorName')
                    const matches = onclickAttr.match(/bulkChangeTagColor\([^,]+,\s*[^,]+,\s*'([^']+)'\)/);
                    if (matches && matches[1] === colorName) {
                        const checkmark = option.querySelector('.meatball-menu-color-checkmark');
                        if (checkmark) {
                            checkmark.style.display = 'block';
                        }
                    }
                });
            }
            
            // Update all pills with this tag across all insights
            const escapeHtmlFn = window.escapeHtml;
            
            // Use the colorName we just saved directly to get the color, rather than reading back from storage
            const colorMap = window.TAG_COLOR_MAP || {
                'default': { bg: 'rgba(99, 71, 169, 0.1)', color: '#6347a9' },
                'gray': { bg: 'rgba(156, 163, 175, 0.15)', color: '#6b7280' },
                'brown': { bg: 'rgba(146, 64, 14, 0.15)', color: '#92400e' },
                'orange': { bg: 'rgba(249, 115, 22, 0.15)', color: '#f97316' },
                'yellow': { bg: 'rgba(234, 179, 8, 0.15)', color: '#ca8a04' },
                'green': { bg: 'rgba(34, 197, 94, 0.15)', color: '#16a34a' },
                'blue': { bg: 'rgba(59, 130, 246, 0.15)', color: '#2563eb' },
                'purple': { bg: 'rgba(168, 85, 247, 0.15)', color: '#9333ea' },
                'pink': { bg: 'rgba(236, 72, 153, 0.15)', color: '#db2777' },
                'red': { bg: 'rgba(239, 68, 68, 0.15)', color: '#dc2626' }
            };
            const selectedColor = colorMap[colorName] || colorMap['default'];
            
            document.querySelectorAll(`.insight-pill[data-value="${escapeHtmlFn(tagValue)}"]`).forEach(pill => {
                const pillFieldName = pill.closest('.insight-multiselect-cell')?.dataset.field;
                if (pillFieldName === fieldName) {
                    pill.style.background = selectedColor.bg;
                    pill.style.color = selectedColor.color;
                }
            });
            
            // Also update pills in the dropdown if open
            const dropdown = document.getElementById('active-multiselect-dropdown');
            if (dropdown) {
                const dropdownCell = dropdown.closest('.insight-multiselect-cell');
                if (dropdownCell) {
                    const insightId = dropdownCell.dataset.insightId;
                    const currentValues = normalizeFieldToArray(
                        insightsAllInsights.find(i => i.id === insightId)?.[fieldName] || [],
                        fieldName
                    );
                    updateMultiSelectPills(insightId, fieldName, currentValues);
                }
            }
        }

        function filterMultiSelectOptions() {
            console.log('[MULTISELECT_FILTER] filterMultiSelectOptions called');
            
            const dropdown = document.getElementById('active-multiselect-dropdown');
            if (!dropdown) {
                console.warn('[MULTISELECT_FILTER] No dropdown found');
                return;
            }
            console.log('[MULTISELECT_FILTER] Dropdown found:', dropdown);

            // Get insightId and fieldName from dropdown's dataset (since dropdown is moved to body)
            const insightId = dropdown.dataset.insightId;
            const fieldName = dropdown.dataset.fieldName;
            
            console.log('[MULTISELECT_FILTER] insightId:', insightId, 'fieldName:', fieldName);
            
            if (!insightId || !fieldName) {
                console.warn('[MULTISELECT_FILTER] Missing insightId or fieldName in dropdown dataset');
                return;
            }
            
            const insight = insightsAllInsights.find(i => i.id === insightId);
            if (!insight) {
                console.warn('[MULTISELECT_FILTER] Insight not found for id:', insightId);
                return;
            }
            console.log('[MULTISELECT_FILTER] Found insight:', insight.id);

            const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
            const availableOptions = getUniqueFieldValues(fieldName);
            
            console.log('[MULTISELECT_FILTER] Rendering options. Available:', availableOptions.length, 'Current:', currentValues.length);
            
            renderMultiSelectOptions(availableOptions, currentValues, insightId, fieldName);
        }

        function handleMultiSelectKeydown(event, insightId, fieldName) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const searchInput = event.target;
                const searchTerm = searchInput.value.trim();
                
                if (searchTerm) {
                    const availableOptions = getUniqueFieldValues(fieldName);
                    const exactMatch = availableOptions.find(opt => opt.toLowerCase() === searchTerm.toLowerCase());
                    
                    if (exactMatch) {
                        toggleMultiSelectOption(insightId, fieldName, exactMatch);
                    } else {
                        addNewMultiSelectOption(insightId, fieldName, searchTerm);
                    }
                }
            } else if (event.key === 'Escape') {
                closeMultiSelect();
            }
        }

        async function toggleMultiSelectOption(insightId, fieldName, value) {
            const insight = insightsAllInsights.find(i => i.id === insightId);
            if (!insight) return;

            let currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
            
            if (currentValues.includes(value)) {
                currentValues = currentValues.filter(v => v !== value);
            } else {
                currentValues = [...currentValues, value];
            }

            // Update via API - send as comma-separated string for both type and application
            const success = await updateInsightField(insightId, fieldName, currentValues.join(', '));
            
            if (success) {
                // Update just the pills display without closing dropdown
                updateMultiSelectPills(insightId, fieldName, currentValues);
                
                // Refresh dropdown options to reflect changes
                const availableOptions = getUniqueFieldValues(fieldName);
                renderMultiSelectOptions(availableOptions, currentValues, insightId, fieldName);
            }
        }

        async function addNewMultiSelectOption(insightId, fieldName, newValue) {
            const insight = insightsAllInsights.find(i => i.id === insightId);
            if (!insight) return;

            const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
            
            // Add new value if not already present
            if (!currentValues.includes(newValue)) {
                const updatedValues = [...currentValues, newValue];
                
                // Update via API - send as comma-separated string for both type and application
                const success = await updateInsightField(insightId, fieldName, updatedValues.join(', '));
                
                if (success) {
                    // Update just the pills display without closing dropdown
                    updateMultiSelectPills(insightId, fieldName, updatedValues);
                    
                    // Refresh dropdown options to reflect changes
                    const availableOptions = getUniqueFieldValues(fieldName);
                    renderMultiSelectOptions(availableOptions, updatedValues, insightId, fieldName);
                    
                    // Clear search input
                    const searchInput = document.querySelector('.multiselect-search');
                    if (searchInput) {
                        searchInput.value = '';
                        searchInput.focus();
                    }
                }
            }
        }

        async function removeMultiSelectValue(insightId, fieldName, value) {
            const insight = insightsAllInsights.find(i => i.id === insightId);
            if (!insight) return;

            const currentValues = normalizeFieldToArray(insight[fieldName], fieldName);
            const updatedValues = currentValues.filter(v => v !== value);

            // Update via API - send as comma-separated string for both type and application
            const success = await updateInsightField(insightId, fieldName, updatedValues.join(', '));
            
            if (success) {
                // Update just the pills display without closing dropdown
                updateMultiSelectPills(insightId, fieldName, updatedValues);
                
                // Refresh dropdown options to reflect changes
                const availableOptions = getUniqueFieldValues(fieldName);
                renderMultiSelectOptions(availableOptions, updatedValues, insightId, fieldName);
            }
        }

        // Tag color storage and management - now imported from js/services/storage.js module
        // TAG_COLORS_STORAGE_KEY, TAG_COLOR_MAP, getTagColors, setTagColor, getTagColor available globally via window.*

        function getPillStyle(fieldName, tagValue) {
            const color = window.getTagColor(fieldName, tagValue);
            return `background: ${color.bg}; color: ${color.color};`;
        }

        // Helper function to update pills display without re-rendering entire table
        function updateMultiSelectPills(insightId, fieldName, values) {
            const escapeHtmlFn = window.escapeHtml;
            
            const cell = document.getElementById(`multiselect-${fieldName}-${insightId}`);
            if (!cell) return;

            const pillsContainer = cell.querySelector('.insight-pills-container');
            if (!pillsContainer) return;

            // Generate new pills HTML with colors
            const pills = values.map(value => {
                const style = getPillStyle(fieldName, value);
                // Escape single quotes and backslashes for JavaScript string in onclick handler
                const valueEscapedJs = String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                return `<span class="insight-pill" data-value="${escapeHtmlFn(value)}" style="${style}">
                    ${escapeHtmlFn(value)}
                    <button class="pill-remove" onclick="event.stopPropagation(); event.preventDefault(); removeMultiSelectValue('${insightId}', '${fieldName}', '${valueEscapedJs}')"></button>
                </span>`;
            }).join('');

            pillsContainer.innerHTML = pills || '<span class="empty-value">-</span>';
        }

        function closeMultiSelect() {
            const dropdown = document.getElementById('active-multiselect-dropdown');
            if (dropdown) {
                dropdown.remove();
            }
            
            // Remove active class from all cells
            document.querySelectorAll('.insight-multiselect-cell.dropdown-active').forEach(cell => {
                cell.classList.remove('dropdown-active');
            });
            
            document.removeEventListener('click', closeMultiSelectOnClickOutside, true);
        }

        function closeMultiSelectOnClickOutside(event) {
            const dropdown = document.getElementById('active-multiselect-dropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                // Check if click is on pill-remove button - don't close if so
                if (event.target.classList.contains('pill-remove')) {
                    return;
                }
                // Prevent the click from propagating to other elements
                event.preventDefault();
                event.stopPropagation();
                closeMultiSelect();
            }
        }

        // Inline text editing for name field
        function createEditableNameCell(insightId, name, highlightedName) {
            const escapeHtmlFn = window.escapeHtml;
            return `<td class="name-cell" data-column="name">
                <div class="name-content" style="position: relative;">
                    <svg class="doc-icon" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M2.5 2.5h11l.5.5v10l-.5.5h-11l-.5-.5V3l.5-.5zM3 4v8h10V4H3zm2 1h6v1H5V5zm0 2h6v1H5V7zm0 2h4v1H5V9z"/>
                    </svg>
                    <span class="insight-name-text" 
                          contenteditable="true" 
                          data-insight-id="${insightId}"
                          data-original-name="${escapeHtmlFn(name)}"
                          onblur="saveInsightName('${insightId}')"
                          onkeydown="handleNameKeydown(event, '${insightId}')"
                          onclick="event.stopPropagation(); this.focus();">${highlightedName}</span>
                    <button class="insight-open-btn-table" onclick="openInsightNotes('${insightId}')" title="Open in side peek" style="display: none;">
                        <span style="font-size: 12px; margin-right: 4px;">OPEN</span>
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" style="opacity: 0.6;">
                            <rect x="4" y="4" width="8" height="8" stroke="currentColor" stroke-width="1.5" fill="none" rx="1"/>
                            <path d="M6 2 L6 6 M10 2 L10 6 M2 6 L2 10 M2 6 L6 6 M10 6 L14 6 M14 6 L14 10" stroke="currentColor" stroke-width="1.5" fill="none"/>
                        </svg>
                    </button>
                </div>
            </td>`;
        }

        function handleNameKeydown(event, insightId) {
            if (event.key === 'Enter') {
                event.preventDefault();
                event.target.blur();
            } else if (event.key === 'Escape') {
                event.preventDefault();
                const originalName = event.target.dataset.originalName;
                event.target.textContent = originalName;
                event.target.blur();
            }
        }

        async function saveInsightName(insightId) {
            const nameElement = document.querySelector(`.insight-name-text[data-insight-id="${insightId}"]`);
            if (!nameElement) return;

            const newName = nameElement.textContent.trim();
            const originalName = nameElement.dataset.originalName;

            if (newName === originalName || !newName) {
                // Revert if empty or unchanged
                nameElement.textContent = originalName;
                return;
            }

            // Update via API
            const success = await updateInsightField(insightId, 'name', newName);
            
            if (success) {
                // Update original name reference
                nameElement.dataset.originalName = newName;
            } else {
                // Revert on failure
                nameElement.textContent = originalName;
            }
        }

        async function openInsightNotes(insightId) {
            // Delegate to SlideoutPanel for consistent behavior
            if (window.SlideoutPanel && window.SlideoutPanel.openInsightNotes) {
                return await window.SlideoutPanel.openInsightNotes(insightId);
            } else {
                console.error('[openInsightNotes] SlideoutPanel not available');
                alert('Unable to open insight. Please refresh the page.');
            }
        }

        function closeInsightNotes() {
            if (window.SlideoutPanel && window.SlideoutPanel.close) {
                window.SlideoutPanel.close();
            }
            
            // Clean up any remaining standalone state
            insightsCurrentInsightNotesId = null;
            insightsCurrentInsightData = null;
            
            if (insightsSaveNotesTimeout) {
                clearTimeout(insightsSaveNotesTimeout);
                insightsSaveNotesTimeout = null;
            }
            if (insightsFieldSaveTimeout) {
                clearTimeout(insightsFieldSaveTimeout);
                insightsFieldSaveTimeout = null;
            }
        }

        // Shared media upload utilities for insight editors
        async function uploadMediaToBlob(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const frontendUrl = window.location.origin;
            const response = await fetch(`${frontendUrl}/api/upload-media`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
                throw new Error(errorData.error || errorData.detail || 'Upload failed');
            }
            
            const data = await response.json();
            return data.url;
        }
        
        function convertLoomUrl(url) {
            if (!url) return null;
            // Match various Loom URL formats: loom.com/share/ID, www.loom.com/share/ID, etc.
            // Also handle URLs with or without protocol
            const loomMatch = url.match(/(?:https?:\/\/)?(?:www\.)?loom\.com\/share\/([a-zA-Z0-9]+)/);
            if (loomMatch) {
                const videoId = loomMatch[1];
                return `https://www.loom.com/embed/${videoId}`;
            }
            return null;
        }
        
        function createMediaPasteHandler(getEditor, insertAndUploadMedia) {
            return (view, event, slice) => {
                console.log('[Paste Handler] Paste event triggered', { view, event, slice });
                console.log('[Paste Handler] Clipboard data available:', !!event.clipboardData);
                
                // Get editor reference at execution time (getEditor can be a function or the editor itself)
                const editor = typeof getEditor === 'function' ? getEditor() : getEditor;
                console.log('[Paste Handler] Editor available:', !!editor, editor);
                if (!editor) {
                    console.log('[Paste Handler] No editor available, allowing default paste');
                    return false; // Editor not available, allow default paste
                }
                
                const items = Array.from(event.clipboardData?.items || []);
                console.log('[Paste Handler] Clipboard items:', items.length, items.map(item => ({ type: item.type, kind: item.kind })));
                
                const imageItem = items.find(item => item.type.startsWith('image/'));
                const videoItem = items.find(item => item.type.startsWith('video/'));
                console.log('[Paste Handler] Image item:', !!imageItem, 'Video item:', !!videoItem);
                
                if (imageItem) {
                    console.log('[Paste Handler] Processing image paste');
                    event.preventDefault();
                    const file = imageItem.getAsFile();
                    if (file) {
                        insertAndUploadMedia(file, false);
                        return true;
                    }
                }
                
                if (videoItem) {
                    console.log('[Paste Handler] Processing video paste');
                    event.preventDefault();
                    const file = videoItem.getAsFile();
                    if (file) {
                        insertAndUploadMedia(file, true);
                        return true;
                    }
                }
                
                // Check for Loom URLs in both plain text and HTML clipboard data
                const pastedText = event.clipboardData?.getData('text/plain');
                const pastedHtml = event.clipboardData?.getData('text/html');
                console.log('[Paste Handler] Pasted text:', pastedText);
                console.log('[Paste Handler] Pasted HTML:', pastedHtml ? pastedHtml.substring(0, 200) + '...' : null);
                
                // Extract URL from pasted content (check plain text first, then HTML)
                let textToCheck = pastedText?.trim();
                if (!textToCheck && pastedHtml) {
                    console.log('[Paste Handler] Extracting URL from HTML');
                    // Try to extract URL from HTML (look for href attributes first, then text content)
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = pastedHtml;
                    const linkElement = tempDiv.querySelector('a[href]');
                    if (linkElement) {
                        textToCheck = linkElement.href;
                        console.log('[Paste Handler] Found URL in link href:', textToCheck);
                    } else {
                        // Fall back to text content if no link element found
                        textToCheck = tempDiv.textContent?.trim();
                        console.log('[Paste Handler] Using HTML text content:', textToCheck);
                    }
                }
                
                console.log('[Paste Handler] Text to check for Loom URL:', textToCheck);
                
                // Check if the pasted content contains a Loom URL (even if embedded in other text)
                if (textToCheck) {
                    const loomEmbedUrl = convertLoomUrl(textToCheck);
                    console.log('[Paste Handler] Loom embed URL:', loomEmbedUrl);
                    if (loomEmbedUrl) {
                        console.log('[Paste Handler] Inserting Loom iframe');
                        event.preventDefault();
                        // Use TipTap's iframe node instead of raw HTML
                        editor.chain().focus().insertContent({
                            type: 'iframe',
                            attrs: {
                                src: loomEmbedUrl,
                                width: '100%',
                                height: '500px',
                                frameborder: '0',
                                allowfullscreen: true,
                                style: 'width: 100%; border-radius: 0.5rem; aspect-ratio: 16/9; margin: 1rem 0; border: none;',
                            },
                        }).run();
                        const editorHtml = editor.getHTML();
                        console.log('[Paste Handler] Editor HTML after insertion:', editorHtml);
                        console.log('[Paste Handler] Editor HTML contains iframe:', editorHtml.includes('iframe'));
                        console.log('[Paste Handler] Editor HTML contains embed URL:', editorHtml.includes(loomEmbedUrl));
                        return true;
                    } else {
                        console.log('[Paste Handler] Not a Loom URL, allowing default paste');
                    }
                } else {
                    console.log('[Paste Handler] No text to check, allowing default paste');
                }
                
                console.log('[Paste Handler] Returning false, allowing default paste behavior');
                return false;
            };
        }
        
        function createMediaDropHandler(insertAndUploadMedia) {
            return (view, event, slice, moved) => {
                if (!moved && event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
                    const file = event.dataTransfer.files[0];
                    const isImage = file.type.startsWith('image/');
                    const isVideo = file.type.startsWith('video/');
                    
                    if (isImage || isVideo) {
                        event.preventDefault();
                        insertAndUploadMedia(file, isVideo);
                        return true;
                    }
                }
                return false;
            };
        }
        
        // Removed standalone functions - now using SlideoutPanel implementations:
        // - initializeInsightEditor -> SlideoutPanel.initializeInsightEditor
        // - setupInsightEditorContextMenu -> SlideoutPanel.setupEditorContextMenu
        // - cleanupInsightEditorContextMenu -> SlideoutPanel.cleanupEditorContextMenu
        
        function updateInsightContextMenuStates(menu, editor) {
            const items = menu.querySelectorAll('.context-menu-item');
            items.forEach(item => {
                const action = item.getAttribute('data-action');
                let isActive = false;
                
                switch (action) {
                    case 'heading-1':
                        isActive = editor.isActive('heading', { level: 1 });
                        break;
                    case 'heading-2':
                        isActive = editor.isActive('heading', { level: 2 });
                        break;
                    case 'heading-3':
                        isActive = editor.isActive('heading', { level: 3 });
                        break;
                    case 'bold':
                        isActive = editor.isActive('bold');
                        break;
                    case 'bulletList':
                        isActive = editor.isActive('bulletList');
                        break;
                    case 'taskList':
                        isActive = editor.isActive('taskList');
                        break;
                    case 'blockquote':
                        isActive = editor.isActive('blockquote');
                        break;
                }
                
                if (isActive) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function debouncedSaveInsightNotes(insightId, content) {
            // Use SlideoutPanel.currentInsightId if insightId is not provided
            if (!insightId && window.SlideoutPanel && window.SlideoutPanel.currentInsightId) {
                insightId = window.SlideoutPanel.currentInsightId;
            }
            clearTimeout(insightsSaveNotesTimeout);
            
            const statusEl = document.getElementById('insightNotesSaveStatus');
            if (statusEl) {
                statusEl.textContent = 'Saving...';
                statusEl.style.color = 'oklch(0.556 0 0)';
                statusEl.style.opacity = '1';
                statusEl.style.pointerEvents = 'auto';
            }
            
            insightsSaveNotesTimeout = setTimeout(async () => {
                await saveInsightNotes(insightId, content);
            }, 500);
        }

        function debouncedSaveInsightField(fieldName, value) {
            clearTimeout(insightsFieldSaveTimeout);
            
            insightsFieldSaveTimeout = setTimeout(async () => {
                await saveInsightField(fieldName, value);
            }, 500);
        }

        async function saveInsightField(fieldName, value) {
            // Use SlideoutPanel.currentInsightId if available, otherwise fall back to insightsCurrentInsightNotesId
            const insightId = (window.SlideoutPanel && window.SlideoutPanel.currentInsightId) 
                ? window.SlideoutPanel.currentInsightId 
                : insightsCurrentInsightNotesId;
            const clientId = (window.SlideoutPanel && currentClientId) 
                ? currentClientId 
                : insightsCurrentClientId;
            
            if (!clientId || !insightId) return;
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    throw new Error('Not authenticated');
                }
                
                const updateData = {};
                updateData[fieldName] = value;
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${clientId}/insights/${insightId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save field');
                }
                
                if (insightsCurrentInsightData) {
                    insightsCurrentInsightData[fieldName] = value;
                }
                
                if (typeof loadInsightsPage === 'function') {
                    loadInsightsPage();
                }
            } catch (error) {
                console.error('Error saving field:', error);
            }
        }

        async function saveInsightNotes(insightId, content) {
            // Use SlideoutPanel.currentInsightId if insightId is not provided
            if (!insightId && window.SlideoutPanel && window.SlideoutPanel.currentInsightId) {
                insightId = window.SlideoutPanel.currentInsightId;
            }
            // Use SlideoutPanel.currentInsightId if available, otherwise fall back to insightsCurrentInsightNotesId
            const finalInsightId = insightId || ((window.SlideoutPanel && window.SlideoutPanel.currentInsightId) 
                ? window.SlideoutPanel.currentInsightId 
                : insightsCurrentInsightNotesId);
            const clientId = (window.SlideoutPanel && currentClientId) 
                ? currentClientId 
                : insightsCurrentClientId;
            
            if (!clientId || !finalInsightId) return;
            
            const statusEl = document.getElementById('insightNotesSaveStatus');
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    throw new Error('Not authenticated');
                }
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${clientId}/insights/${finalInsightId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ notes: content })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save notes');
                }
                
                if (statusEl) {
                    statusEl.textContent = 'Saved';
                    statusEl.style.color = '#B9F040';
                    statusEl.style.opacity = '1';
                    statusEl.style.pointerEvents = 'auto';
                    setTimeout(() => {
                        if (statusEl) {
                            statusEl.style.opacity = '0';
                            setTimeout(() => {
                                if (statusEl) {
                                    statusEl.textContent = '';
                                    statusEl.style.pointerEvents = 'none';
                                }
                            }, 200); // Wait for fade out animation
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('Error saving notes:', error);
                if (statusEl) {
                    statusEl.textContent = 'Error saving';
                    statusEl.style.color = 'oklch(0.577 0.245 27.325)';
                    statusEl.style.opacity = '1';
                    statusEl.style.pointerEvents = 'auto';
                }
            }
        }

        // Column order management
        const COLUMN_ORDER_KEY = 'insights_column_order';
        
        function getDefaultColumnOrder() {
            return ['name', 'type', 'application', 'status', 'origin', 'created_at'];
        }
        
        function getColumnOrder() {
            const saved = localStorage.getItem(COLUMN_ORDER_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Migrate old column order: replace 'project' and 'data_source' with 'origin'
                    const migrated = parsed.map(col => {
                        if (col === 'project' || col === 'data_source') {
                            return 'origin';
                        }
                        return col;
                    }).filter((col, index, arr) => arr.indexOf(col) === index); // Remove duplicates
                    
                    // Validate that all default columns are present
                    const defaultOrder = getDefaultColumnOrder();
                    const hasAllColumns = defaultOrder.every(col => migrated.includes(col));
                    if (hasAllColumns && migrated.length === defaultOrder.length) {
                        // Save migrated order
                        if (JSON.stringify(migrated) !== JSON.stringify(parsed)) {
                            saveColumnOrder(migrated);
                        }
                        return migrated;
                    }
                } catch (e) {
                    console.warn('Failed to parse saved column order:', e);
                }
            }
            return getDefaultColumnOrder();
        }
        
        function saveColumnOrder(order) {
            localStorage.setItem(COLUMN_ORDER_KEY, JSON.stringify(order));
        }
        
        function initializeColumnDragAndDrop() {
            const tables = document.querySelectorAll('.notion-table');
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                if (!thead) return;
                
                const headers = Array.from(thead.querySelectorAll('th.draggable'));
                headers.forEach(header => {
                    header.addEventListener('dragstart', handleDragStart);
                    header.addEventListener('dragend', handleDragEnd);
                    header.addEventListener('dragover', handleDragOver);
                    header.addEventListener('drop', handleDrop);
                    header.addEventListener('dragleave', handleDragLeave);
                });
            });
            
            // Initialize column resizing
            initializeColumnResize();
        }

        // Column resize functionality
        const COLUMN_WIDTHS_STORAGE_KEY = 'vizualizd_column_widths';
        let resizing = false;
        let currentResizeHeader = null;
        let startX = 0;
        let startWidth = 0;

        function getColumnWidths() {
            try {
                const stored = localStorage.getItem(COLUMN_WIDTHS_STORAGE_KEY);
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                console.error('Error loading column widths:', e);
                return {};
            }
        }

        function setColumnWidth(columnName, width) {
            const widths = getColumnWidths();
            widths[columnName] = width;
            try {
                localStorage.setItem(COLUMN_WIDTHS_STORAGE_KEY, JSON.stringify(widths));
            } catch (e) {
                console.error('Error saving column width:', e);
            }
        }

        function applyColumnWidths() {
            const widths = getColumnWidths();
            const tables = document.querySelectorAll('.notion-table');
            
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                const tbody = table.querySelector('tbody');
                if (!thead || !tbody) return;
                
                // Skip insights panel table on visualizations tab - it has a different structure (only 2 columns)
                // The insights panel table has id "insightsTableBody" and is in the visualizations-section
                if (tbody.id === 'insightsTableBody' && table.closest('#visualizations-section')) {
                    return;
                }
                
                const headers = Array.from(thead.querySelectorAll('th[data-column]'));
                headers.forEach(header => {
                    const columnName = header.getAttribute('data-column');
                    if (columnName && widths[columnName]) {
                        const width = widths[columnName];
                        header.style.width = width + 'px';
                        header.style.minWidth = width + 'px';
                        header.style.maxWidth = width + 'px';
                        
                        // Apply to corresponding cells
                        const tbody = table.querySelector('tbody');
                        if (tbody) {
                            const cells = tbody.querySelectorAll(`td[data-column="${columnName}"]`);
                            cells.forEach(cell => {
                                cell.style.width = width + 'px';
                                cell.style.minWidth = width + 'px';
                                cell.style.maxWidth = width + 'px';
                            });
                        }
                    }
                });
            });
        }

        function initializeColumnResize() {
            const tables = document.querySelectorAll('.notion-table');
            
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                if (!thead) return;
                
                const headers = Array.from(thead.querySelectorAll('th[data-column]'));
                headers.forEach(header => {
                    // Skip if resize handle already exists
                    if (header.querySelector('.resize-handle')) return;
                    
                    // Create resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.style.position = 'absolute';
                    resizeHandle.style.top = '0';
                    resizeHandle.style.right = '0';
                    resizeHandle.style.width = '4px';
                    resizeHandle.style.height = '100%';
                    resizeHandle.style.cursor = 'col-resize';
                    resizeHandle.style.background = 'transparent';
                    resizeHandle.style.zIndex = '10';
                    
                    resizeHandle.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        startResize(header, e);
                    });
                    
                    header.appendChild(resizeHandle);
                });
            });
        }

        function startResize(header, e) {
            resizing = true;
            currentResizeHeader = header;
            startX = e.pageX;
            startWidth = header.offsetWidth;
            
            header.classList.add('resizing');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        }

        function handleResize(e) {
            if (!resizing || !currentResizeHeader) return;
            
            const diff = e.pageX - startX;
            const newWidth = Math.max(50, startWidth + diff); // Minimum width of 50px
            
            const columnName = currentResizeHeader.getAttribute('data-column');
            if (!columnName) return;
            
            // Update header width
            currentResizeHeader.style.width = newWidth + 'px';
            currentResizeHeader.style.minWidth = newWidth + 'px';
            currentResizeHeader.style.maxWidth = newWidth + 'px';
            
            // Update all corresponding cells
            const table = currentResizeHeader.closest('.notion-table');
            if (table) {
                const cells = table.querySelectorAll(`td[data-column="${columnName}"]`);
                cells.forEach(cell => {
                    cell.style.width = newWidth + 'px';
                    cell.style.minWidth = newWidth + 'px';
                    cell.style.maxWidth = newWidth + 'px';
                });
            }
        }

        function stopResize() {
            if (!resizing || !currentResizeHeader) return;
            
            const columnName = currentResizeHeader.getAttribute('data-column');
            if (columnName) {
                const width = currentResizeHeader.offsetWidth;
                setColumnWidth(columnName, width);
            }
            
            currentResizeHeader.classList.remove('resizing');
            currentResizeHeader = null;
            resizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            document.removeEventListener('mousemove', handleResize);
            document.removeEventListener('mouseup', stopResize);
        }
        
        let draggedColumn = null;
        
        function handleDragStart(e) {
            draggedColumn = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('drag-over');
            });
            draggedColumn = null;
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.target.closest('th.draggable');
            if (target && target !== draggedColumn) {
                target.classList.add('drag-over');
            }
            return false;
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('th.draggable');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const target = e.target.closest('th.draggable');
            if (!target || !draggedColumn || target === draggedColumn) {
                return false;
            }
            
            const table = target.closest('table');
            if (!table) return false;
            
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) return false;
            
            // Get column names
            const draggedCol = draggedColumn.getAttribute('data-column');
            const targetCol = target.getAttribute('data-column');
            
            if (!draggedCol || !targetCol) return false;
            
            // Get current order
            const currentOrder = Array.from(thead.querySelectorAll('th.draggable'))
                .map(th => th.getAttribute('data-column'))
                .filter(col => col);
            
            // Calculate new order
            const draggedIndex = currentOrder.indexOf(draggedCol);
            const targetIndex = currentOrder.indexOf(targetCol);
            
            if (draggedIndex === -1 || targetIndex === -1) return false;
            
            // Remove dragged column from its current position
            const newOrder = [...currentOrder];
            newOrder.splice(draggedIndex, 1);
            
            // Insert at target position
            const insertIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
            newOrder.splice(insertIndex, 0, draggedCol);
            
            // Save new order
            saveColumnOrder(newOrder);
            
            // Reorder headers
            const headerMap = new Map();
            const nonDraggableHeaders = [];
            
            Array.from(thead.querySelectorAll('th')).forEach(th => {
                if (th.classList.contains('draggable')) {
                    const col = th.getAttribute('data-column');
                    if (col) {
                        headerMap.set(col, th);
                    }
                } else {
                    nonDraggableHeaders.push(th);
                }
            });
            
            thead.innerHTML = '';
            newOrder.forEach(col => {
                const header = headerMap.get(col);
                if (header) thead.appendChild(header);
            });
            nonDraggableHeaders.forEach(header => {
                thead.appendChild(header);
            });
            
            // Reorder body cells
            const rows = Array.from(tbody.querySelectorAll('tr'));
            rows.forEach(row => {
                const cellMap = new Map();
                const nonDraggableCells = [];
                
                Array.from(row.querySelectorAll('td')).forEach(cell => {
                    const col = cell.getAttribute('data-column');
                    if (col) {
                        cellMap.set(col, cell);
                    } else {
                        nonDraggableCells.push(cell);
                    }
                });
                
                row.innerHTML = '';
                newOrder.forEach(col => {
                    const cell = cellMap.get(col);
                    if (cell) row.appendChild(cell);
                });
                nonDraggableCells.forEach(cell => {
                    row.appendChild(cell);
                });
            });
            
            // Re-initialize drag and drop
            initializeColumnDragAndDrop();
            
            target.classList.remove('drag-over');
            return false;
        }
        
        function applyColumnOrder() {
            const order = getColumnOrder();
            const tables = document.querySelectorAll('.notion-table');
            
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                const tbody = table.querySelector('tbody');
                
                if (!thead || !tbody) return;
                
                // Skip history table - it has its own fixed column order
                if (table.closest('#history-section')) {
                    return;
                }
                
                // Skip insights panel table on visualizations tab - it has a different structure (only 2 columns)
                // The insights panel table has id "insightsTableBody" and is in the visualizations-section
                if (tbody.id === 'insightsTableBody' && table.closest('#visualizations-section')) {
                    return;
                }
                
                // Get all headers and map them by column
                const allHeaders = Array.from(thead.querySelectorAll('th'));
                const headerMap = new Map();
                const nonDraggableHeaders = [];
                
                allHeaders.forEach(header => {
                    if (header.classList.contains('draggable')) {
                        const col = header.getAttribute('data-column');
                        if (col) {
                            headerMap.set(col, header);
                        }
                    } else {
                        nonDraggableHeaders.push(header);
                    }
                });
                
                // Reorder headers based on saved order
                const orderedHeaders = order.map(col => headerMap.get(col)).filter(h => h);
                
                // Clear and rebuild header row
                thead.innerHTML = '';
                orderedHeaders.forEach(header => {
                    thead.appendChild(header);
                });
                nonDraggableHeaders.forEach(header => {
                    thead.appendChild(header);
                });
                
                // Reorder body cells
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.forEach(row => {
                    const allCells = Array.from(row.querySelectorAll('td'));
                    const cellMap = new Map();
                    const nonDraggableCells = [];
                    
                    // Map cells by data-column attribute
                    allCells.forEach(cell => {
                        const col = cell.getAttribute('data-column');
                        if (col) {
                            cellMap.set(col, cell);
                        } else {
                            // Cells without data-column (like Actions) are non-draggable
                            nonDraggableCells.push(cell);
                        }
                    });
                    
                    // Clear and rebuild row in correct order
                    row.innerHTML = '';
                    order.forEach(col => {
                        const cell = cellMap.get(col);
                        if (cell) row.appendChild(cell);
                    });
                    nonDraggableCells.forEach(cell => {
                        row.appendChild(cell);
                    });
                    
                });
            });
            
            // Re-initialize drag and drop after reordering
            initializeColumnDragAndDrop();
            
            // Re-apply column widths after reordering
            if (typeof applyColumnWidths === 'function') {
                applyColumnWidths();
            }
        }

        // Make insights functions globally accessible
        window.openCreateModal = openCreateModal;
        window.closeModal = closeModal;
        window.handleSearch = handleSearch;
        window.sortBy = sortBy;
        window.removeFilter = removeFilter;
        window.resetFilters = resetFilters;
        window.openFilterMenu = openFilterMenu;
        window.toggleFilterMenu = toggleFilterMenu;
        window.filterFilterOptions = filterFilterOptions;
        window.openFilterValueDialog = openFilterValueDialog;
        window.toggleFilterValue = toggleFilterValue;
        window.toggleInlineFilterValue = toggleInlineFilterValue;
        window.toggleInlineFilterDropdown = toggleInlineFilterDropdown;
        window.removeInlineFilter = removeInlineFilter;
        window.addDateFilter = addDateFilter;
        window.closeFilterValueDialog = closeFilterValueDialog;
        window.removeFilterByIndex = removeFilterByIndex;
        window.editInsight = editInsight;
        window.deleteInsight = deleteInsight;
        window.handleInsightCheckboxChange = handleInsightCheckboxChange;
        window.toggleSelectAllInsights = toggleSelectAllInsights;
        window.deleteSelectedInsights = deleteSelectedInsights;
        window.updateInsightStatus = updateInsightStatus;
        window.saveInsight = saveInsight;
        window.openInsightNotes = openInsightNotes;
        window.closeInsightNotes = closeInsightNotes;
        window.initInsightsPage = initInsightsPage;
        window.applyColumnOrder = applyColumnOrder;
        window.initializeColumnDragAndDrop = initializeColumnDragAndDrop;
        window.applyColumnWidths = applyColumnWidths;
        window.initializeColumnResize = initializeColumnResize;
        
        // Multi-select and inline editing functions
        window.updateInsightField = updateInsightField;
        window.getUniqueFieldValues = getUniqueFieldValues;
        window.createMultiSelectCell = createMultiSelectCell;
        window.openMultiSelect = openMultiSelect;
        window.closeMultiSelect = closeMultiSelect;
        window.filterMultiSelectOptions = filterMultiSelectOptions;
        window.handleMultiSelectKeydown = handleMultiSelectKeydown;
        window.toggleMultiSelectOption = toggleMultiSelectOption;
        window.addNewMultiSelectOption = addNewMultiSelectOption;
        window.removeMultiSelectValue = removeMultiSelectValue;
        window.updateMultiSelectPills = updateMultiSelectPills;
        window.createEditableNameCell = createEditableNameCell;
        window.handleNameKeydown = handleNameKeydown;
        window.saveInsightName = saveInsightName;
        
        // Debug: Verify function is accessible

        // Close modal/panel handlers
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('insightModal');
            if (modal && modal.classList.contains('active') && e.target === modal) {
                closeModal();
            }
            
            // Check for slideoutOverlay (SlideoutPanel) instead of insightNotesOverlay
            const overlay = document.getElementById('slideoutOverlay');
            if (overlay && e.target === overlay && window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                closeInsightNotes();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('insightModal');
                if (modal && modal.classList.contains('active')) {
                    closeModal();
                }
                
                // Check for slideoutPanel (SlideoutPanel) instead of insightNotesPanel
                const panel = document.getElementById('slideoutPanel');
                if (panel && panel.classList.contains('open') && window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                    closeInsightNotes();
                }
            }
        });

        // Removed: closeInsightNotesPanel button event listener - now using SlideoutPanel's close button
        
        // Wait for module script to finish assigning window functions before auth check
        // Module scripts are deferred, so they run after HTML parsing but we need to ensure
        // window functions are available before handleAuthenticatedUser is called
        function waitForModuleAndCheckAuth() {
            if (typeof window.appStateSetCurrentProjectName === 'function') {
                const authCheck = typeof Auth !== 'undefined' ? Auth.checkAuth() : Promise.resolve(false);
                authCheck.then(authenticated => {
                    console.log('Auth check result:', authenticated);
                    if (!authenticated) {
                        console.log('Not authenticated, showing login');
                        if (typeof Auth !== 'undefined') {
                            Auth.showLogin();
                        }
                    }
                }).catch(error => {
                    console.error('Error in checkAuth:', error);
                });
            } else {
                // Module script hasn't run yet, wait a bit and try again
                setTimeout(waitForModuleAndCheckAuth, 10);
            }
        }
        waitForModuleAndCheckAuth();
        
        async function getPromptRendererWithRetry() {
            const diagnostics = {
                FounderAdmin: !!window.FounderAdmin,
                MarkdownConverter: !!window.MarkdownConverter,
                StreamingRenderer: !!window.StreamingRenderer,
                PromptUIRenderer: !!window.PromptUIRenderer,
                ClientPromptRenderer: !!window.ClientPromptRenderer,
                getClientPromptRenderer: !!window.getClientPromptRenderer
            };
            console.log('[getPromptRendererWithRetry] Module availability:', diagnostics);

            let renderer = window.PromptUIRenderer || window.ClientPromptRenderer;
            if (!renderer && window.getClientPromptRenderer) {
                console.log('[getPromptRendererWithRetry] Attempting to initialize renderer...');
                renderer = window.getClientPromptRenderer();
            }

            if (!renderer) {
                console.log('[getPromptRendererWithRetry] Renderer not available, waiting 200ms and retrying...');
                await new Promise(resolve => setTimeout(resolve, 200));
                renderer = window.PromptUIRenderer || window.ClientPromptRenderer;
                if (!renderer && window.getClientPromptRenderer) {
                    renderer = window.getClientPromptRenderer();
                }
            }

            if (!renderer) {
                console.error('[getPromptRendererWithRetry] Rendering modules not available after retry:', {
                    ...diagnostics,
                    afterRetry: {
                        PromptUIRenderer: !!window.PromptUIRenderer,
                        ClientPromptRenderer: !!window.ClientPromptRenderer
                    }
                });
            }

            return renderer;
        }

        // Slideout Panel - handles AI Insights, Verbatims, Insight Notes, and Create Insight
        const SlideoutPanel = {
            isOpen: false,
            currentMode: null, // 'ai-insights', 'verbatims', 'insight-notes', 'create-insight', 'history', or 'chart'
            currentContext: null,
            currentDimensionRef: null,  // Track current dimension
            currentInsightEditor: null,  // Tiptap editor instance for insight notes
            currentInsightId: null,  // Currently open insight ID
            currentInsightData: null,  // Full insight data for editing
            createInsightContext: null,  // Context data for creating new insight
            navigationStack: [],  // Navigation stack: [{level, data, view}], levels: 'insight', 'chart', 'verbatims'
            dataSourceNameCache: {},  // Cache for data source names: {dataSourceId: name}
            currentChartCategoryName: null,  // Current chart view category
            currentChartTopicName: null,  // Current chart view topic (if any)
            currentChartDataSourceId: null,  // Current chart view data source
            currentChartDimensionName: null,  // Current chart view dimension
            
            init() {
                const tab = document.getElementById('slideoutTab');
                const panel = document.getElementById('slideoutPanel');
                const closeBtn = document.getElementById('closeSlideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const expandBtn = document.getElementById('slideoutExpandButton');
                
                if (!tab || !panel) return;
                
                // Ensure tab is hidden initially
                tab.style.display = 'none';
                
                // Open on tab click
                tab.addEventListener('click', () => this.openAIInsights());
                
                // Close handlers
                if (closeBtn) closeBtn.addEventListener('click', () => this.close());
                if (overlay) overlay.addEventListener('click', () => this.close());
                
                // Expand button handler
                if (expandBtn) {
                    expandBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.handleExpandToggle();
                    });
                }
                
                // ESC key to close
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.close();
                    }
                });
                
                console.log('Slideout Panel initialized');
            },
            
            handleExpandToggle() {
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                
                if (!panel) return;
                
                const isExpanded = panel.classList.contains('expanded');
                const SLIDEOUT_DEFAULT_WIDTH = '500px';
                const SLIDEOUT_EXPANDED_WIDTH = '50vw';
                
                if (isExpanded) {
                    // Collapse to default width
                    panel.classList.remove('expanded');
                    if (overlay) {
                        overlay.style.width = SLIDEOUT_DEFAULT_WIDTH;
                    }
                } else {
                    // Expand to viewport width
                    panel.classList.add('expanded');
                    if (overlay) {
                        overlay.style.width = SLIDEOUT_EXPANDED_WIDTH;
                    }
                }
            },
            
            setCurrentDimension(dimensionRef) {
                this.currentDimensionRef = dimensionRef;
                console.log('Current dimension set to:', dimensionRef);
                
                // Show/hide the AI Insights tab based on whether a dimension is selected
                // TEMPORARILY DISABLED: Tab hidden until further notice
                const tab = document.getElementById('slideoutTab');
                if (tab) {
                    // Always keep tab hidden
                    tab.style.display = 'none';
                    // Close the panel if it's open, but NOT if we're viewing history
                    // History mode should persist even when dimensions change
                    if (this.currentMode !== 'history') {
                        this.close();
                    }
                }
            },
            
            async openAIInsights() {
                // Get current context from the app state
                const clientSelect = document.getElementById('clientSelect');
                const client_uuid = clientSelect?.value;
                
                // Get data source (look for active project/source)
                const data_source = this.getCurrentDataSource();
                const dimension_ref = this.currentDimensionRef;
                
                if (!client_uuid) {
                    alert('Please select a client first');
                    return;
                }
                
                if (!dimension_ref) {
                    alert('Please select a dimension first by clicking on a treemap section');
                    return;
                }
                
                this.currentContext = { client_uuid, data_source, dimension_ref };
                this.currentMode = 'ai-insights';
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                
                // For AI insights mode, keep title as h2 (not editable)
                if (title) {
                    title.textContent = 'AI-Generated Insights';
                    // Remove contenteditable if it was set
                    title.removeAttribute('contenteditable');
                    title.setAttribute('data-placeholder', '');
                }
                if (panel) panel.classList.add('open');
                if (overlay) overlay.classList.add('visible');
                this.isOpen = true;
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Load content
                await this.loadSummary();
            },
            
            openVerbatims(verbatims, topicName, categoryName, skipUIUpdates = false, skipStackPush = false) {
                console.log('[BreadcrumbNav] SlideoutPanel.openVerbatims called with:', { 
                    verbatimsCount: verbatims?.length, 
                    topicName, 
                    categoryName,
                    firstVerbatim: verbatims?.[0],
                    currentMode: this.currentMode,
                    skipUIUpdates,
                    skipStackPush
                });
                
                // Save current state to navigation stack if not already in verbatims mode and not skipped
                if (!skipStackPush && this.currentMode !== 'verbatims') {
                    if (this.currentMode === 'chart') {
                        // Save chart state
                        this.navigationStack.push({
                            level: 'chart',
                            data: { 
                                categoryName: categoryName || null,
                                topicName: topicName || null
                            },
                            view: 'chart'
                        });
                        console.log('[BreadcrumbNav] Pushed chart state to stack');
                    } else if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                        // Save insight state
                        this.navigationStack.push({
                            level: 'insight',
                            data: { insightId: this.currentInsightId },
                            view: 'insight'
                        });
                        console.log('[BreadcrumbNav] Pushed insight state to stack');
                    }
                }
                
                this.currentMode = 'verbatims';
                this.currentVerbatimsData = verbatims;
                this.currentTopicName = topicName;
                this.currentCategoryName = categoryName;
                this.verbatimSearchTerm = '';
                
                // Update UI (unless already updated by caller)
                if (!skipUIUpdates) {
                    // Open UI
                    const panel = document.getElementById('slideoutPanel');
                    const overlay = document.getElementById('slideoutOverlay');
                    const title = document.getElementById('slideoutTitle');
                    const subtitle = document.getElementById('slideoutSubtitle');
                    const searchBox = document.getElementById('slideoutSearch');
                    const settingsBtn = document.getElementById('slideoutSettingsBtn');
                    
                    // Show search and settings for verbatims
                    if (searchBox) {
                        searchBox.style.display = 'block';
                        // Also show the wrapper div that contains the search box
                        const searchContainer = document.getElementById('slideoutSearchContainer');
                        if (searchContainer) {
                            searchContainer.style.display = 'block';
                        }
                    }
                    if (settingsBtn) settingsBtn.style.display = 'block';
                    
                    // For verbatims mode, keep title as h2 (not editable)
                    if (title) {
                        title.textContent = topicName || categoryName || 'Verbatims';
                        // Remove contenteditable if it was set
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    if (subtitle) {
                        subtitle.textContent = `${categoryName || ''}  ${verbatims.length} verbatim${verbatims.length !== 1 ? 's' : ''}`;
                        subtitle.style.display = 'block';
                    }
                    
                    // Update back button
                    this.updateBackButton();
                    
                    if (panel) panel.classList.add('open');
                    if (overlay) overlay.classList.add('visible');
                    this.isOpen = true;
                    
                    // Prevent body scroll
                    document.body.classList.add('slideout-open');
                    
                    // Update search bar z-index when slideout opens
                    if (typeof updateTreemapSearchZIndex === 'function') {
                        updateTreemapSearchZIndex();
                    }
                }
                
                // Render verbatims
                this.renderVerbatims(verbatims, topicName, categoryName);
            },
            
            async openCreateInsight(contextData, fromContextMenu = false) {
                console.log('[SlideoutPanel.openCreateInsight] Called with contextData:', contextData);
                console.log('[SlideoutPanel.openCreateInsight] currentClientId:', currentClientId);
                console.log('[SlideoutPanel.openCreateInsight] fromContextMenu:', fromContextMenu);
                
                if (!currentClientId) {
                    console.error('[SlideoutPanel.openCreateInsight] No client selected');
                    return;
                }
                
                // Reset navigation stack when creating new insight
                this.navigationStack = [];
                this.updateBackButton();
                
                this.currentMode = 'create-insight';
                this.createInsightContext = contextData;
                this.currentInsightId = null; // No existing insight
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const content = document.getElementById('slideoutContent');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                
                console.log('[SlideoutPanel.openCreateInsight] UI elements:', {
                    panel: !!panel,
                    overlay: !!overlay,
                    title: !!title,
                    subtitle: !!subtitle,
                    content: !!content,
                    searchBox: !!searchBox,
                    settingsBtn: !!settingsBtn
                });
                
                // Hide search and settings (only for verbatims)
                if (searchBox) {
                    searchBox.style.display = 'none';
                    // Also hide the wrapper div that contains the search box to remove unnecessary spacing
                    const searchContainer = document.getElementById('slideoutSearchContainer');
                    if (searchContainer) {
                        searchContainer.style.display = 'none';
                    }
                }
                if (settingsBtn) settingsBtn.style.display = 'none';
                if (subtitle) subtitle.style.display = 'none';
                
                // Set editable title in header (empty for new insight)
                if (title) {
                    title.textContent = '';
                    title.setAttribute('data-placeholder', 'New Insight');
                    title.setAttribute('contenteditable', 'true');
                }
                
                if (panel) {
                    console.log('[SlideoutPanel.openCreateInsight] Adding "open" class to panel');
                    panel.classList.add('open');
                    console.log('[SlideoutPanel.openCreateInsight] Panel classes after adding open:', panel.classList.toString());
                } else {
                    console.error('[SlideoutPanel.openCreateInsight] Panel element not found!');
                }
                
                if (overlay) {
                    console.log('[SlideoutPanel.openCreateInsight] Adding "visible" class to overlay');
                    overlay.classList.add('visible');
                } else {
                    console.error('[SlideoutPanel.openCreateInsight] Overlay element not found!');
                }
                
                this.isOpen = true;
                
                // Focus the title input after panel is opened
                if (title) {
                    setTimeout(() => {
                        title.focus();
                    }, 100);
                }
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                console.log('[SlideoutPanel.openCreateInsight] Body classes:', document.body.classList.toString());
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Initialize panel with empty form, pre-populated with context
                console.log('[SlideoutPanel.openCreateInsight] Calling initializeCreateInsightPanel');
                await this.initializeCreateInsightPanel(content, contextData, fromContextMenu);
                console.log('[SlideoutPanel.openCreateInsight] Panel initialization complete');
            },
            
            async openInsightNotes(insightId) {
                if (!currentClientId) {
                    console.error('No client selected');
                    return;
                }
                
                this.currentMode = 'insight-notes';
                this.currentInsightId = insightId;
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const content = document.getElementById('slideoutContent');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                
                // Hide search and settings (only for verbatims)
                if (searchBox) searchBox.style.display = 'none';
                const searchContainer = document.getElementById('slideoutSearchContainer');
                if (searchContainer) searchContainer.style.display = 'none';
                if (settingsBtn) settingsBtn.style.display = 'none';
                if (subtitle) subtitle.style.display = 'none';
                
                if (panel) panel.classList.add('open');
                if (overlay) overlay.classList.add('visible');
                this.isOpen = true;
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Load insight data
                try {
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${insightId}`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to load insight');
                    }
                    
                    const insight = await response.json();
                    this.currentInsightData = insight; // Store full insight data
                    
                    // Hide title in header, we'll show it in content
                    if (title) title.textContent = '';
                    
                    // Initialize panel with attributes and editor
                    await this.initializeInsightPanel(content, insight);
                    
                    // Remove transitioning class from all elements (for smooth fade-in)
                    const updatedContent = document.getElementById('slideoutContent');
                    const updatedTitle = document.getElementById('slideoutTitle');
                    const updatedSubtitle = document.getElementById('slideoutSubtitle');
                    const updatedSearchBox = document.getElementById('slideoutSearch');
                    const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                    
                    if (updatedContent) {
                        void updatedContent.offsetHeight;
                        updatedContent.classList.remove('transitioning');
                    }
                    if (updatedTitle) {
                        void updatedTitle.offsetHeight;
                        updatedTitle.classList.remove('transitioning');
                    }
                    if (updatedSubtitle) {
                        void updatedSubtitle.offsetHeight;
                        updatedSubtitle.classList.remove('transitioning');
                    }
                    if (updatedSearchBox) {
                        void updatedSearchBox.offsetHeight;
                        updatedSearchBox.classList.remove('transitioning');
                    }
                    if (updatedSettingsBtn) {
                        void updatedSettingsBtn.offsetHeight;
                        updatedSettingsBtn.classList.remove('transitioning');
                    }
                } catch (error) {
                    console.error('Error loading insight:', error);
                    if (content) {
                        content.innerHTML = `<div style="padding: 24px; color: #666;">Error loading insight: ${error.message}</div>`;
                    }
                    // Remove transitioning from all elements even on error
                    const allElements = [content, title, subtitle, searchBox, settingsBtn].filter(Boolean);
                    allElements.forEach(el => {
                        void el.offsetHeight;
                        el.classList.remove('transitioning');
                    });
                }
            },
            
            // Helper function to get verbatims from context data
            getVerbatimsFromContext(contextData) {
                if (!contextData || !hierarchyData) return [];
                
                const categoryName = contextData.category;
                const topicName = contextData.topic_label;
                const type = contextData.type;
                
                if (!categoryName) return [];
                
                // Find the category in hierarchy
                const categoryData = findCategoryInHierarchy(categoryName);
                if (!categoryData) return [];
                
                // If it's a topic, get verbatims from that specific topic
                if (type === 'topic' && topicName) {
                    const topicData = findTopicInCategory(categoryData, topicName);
                    if (topicData && topicData.verbatims) {
                        return topicData.verbatims;
                    }
                }
                
                // If it's a category, get all verbatims from that category
                if (type === 'category') {
                    return collectCategoryVerbatims(categoryData);
                }
                
                return [];
            },
            
            async initializeCreateInsightPanel(container, contextData, fromContextMenu = false) {
                console.log('[initializeCreateInsightPanel] Called');
                console.log('[initializeCreateInsightPanel] Container:', container);
                console.log('[initializeCreateInsightPanel] ContextData:', contextData);
                console.log('[initializeCreateInsightPanel] fromContextMenu:', fromContextMenu);
                
                if (!container) {
                    console.error('[initializeCreateInsightPanel] Container is null or undefined!');
                    return;
                }
                
                // Build origin object from context data
                // Map 'type' field to 'origin_type' (contextData.type is 'category' or 'topic')
                const origin = {
                    origin_type: contextData.type || contextData.origin_type || 'category',
                    process_voc_id: contextData.process_voc_id || null,
                    project_name: contextData.project_name || null,
                    data_source: contextData.data_source || null,
                    dimension_ref: contextData.dimension_ref || null,
                    dimension_name: contextData.dimension_name || null,
                    category: contextData.category || null,
                    topic_label: contextData.topic_label || null,
                };
                
                // Extract breadcrumb data from context data
                const categoryName = contextData.category || null;
                const topicName = contextData.topic_label || null;
                const dataSourceName = contextData.data_source || null; // This is the name, not ID in contextData
                const dimensionName = contextData.dimension_name || null;
                const dimensionRef = contextData.dimension_ref || null;
                
                console.log('[BreadcrumbNav] initializeCreateInsightPanel - Extracted breadcrumb data:', { categoryName, topicName, dataSourceName, dimensionName, dimensionRef });
                
                // Get verbatims for this context
                let availableVerbatims = this.getVerbatimsFromContext(contextData);
                
                // Check if there's a pre-pinned verbatim to add
                if (this.prePinnedVerbatim) {
                    // Find the verbatim in availableVerbatims by matching text and index
                    const prePinnedIndex = availableVerbatims.findIndex(v => {
                        const textMatch = v.text === this.prePinnedVerbatim.text;
                        const indexMatch = (v.index !== undefined && this.prePinnedVerbatim.index !== undefined) 
                            ? v.index === this.prePinnedVerbatim.index 
                            : true; // If index not available, just match by text
                        return textMatch && indexMatch;
                    });
                    
                    if (prePinnedIndex >= 0) {
                        // Found in available verbatims, store index to pin it
                        this.prePinnedVerbatimIndex = prePinnedIndex;
                    } else {
                        // Not found in available verbatims, add it to the list
                        availableVerbatims.push(this.prePinnedVerbatim);
                        this.prePinnedVerbatimIndex = availableVerbatims.length - 1;
                    }
                } else {
                    this.prePinnedVerbatimIndex = null;
                }
                
                // Build breadcrumb HTML with pill format (matching insights list)
                const breadcrumbParts = [];
                if (dataSourceName) {
                    const pascalDataSource = toPascalCase(dataSourceName);
                    breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDataSource)}</span>`);
                }
                if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    // Make dimension clickable if we have dimension_ref
                    if (dimensionRef) {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill" data-breadcrumb-click="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtml(dimensionName)}" style="cursor: pointer;">${escapeHtml(pascalDimension)}</span>`);
                    } else {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDimension)}</span>`);
                    }
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    // For create mode, we don't have data source ID yet, so we'll pass the name
                    breadcrumbParts.push(`<span class="tag tag-category insight-origin-pill" data-breadcrumb-click="category" data-category="${escapeHtml(categoryName)}" data-topic="${topicName ? escapeHtml(topicName) : ''}" data-data-source-name="${dataSourceName || ''}" data-dimension="${dimensionName || ''}" style="cursor: pointer;">${escapeHtml(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    breadcrumbParts.push(`<span class="tag tag-topic insight-origin-pill" data-breadcrumb-click="topic" data-category="${categoryName ? escapeHtml(categoryName) : ''}" data-topic="${escapeHtml(topicName)}" data-data-source-name="${dataSourceName || ''}" data-dimension="${dimensionName || ''}" style="cursor: pointer;">${escapeHtml(pascalTopic)}</span>`);
                }
                
                const breadcrumbHTML = breadcrumbParts.length > 0 
                    ? breadcrumbParts.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '';
                
                console.log('[BreadcrumbNav] initializeCreateInsightPanel - Generated breadcrumb HTML');
                
                // Create panel structure with attributes (title is now in header)
                // Use flexbox layout with scrollable content and fixed footer
                // Adjust padding and gap when opened from context menu to reduce whitespace
                const attributesPadding = fromContextMenu ? '0.5rem 1.5rem 0.75rem 1.5rem' : '1rem 1.5rem';
                const attributesGap = fromContextMenu ? '0.5rem' : '0.75rem';
                const hasBreadcrumb = breadcrumbHTML && !fromContextMenu;
                container.innerHTML = `
                    <div style="padding: 0; display: flex; flex-direction: column; height: 100%;">
                        <!-- Scrollable Content Area -->
                        <div style="flex: 1; overflow-y: auto; display: flex; flex-direction: column;">
                            <!-- Attributes Section - Only show if there's breadcrumb content -->
                            ${hasBreadcrumb ? `
                            <div style="padding: ${attributesPadding}; border-bottom: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div id="insightAttributes" style="display: flex; flex-direction: column; gap: ${attributesGap};">
                                    <!-- Breadcrumb -->
                                    <div class="insight-attribute-row">
                                        <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 500; color: oklch(0.556 0 0); flex-shrink: 0;">Origin</div>
                                        <div style="flex: 1;">
                                            ${breadcrumbHTML}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                            
                            <!-- Notes Section -->
                            <div style="padding: 1.5rem; flex-shrink: 0; border-top: none;">
                                <div id="insightNotesSaveStatus" style="font-size: 0.75rem; font-family: 'Lato', sans-serif; color: oklch(0.556 0 0); margin-bottom: 0.5rem; min-height: 1rem;"></div>
                                <div id="insightNotesEditor" style="min-height: 200px; outline: none; font-size: 0.875rem; font-family: 'Lato', sans-serif; line-height: 1.5; color: oklch(0.145 0 0);"></div>
                            </div>
                            
                            <!-- Verbatims Section -->
                            <div style="padding: 1.5rem; border-top: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 600; color: oklch(0.145 0 0); margin-bottom: 0.75rem;">
                                    Verbatims (${availableVerbatims.length})
                                </div>
                                <div id="insightVerbatimsList" style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;">
                                    <!-- Verbatims will be rendered here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Fixed Footer with Save Button -->
                        <div style="padding: 1rem 1.5rem; border-top: 1px solid oklch(0.922 0 0); background: oklch(0.98 0 0); display: flex; justify-content: flex-end; flex-shrink: 0; position: sticky; bottom: 0;">
                            <button id="saveNewInsightBtn" style="background: #B9F040; color: #000; border: none; padding: 0.5rem 1.5rem; border-radius: 0.5rem; font-weight: 600; font-size: 0.875rem; font-family: 'Lato', sans-serif; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#a0d636'" onmouseout="this.style.background='#B9F040'">
                                Create Insight
                            </button>
                        </div>
                    </div>
                `;
                
                // Store available verbatims and initialize pinned verbatims set
                this.availableVerbatims = availableVerbatims;
                this.pinnedVerbatims = new Set();
                
                // Pre-pin the verbatim if it was provided
                if (this.prePinnedVerbatimIndex !== null && this.prePinnedVerbatimIndex !== undefined) {
                    this.pinnedVerbatims.add(this.prePinnedVerbatimIndex);
                }
                
                // Clear the pre-pinned verbatim after using it
                this.prePinnedVerbatim = null;
                this.prePinnedVerbatimIndex = null;
                
                // Store origin for saving
                this.createInsightOrigin = origin;
                
                // Set up editable title in header (no auto-save in create mode)
                const titleEl = document.getElementById('slideoutTitle');
                if (titleEl) {
                    titleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            titleEl.blur();
                        }
                    });
                }
                
                // Set up save button
                const saveBtn = document.getElementById('saveNewInsightBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => {
                        this.saveNewInsight();
                    });
                }
                
                // Set up breadcrumb click handlers
                const breadcrumbClickItems = container.querySelectorAll('[data-breadcrumb-click]');
                breadcrumbClickItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        const clickType = item.getAttribute('data-breadcrumb-click');
                        const catName = item.getAttribute('data-category') || null;
                        const topName = item.getAttribute('data-topic') || null;
                        const dsName = item.getAttribute('data-data-source-name') || null;
                        const dimName = item.getAttribute('data-dimension') || null;
                        const dimRef = item.getAttribute('data-dimension-ref') || null;
                        
                        console.log('[BreadcrumbNav] initializeCreateInsightPanel - Breadcrumb clicked:', { clickType, catName, topName, dsName, dimName, dimRef });
                        
                        if (clickType === 'dimension' && dimRef) {
                            // Dimension click: navigate to visualizations and filter by dimension
                            navigateToView('visualizations');
                            
                            // Set the dimension selector to the clicked dimension
                            const questionSelect = document.getElementById('questionSelect');
                            if (questionSelect) {
                                const previousRefKey = currentQuestionRefKey;
                                questionSelect.value = dimRef;
                                currentQuestionRefKey = dimRef;
                                
                                // Filter by this dimension (this will reload charts/data in the background)
                                filterByQuestion(dimRef, previousRefKey);
                                
                                // Update navigation links
                                updateNavLinks();
                                
                                // Update AI Insights panel with current dimension
                                if (window.AIInsightsPanel) {
                                    window.AIInsightsPanel.setCurrentDimension(dimRef);
                                }
                                
                                // Re-render insights table so pinning updates for the new dimension
                                if (typeof renderInsights === 'function') {
                                    renderInsights();
                                }
                            }
                        } else if (clickType === 'category' || clickType === 'topic') {
                            // For create mode, we need to find the data source ID from the name
                            // We'll navigate to chart view, and it should work with current rawData
                            this.navigateToChart(catName, topName, null, dimName);
                        }
                    });
                });
                
                // Initialize editor with empty notes
                await this.initializeInsightEditor(document.getElementById('insightNotesEditor'), '');
                
                // Render verbatims list
                this.renderVerbatimsList();
            },
            
            // Render verbatims list with pin icons
            renderVerbatimsList() {
                const container = document.getElementById('insightVerbatimsList');
                if (!container) return;
                
                if (!this.availableVerbatims || this.availableVerbatims.length === 0) {
                    container.innerHTML = '<div style="padding: 1rem; text-align: center; color: oklch(0.556 0 0); font-size: 0.875rem; font-family: \'Lato\', sans-serif;">No verbatims available</div>';
                    return;
                }
                
                container.innerHTML = this.availableVerbatims.map((verbatim, index) => {
                    const isPinned = this.pinnedVerbatims.has(index);
                    const verbatimText = escapeHtml((verbatim.text || '').substring(0, 200)) + (verbatim.text && verbatim.text.length > 200 ? '...' : '');
                    
                    return `
                        <div class="insight-verbatim-item" data-index="${index}" style="
                            display: flex;
                            align-items: flex-start;
                            gap: 0.75rem;
                            padding: 0.75rem;
                            border: 1px solid oklch(0.922 0 0);
                            border-radius: 0.5rem;
                            background: ${isPinned ? 'oklch(0.98 0.02 120)' : 'oklch(1 0 0)'};
                            transition: all 0.2s ease;
                            cursor: pointer;
                        " onmouseover="this.style.borderColor='oklch(0.8 0 0)'" onmouseout="this.style.borderColor='oklch(0.922 0 0)'">
                            <div style="flex: 1; font-size: 0.875rem; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); line-height: 1.5;">
                                ${verbatimText}
                            </div>
                            <button class="verbatim-pin-btn" data-index="${index}" style="
                                background: none;
                                border: none;
                                cursor: pointer;
                                padding: 0.25rem;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                flex-shrink: 0;
                                color: ${isPinned ? '#B9F040' : 'oklch(0.556 0 0)'};
                                transition: all 0.2s ease;
                            " onclick="event.stopPropagation(); SlideoutPanel.togglePinVerbatim(${index})" title="${isPinned ? 'Unpin verbatim' : 'Pin verbatim'}">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="${isPinned ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M8 2v12M5 6l3-4 3 4"/>
                                    ${isPinned ? '<circle cx="8" cy="6" r="1.5" fill="currentColor"/>' : ''}
                                </svg>
                            </button>
                        </div>
                    `;
                }).join('');
            },
            
            // Toggle pin state for a verbatim
            togglePinVerbatim(index) {
                if (this.pinnedVerbatims.has(index)) {
                    this.pinnedVerbatims.delete(index);
                } else {
                    this.pinnedVerbatims.add(index);
                }
                // Re-render to update visual state
                this.renderVerbatimsList();
            },
            
            async openAIExpertInsight(contextData, promptId, useFullAggregatedData = false) {
                console.log('[openAIExpertInsight] Called with contextData:', contextData, 'promptId:', promptId, 'useFullAggregatedData:', useFullAggregatedData);
                
                if (!currentClientId) {
                    alert('No client selected');
                    return;
                }
                
                if (!window.ClientPromptAPI) {
                    alert('Error: Client prompt API not loaded');
                    return;
                }
                
                const renderer = await getPromptRendererWithRetry();
                if (!renderer) {
                    alert('Error: Prompt rendering modules not loaded. Please check the browser console for details and refresh the page.');
                    return;
                }
                
                console.log('[openAIExpertInsight] Using renderer:', renderer.constructor?.name || 'object');
                
                let cleanVerbatims = [];
                let vocDataForAPI = null;
                
                if (useFullAggregatedData) {
                    // Use full aggregated VOC JSON (same as AI Overview)
                    if (!hierarchyData || !hierarchyData.children || hierarchyData.children.length === 0) {
                        alert('No visualization data available. Please load data first.');
                        return;
                    }
                    
                    // Build aggregated summary and extract all verbatims
                    cleanVerbatims = extractVerbatimsFromAggregatedSummary();
                    if (cleanVerbatims.length === 0) {
                        alert('No verbatims available in the aggregated data.');
                        return;
                    }
                    
                    // Wrap in object to satisfy backend schema (voc_data must be a dict, not array)
                    vocDataForAPI = { verbatims: cleanVerbatims };
                    
                    // Store cleaned vocData for later use when saving insight
                    this.currentVocData = cleanVerbatims;
                } else {
                    // Use context-specific data (existing behavior)
                    if (!contextData) {
                        alert('Error: No context data provided.');
                        return;
                    }
                    
                    // Get JSON data for the context
                    const fullData = getFullDataForContext(contextData);
                    if (!fullData) {
                        alert('Error: Unable to retrieve data. Please try right-clicking again.');
                        return;
                    }
                    
                    // Extract clean verbatims (text and id only) for use in system prompts
                    cleanVerbatims = extractCleanVerbatims(fullData);
                    
                    // Wrap in object to satisfy backend schema (voc_data must be a dict, not array)
                    vocDataForAPI = { verbatims: cleanVerbatims };
                    
                    // Store cleaned vocData for later use when saving insight
                    this.currentVocData = cleanVerbatims;
                }
                
                // Get prompt name for display
                let promptName = 'AI Expert';
                try {
                    const prompts = await window.ClientPromptAPI.listPrompts(currentClientId);
                    const prompt = prompts.find(p => p.id === promptId);
                    if (prompt && prompt.name) {
                        const name = prompt.name;
                        // Common marketing abbreviations to keep in uppercase
                        const abbreviations = ['SEO', 'CRO', 'UX', 'UI', 'API', 'CRM', 'CMS', 'CTA', 'ROI', 'KPI', 'A/B', 'AB', 'PPC', 'SEM', 'SERP', 'SaaS', 'B2B', 'B2C', 'GDPR', 'CTA', 'LTV', 'CAC', 'MVP', 'FAQ', 'URL', 'HTML', 'CSS', 'JS', 'JSON', 'XML', 'REST', 'HTTP', 'HTTPS', 'SSL', 'TLS', 'CDN', 'DNS', 'IP', 'PDF', 'CSV', 'XLS', 'XLSX'];
                        
                        // Replace underscores and hyphens with spaces, then apply Title Case with abbreviation preservation
                        promptName = name
                            .replace(/_/g, ' ')
                            .replace(/-/g, ' ')
                            .split(' ')
                            .map(word => {
                                // Check if word (case-insensitive) matches any abbreviation
                                const upperWord = word.toUpperCase();
                                if (abbreviations.includes(upperWord)) {
                                    return upperWord;
                                }
                                // Apply Title Case
                                return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
                            })
                            .join(' ');
                    }
                } catch (e) {
                    console.warn('[openAIExpertInsight] Failed to fetch prompt name:', e);
                }
                
                // Open slideout in create mode - this sets up the panel structure
                // If using full aggregated data, pass minimal contextData with 'category' as origin_type
                // (since we're at dimension level, similar to AI Overview)
                const contextDataForCreate = useFullAggregatedData ? {
                    type: 'category', // Must be 'verbatim', 'topic', or 'category' - use 'category' for dimension-level
                    origin_type: 'category', // Explicitly set origin_type
                    dimension_ref: currentQuestionRefKey || null,
                    dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                    category: null,
                    topic_label: null,
                    project_name: currentProjectName || null,
                    data_source: currentDataSourceId || null
                } : contextData;
                await this.openCreateInsight(contextDataForCreate, true);
                
                // Wait a bit for the panel to fully initialize
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Get origin from createInsightOrigin (set by openCreateInsight/initializeCreateInsightPanel)
                const origin = this.createInsightOrigin || null;
                
                // Get content container - this is where we'll show streaming
                const content = document.getElementById('slideoutContent');
                if (!content) {
                    console.error('[openAIExpertInsight] Content container not found');
                    return;
                }
                
                // Clear the content area (but keep the panel structure from openCreateInsight)
                // The insight editor is in a separate section, so we can stream into content
                content.innerHTML = '';
                
                // Update title
                const titleEl = document.getElementById('slideoutTitle');
                if (titleEl) {
                    titleEl.textContent = promptName;
                }
                
                // Create streaming result item in the content area
                const streamingItem = renderer.createStreamingResultItem(
                    content,
                    promptName,
                    null, // version
                    '' // user message (not shown in client interface)
                );
                
                if (!streamingItem) {
                    console.error('[openAIExpertInsight] Failed to create streaming item');
                    alert('Error: Failed to initialize streaming display');
                    return;
                }
                
                // Attach idea card listeners immediately so they work during streaming
                // Event delegation means they'll work for idea cards added dynamically
                const slideoutContent = document.getElementById('slideoutContent');
                if (slideoutContent) {
                    if (renderer.attachIdeaCardListeners) {
                        console.log('[openAIExpertInsight] Attaching idea card listeners to slideoutContent', {
                            containerId: slideoutContent.id,
                            hasAttachMethod: !!renderer.attachIdeaCardListeners,
                            timestamp: new Date().toISOString()
                        });
                        renderer.attachIdeaCardListeners(slideoutContent);
                    } else if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                        console.log('[openAIExpertInsight] Attaching idea card listeners via ActionRenderer', {
                            containerId: slideoutContent.id,
                            hasAttachMethod: !!window.ActionRenderer.attachIdeaCardListeners,
                            timestamp: new Date().toISOString()
                        });
                        window.ActionRenderer.attachIdeaCardListeners(slideoutContent);
                    } else {
                        console.warn('[openAIExpertInsight] No attachIdeaCardListeners method available', {
                            hasRenderer: !!renderer,
                            hasActionRenderer: !!window.ActionRenderer
                        });
                    }
                } else {
                    console.warn('[openAIExpertInsight] slideoutContent element not found');
                }
                
                // Start streaming
                try {
                    await window.ClientPromptAPI.executeStream(
                        currentClientId,
                        promptId,
                        vocDataForAPI,
                        // onChunk
                        (chunk) => {
                            renderer.appendToStreamingItem(streamingItem, chunk);
                        },
                        // onDone
                        async (metadata) => {
                            console.log('[openAIExpertInsight] Streaming completed', metadata);
                            renderer.finalizeStreamingItem(streamingItem, metadata);
                            
                            // Note: Idea card listeners were already attached before streaming started
                            // They use event delegation so they work for dynamically added idea cards
                            
                            // Extract content from streaming item
                            const contentElement = streamingItem.querySelector('.prompt-result-content');
                            if (contentElement) {
                                const renderedHTML = contentElement.innerHTML;
                                
                                // Get the editor element and set its content
                                const editorElement = document.getElementById('insightNotesEditor');
                                if (editorElement) {
                                    // Wait for editor to be initialized (with a timeout)
                                    let attempts = 0;
                                    const maxAttempts = 20; // 2 seconds max wait
                                    while (!this.currentInsightEditor && attempts < maxAttempts) {
                                        await new Promise(resolve => setTimeout(resolve, 100));
                                        attempts++;
                                    }
                                    
                                    if (this.currentInsightEditor) {
                                        // Editor is initialized, set content
                                        this.currentInsightEditor.commands.setContent(renderedHTML);
                                    } else {
                                        // Editor not initialized yet, initialize it with content
                                        await this.initializeInsightEditor(editorElement, renderedHTML);
                                    }
                                    
                                    // Remove the streaming item from content (it's now in the editor)
                                    if (streamingItem.parentNode) {
                                        streamingItem.remove();
                                    }
                                } else {
                                    console.warn('[openAIExpertInsight] Editor element not found');
                                }
                            }
                        },
                        // onError
                        (error) => {
                            console.error('[openAIExpertInsight] Streaming error:', error);
                            const contentDiv = streamingItem.querySelector('.prompt-result-content');
                            if (contentDiv) {
                                contentDiv.innerHTML = `<p style="color: oklch(0.577 0.245 27.325);">Error: ${escapeHtml(error.message || 'Unknown error occurred')}</p>`;
                            }
                            renderer.finalizeStreamingItem(streamingItem, {});
                            
                            // Attach idea card listeners even on error (in case partial content was rendered)
                            const slideoutContent = document.getElementById('slideoutContent');
                            if (slideoutContent) {
                                if (renderer.attachIdeaCardListeners) {
                                    renderer.attachIdeaCardListeners(slideoutContent);
                                } else if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                                    window.ActionRenderer.attachIdeaCardListeners(slideoutContent);
                                }
                            }
                        },
                        // origin (optional)
                        origin
                    );
                } catch (error) {
                    console.error('[openAIExpertInsight] Failed to start streaming:', error);
                    alert('Error: ' + (error.message || 'Failed to start AI expert'));
                }
            },

            async saveOverviewAsInsight(notesHTML, summaryPayload) {
                if (!currentClientId) {
                    console.error('[saveOverviewAsInsight] No client selected');
                    return;
                }

                try {
                    // Build insight name from dimension name, stripping leading numbers
                    let dimensionName = currentQuestionRefKey 
                        ? getDimensionDisplayName(currentQuestionRefKey)
                        : 'All Dimensions';
                    
                    // Strip leading numbers and spaces (e.g., "13 Trusted Personalities" -> "Trusted Personalities")
                    dimensionName = dimensionName.replace(/^\d+\s+/, '').trim();
                    
                    const insightName = `Overview: ${dimensionName}`;

                    // Create origin object with only data_source and dimension info
                    const origin = {
                        origin_type: 'category', // Using category as base type since we're at dimension level
                        project_name: currentProjectName || null,
                        data_source: currentDataSourceId || null,
                        dimension_ref: currentQuestionRefKey || null,
                        dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                        category: null,
                        topic_label: null,
                        process_voc_id: null
                    };

                    const insightData = {
                        name: insightName,
                        type: 'Overview',
                        application: 'Executive Summary', // Backend expects comma-separated string
                        notes: notesHTML || null,
                        origins: [origin],
                        verbatims: null,
                        voc_json: summaryPayload
                    };

                    console.log('[saveOverviewAsInsight] Saving insight:', insightData);

                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights`, {
                        method: 'POST',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(insightData)
                    });

                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ detail: 'Failed to create insight' }));
                        throw new Error(error.detail || 'Failed to create insight');
                    }

                    const newInsight = await response.json();
                    this.currentOverviewInsightId = newInsight.id;
                    console.log('[saveOverviewAsInsight] Insight saved with ID:', newInsight.id);

                    // Refresh insights list
                    if (typeof loadInsights === 'function') {
                        loadInsights();
                    }
                } catch (error) {
                    console.error('[saveOverviewAsInsight] Error saving overview insight:', error);
                    // Don't alert user - this is auto-save, just log the error
                }
            },

            async openAIOverviewSummary(summaryPayload, promptId) {
                console.log('[openAIOverviewSummary] Called with promptId:', promptId);

                if (!currentClientId) {
                    alert('No client selected');
                    return;
                }
                if (!window.ClientPromptAPI) {
                    alert('Error: Client prompt API not loaded');
                    return;
                }

                const renderer = await getPromptRendererWithRetry();
                if (!renderer) {
                    alert('Error: Prompt rendering modules not loaded. Please check the browser console for details and refresh the page.');
                    return;
                }

                // Reset navigation stack for overview view
                this.navigationStack = [];
                this.updateBackButton();
                this.currentMode = 'ai-overview';
                this.currentOverviewInsightId = null; // Reset on new overview

                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const content = document.getElementById('slideoutContent');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');

                if (searchBox) searchBox.style.display = 'none';
                const searchContainer = document.getElementById('slideoutSearchContainer');
                if (searchContainer) searchContainer.style.display = 'none';
                if (settingsBtn) settingsBtn.style.display = 'none';
                if (subtitle) subtitle.style.display = 'none';

                if (title) {
                    title.textContent = 'Feedback Overview';
                    title.removeAttribute('contenteditable');
                    title.setAttribute('data-placeholder', '');
                }

                if (panel) panel.classList.add('open');
                if (overlay) overlay.classList.add('visible');
                this.isOpen = true;
                document.body.classList.add('slideout-open');

                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }

                if (!content) {
                    console.error('[openAIOverviewSummary] Content container not found');
                    return;
                }

                content.innerHTML = '';
                const streamingItem = renderer.createStreamingResultItem(
                    content,
                    'Feedback Overview',
                    null,
                    ''
                );

                if (!streamingItem) {
                    console.error('[openAIOverviewSummary] Failed to create streaming item');
                    alert('Error: Failed to initialize streaming display');
                    return;
                }

                // Attach idea card listeners immediately so they work during streaming
                // Event delegation means they'll work for idea cards added dynamically
                const slideoutContentForSummary = document.getElementById('slideoutContent');
                if (slideoutContentForSummary) {
                    if (renderer.attachIdeaCardListeners) {
                        console.log('[openAIOverviewSummary] Attaching idea card listeners to slideoutContent', {
                            containerId: slideoutContentForSummary.id,
                            hasAttachMethod: !!renderer.attachIdeaCardListeners,
                            timestamp: new Date().toISOString()
                        });
                        renderer.attachIdeaCardListeners(slideoutContentForSummary);
                    } else if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                        console.log('[openAIOverviewSummary] Attaching idea card listeners via ActionRenderer', {
                            containerId: slideoutContentForSummary.id,
                            hasAttachMethod: !!window.ActionRenderer.attachIdeaCardListeners,
                            timestamp: new Date().toISOString()
                        });
                        window.ActionRenderer.attachIdeaCardListeners(slideoutContentForSummary);
                    } else {
                        console.warn('[openAIOverviewSummary] No attachIdeaCardListeners method available', {
                            hasRenderer: !!renderer,
                            hasActionRenderer: !!window.ActionRenderer
                        });
                    }
                } else {
                    console.warn('[openAIOverviewSummary] slideoutContent element not found');
                }

                try {
                    await window.ClientPromptAPI.executeStream(
                        currentClientId,
                        promptId,
                        summaryPayload,
                        (chunk) => {
                            renderer.appendToStreamingItem(streamingItem, chunk);
                        },
                        async (metadata) => {
                            console.log('[openAIOverviewSummary] Streaming completed', metadata);
                            renderer.finalizeStreamingItem(streamingItem, metadata);

                            // Note: Idea card listeners were already attached before streaming started
                            // They use event delegation so they work for dynamically added idea cards

                            // Extract HTML content from streaming item
                            const contentElement = streamingItem.querySelector('.prompt-result-content');
                            if (contentElement) {
                                const renderedHTML = contentElement.innerHTML;
                                
                                // Auto-save as insight
                                await this.saveOverviewAsInsight(renderedHTML, summaryPayload);
                            }
                        },
                        (error) => {
                            console.error('[openAIOverviewSummary] Streaming error:', error);
                            const contentDiv = streamingItem.querySelector('.prompt-result-content');
                            if (contentDiv) {
                                contentDiv.innerHTML = `<p style="color: oklch(0.577 0.245 27.325);">Error: ${escapeHtml(error.message || 'Unknown error occurred')}</p>`;
                            }
                            renderer.finalizeStreamingItem(streamingItem, {});

                            const slideoutContent = document.getElementById('slideoutContent');
                            if (slideoutContent) {
                                if (renderer.attachIdeaCardListeners) {
                                    renderer.attachIdeaCardListeners(slideoutContent);
                                } else if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                                    window.ActionRenderer.attachIdeaCardListeners(slideoutContent);
                                }
                            }
                        }
                    );
                } catch (error) {
                    console.error('[openAIOverviewSummary] Failed to start streaming:', error);
                    alert('Error: ' + (error.message || 'Failed to start AI overview'));
                }
            },
            
            async saveNewInsight() {
                if (!currentClientId) {
                    alert('No client selected');
                    return;
                }
                
                const titleEl = document.getElementById('slideoutTitle');
                
                const name = titleEl?.textContent.trim() || '';
                const notes = this.currentInsightEditor ? this.currentInsightEditor.getHTML() : '';
                
                console.log('[saveNewInsight] Notes content:', notes);
                console.log('[saveNewInsight] Notes contains blob URL:', notes.includes('blob:'));
                
                // Check for blob URLs and warn user
                if (notes.includes('blob:')) {
                    console.warn('[saveNewInsight] WARNING: Notes contain blob URLs - images may not persist!');
                    const blobUrlMatch = notes.match(/blob:[^"'\s]+/);
                    if (blobUrlMatch) {
                        console.warn('[saveNewInsight] Blob URL found:', blobUrlMatch[0]);
                    }
                    // Still allow save, but warn user
                    if (!confirm('Warning: Some images are still uploading. They may not appear after saving. Continue anyway?')) {
                        return;
                    }
                }
                
                if (!name || name === 'AI-Generated Insights') {
                    alert('Please enter an insight name');
                    return;
                }
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                if (statusEl) {
                    statusEl.textContent = 'Creating...';
                    statusEl.style.color = 'oklch(0.556 0 0)';
                    statusEl.style.opacity = '1';
                    statusEl.style.pointerEvents = 'auto';
                }
                
                // Collect pinned verbatims
                const pinnedVerbatimsArray = [];
                if (this.pinnedVerbatims && this.availableVerbatims) {
                    this.pinnedVerbatims.forEach(index => {
                        if (this.availableVerbatims[index]) {
                            pinnedVerbatimsArray.push(this.availableVerbatims[index]);
                        }
                    });
                }
                
                // Get voc_json from currentVocData (AI expert) or from createInsightContext (visualization)
                let vocJsonData = null;
                if (this.currentVocData) {
                    // From AI expert response
                    vocJsonData = this.currentVocData;
                } else if (this.createInsightContext && typeof getFullDataForContext === 'function') {
                    // From visualization tab
                    vocJsonData = getFullDataForContext(this.createInsightContext);
                }
                
                try {
                    const insightData = {
                        name: name,
                        type: null,  // Type not available when creating from visualizations view
                        application: null,  // Application not available when creating from visualizations view
                        notes: notes || null,
                        origins: [this.createInsightOrigin],
                        verbatims: pinnedVerbatimsArray.length > 0 ? pinnedVerbatimsArray : null,
                        voc_json: vocJsonData,
                    };
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights`, {
                        method: 'POST',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(insightData)
                    });
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ detail: 'Failed to create insight' }));
                        throw new Error(error.detail || 'Failed to create insight');
                    }
                    
                    const newInsight = await response.json();
                    
                    if (statusEl) {
                        statusEl.textContent = 'Created!';
                        statusEl.style.color = '#B9F040';
                        statusEl.style.opacity = '1';
                        statusEl.style.pointerEvents = 'auto';
                    }
                    
                    // Always refresh insights list so new insight appears when navigating to insights tab
                    // Check if insights section is visible to refresh it immediately
                    const insightsSection = document.getElementById('insights-section');
                    const isInsightsViewActive = insightsSection && insightsSection.classList.contains('active');
                    
                    console.log('[saveNewInsight] Insights section check:', {
                        element: !!insightsSection,
                        isActive: isInsightsViewActive,
                        hasLoadInsightsPage: typeof loadInsightsPage === 'function',
                        hasLoadInsights: typeof loadInsights === 'function'
                    });
                    
                    // Always try to refresh insights page first (for insights tab)
                    if (typeof loadInsightsPage === 'function') {
                        console.log('[saveNewInsight] Refreshing insights list via loadInsightsPage()');
                        loadInsightsPage();
                    }
                    
                    // Also refresh the other insights view if it exists (for compatibility)
                    if (typeof loadInsights === 'function') {
                        console.log('[saveNewInsight] Refreshing insights list via loadInsights()');
                        loadInsights();
                    }
                    
                    // Reset insights initialization flag so it can reload if needed
                    if (window.insightsInitialized) {
                        window.insightsInitialized = false;
                    }
                    
                    // Close panel after a brief delay
                    setTimeout(() => {
                        this.close();
                        // Optionally open the newly created insight
                        // this.openInsightNotes(newInsight.id);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error creating insight:', error);
                    if (statusEl) {
                        statusEl.textContent = 'Error creating';
                        statusEl.style.color = 'oklch(0.577 0.245 27.325)';
                        statusEl.style.opacity = '1';
                        statusEl.style.pointerEvents = 'auto';
                    }
                    alert('Error creating insight: ' + error.message);
                }
            },
            
            async initializeInsightPanel(container, insight) {
                console.log('[BreadcrumbNav] initializeInsightPanel called for insight:', insight.id);
                if (!container) return;
                
                // Reset navigation stack when opening a new insight
                this.navigationStack = [];
                this.updateBackButton();
                
                // Extract breadcrumb data from origins JSONB
                const firstOrigin = insight.origins?.[0] || {};
                const categoryName = firstOrigin.category || null;
                const topicName = firstOrigin.topic_label || null;
                const dataSourceId = firstOrigin.data_source || null;
                const dimensionName = firstOrigin.dimension_name || null;
                const dimensionRef = firstOrigin.dimension_ref || null;
                
                console.log('[BreadcrumbNav] Extracted breadcrumb data:', { categoryName, topicName, dataSourceId, dimensionName, dimensionRef });
                
                // Fetch data source name
                let dataSourceName = null;
                if (dataSourceId) {
                    dataSourceName = await this.fetchDataSourceName(dataSourceId);
                    console.log('[BreadcrumbNav] Fetched data source name:', dataSourceName);
                }
                
                // Set editable title in header
                const insightTitleEl = document.getElementById('slideoutTitle');
                if (insightTitleEl) {
                    insightTitleEl.textContent = toPascalCase(insight.name || '');
                    insightTitleEl.setAttribute('data-placeholder', 'Insight Title');
                    insightTitleEl.setAttribute('contenteditable', 'true');
                }
                
                // Get verbatims from insight
                const insightVerbatims = insight.verbatims || [];
                
                // Build breadcrumb HTML with pill format (matching insights list)
                const breadcrumbParts = [];
                if (dataSourceName) {
                    const pascalDataSource = toPascalCase(dataSourceName);
                    breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDataSource)}</span>`);
                }
                if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    // Make dimension clickable if we have dimension_ref
                    if (dimensionRef) {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill" data-breadcrumb-click="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtml(dimensionName)}" style="cursor: pointer;">${escapeHtml(pascalDimension)}</span>`);
                    } else {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDimension)}</span>`);
                    }
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    breadcrumbParts.push(`<span class="tag tag-category insight-origin-pill" data-breadcrumb-click="category" data-category="${escapeHtml(categoryName)}" data-topic="${topicName ? escapeHtml(topicName) : ''}" data-data-source="${dataSourceId || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" style="cursor: pointer;">${escapeHtml(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    breadcrumbParts.push(`<span class="tag tag-topic insight-origin-pill" data-breadcrumb-click="topic" data-category="${categoryName ? escapeHtml(categoryName) : ''}" data-topic="${escapeHtml(topicName)}" data-data-source="${dataSourceId || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" style="cursor: pointer;">${escapeHtml(pascalTopic)}</span>`);
                }
                
                const breadcrumbHTML = breadcrumbParts.length > 0 
                    ? breadcrumbParts.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '';
                
                console.log('[BreadcrumbNav] Generated breadcrumb HTML');
                
                // Create panel structure with attributes (title is now in header)
                container.innerHTML = `
                    <div style="padding: 0; display: flex; flex-direction: column; height: 100%;">
                        <!-- Scrollable Content Area -->
                        <div style="flex: 1; overflow-y: auto; display: flex; flex-direction: column;">
                            <!-- Attributes Section -->
                            <div style="padding: 1rem 1.5rem; border-bottom: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div id="insightAttributes" style="display: flex; flex-direction: column; gap: 0.75rem;">
                                    <!-- Breadcrumb -->
                                    ${breadcrumbHTML ? `
                                    <div class="insight-attribute-row">
                                        <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 500; color: oklch(0.556 0 0); flex-shrink: 0;">Origin</div>
                                        <div style="flex: 1;">
                                            ${breadcrumbHTML}
                                        </div>
                                    </div>
                                    ` : ''}
                                    
                                </div>
                            </div>
                            
                            <!-- Notes Section -->
                            <div style="padding: 5px 1.5rem 1.5rem 1.5rem; flex-shrink: 0; position: relative;">
                                <div id="insightNotesSaveStatus" style="position: absolute; top: 1.5rem; right: 1.5rem; font-size: 0.75rem; font-family: 'Lato', sans-serif; color: oklch(0.556 0 0); opacity: 0; pointer-events: none; transition: opacity 0.2s ease-in-out; z-index: 10;"></div>
                                <div id="insightNotesEditor" style="min-height: 200px; outline: none; font-size: 0.875rem; font-family: 'Lato', sans-serif; line-height: 1.5; color: oklch(0.145 0 0);"></div>
                            </div>
                            
                            <!-- Verbatims Section (read-only) -->
                            ${insightVerbatims.length > 0 ? `
                            <div style="padding: 1.5rem; border-top: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 600; color: oklch(0.145 0 0); margin-bottom: 0.75rem;">
                                    Pinned Verbatims (${insightVerbatims.length})
                                </div>
                                <div id="insightVerbatimsList" style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;">
                                    ${insightVerbatims.map(verbatim => {
                                        const verbatimText = escapeHtml((verbatim.text || '').substring(0, 200)) + (verbatim.text && verbatim.text.length > 200 ? '...' : '');
                                        return `
                                            <div class="insight-verbatim-item" style="
                                                display: flex;
                                                align-items: flex-start;
                                                gap: 0.75rem;
                                                padding: 0.75rem;
                                                border: 1px solid oklch(0.922 0 0);
                                                border-radius: 0.5rem;
                                                background: oklch(0.98 0.02 120);
                                            ">
                                                <div style="flex: 1; font-size: 0.875rem; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); line-height: 1.5;">
                                                    ${verbatimText}
                                                </div>
                                                <div style="flex-shrink: 0; color: #B9F040; display: flex; align-items: center; justify-content: center; padding: 0.25rem;">
                                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M8 2v12M5 6l3-4 3 4"/>
                                                        <circle cx="8" cy="6" r="2" fill="currentColor"/>
                                                    </svg>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    </div>
                `;
                
                // Set up breadcrumb click handlers
                const breadcrumbClickItems = container.querySelectorAll('[data-breadcrumb-click]');
                breadcrumbClickItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        const clickType = item.getAttribute('data-breadcrumb-click');
                        const catName = item.getAttribute('data-category') || null;
                        const topName = item.getAttribute('data-topic') || null;
                        const dsId = item.getAttribute('data-data-source') || null;
                        const dimName = item.getAttribute('data-dimension') || null;
                        const dimRef = item.getAttribute('data-dimension-ref') || null;
                        
                        console.log('[BreadcrumbNav] Breadcrumb clicked:', { clickType, catName, topName, dsId, dimName, dimRef });
                        
                        if (clickType === 'dimension' && dimRef) {
                            // Dimension click: navigate to visualizations and filter by dimension
                            navigateToView('visualizations');
                            
                            // Set the dimension selector to the clicked dimension
                            const questionSelect = document.getElementById('questionSelect');
                            if (questionSelect) {
                                const previousRefKey = currentQuestionRefKey;
                                questionSelect.value = dimRef;
                                currentQuestionRefKey = dimRef;
                                
                                // Filter by this dimension (this will reload charts/data in the background)
                                filterByQuestion(dimRef, previousRefKey);
                                
                                // Update navigation links
                                updateNavLinks();
                                
                                // Update AI Insights panel with current dimension
                                if (window.AIInsightsPanel) {
                                    window.AIInsightsPanel.setCurrentDimension(dimRef);
                                }
                                
                                // Re-render insights table so pinning updates for the new dimension
                                if (typeof renderInsights === 'function') {
                                    renderInsights();
                                }
                            }
                        } else if (clickType === 'topic' && topName && catName) {
                            // Topic click: go directly to verbatims
                            this.navigateToVerbatimsFromBreadcrumb(topName, catName, dsId, dimRef);
                        } else if (clickType === 'category') {
                            // Category click: go to chart view
                            // Ensure we're in the correct context before navigating
                            ensureContextForInsightNavigation(dsId, dimRef).then(() => {
                                const dimName = dimRef ? getDimensionDisplayName(dimRef) : null;
                                this.navigateToChart(catName, null, dsId, dimName);
                            });
                        }
                    });
                });
                
                // Set up editable title in header (with auto-save for edit mode)
                const headerTitleEl = document.getElementById('slideoutTitle');
                if (headerTitleEl) {
                    headerTitleEl.addEventListener('blur', () => {
                        // Only auto-save if we're in edit mode, not create mode
                        if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                            const newName = headerTitleEl.textContent.trim() || '';
                            if (newName) {
                                this.debouncedSaveInsightField('name', newName);
                            }
                        }
                    });
                    headerTitleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            headerTitleEl.blur();
                        }
                    });
                }
                
                
                // Set up editable application chip (with auto-save for edit mode)
                
                // Initialize editor with notes
                console.log('[initializeInsightPanel] Initializing editor with notes:', insight.notes);
                console.log('[initializeInsightPanel] Notes length:', insight.notes?.length);
                console.log('[initializeInsightPanel] Notes contains img:', insight.notes?.includes('<img'));
                
                // Convert markdown to HTML if needed
                // When insights are saved from streaming, they should already be HTML, but if the saved
                // content contains markdown syntax and isn't already converted HTML, convert it
                let notesContent = insight.notes || '';
                if (notesContent && typeof notesContent === 'string') {
                    // Check if content contains markdown syntax
                    const hasMarkdownSyntax = /(\*\*|__|\*|_|#+\s|```|`|\[.*\]\(.*\))/.test(notesContent);
                    
                    // Check if content is already HTML (has multiple HTML tags)
                    const htmlTagCount = (notesContent.match(/<[^>]+>/g) || []).length;
                    const isAlreadyHTML = htmlTagCount >= 3; // If 3+ HTML tags, likely already converted
                    const hasLiteralNewlines = notesContent.includes('\n'); // Check for literal newlines
                    
                    // If markdown syntax is present but content isn't already HTML, convert it
                    if (hasMarkdownSyntax && !isAlreadyHTML) {
                        console.log('[initializeInsightPanel] Converting markdown to HTML');
                        // Use MarkdownConverter if available (same one used during streaming)
                        if (window.MarkdownConverter && window.MarkdownConverter.convertMarkdown) {
                            notesContent = window.MarkdownConverter.convertMarkdown(notesContent);
                        } else if (this.convertMarkdown) {
                            // Fallback to SlideoutPanel's convertMarkdown
                            notesContent = this.convertMarkdown(notesContent);
                        }
                    }
                    // If content is "already HTML" but has literal newlines, we need to convert those to <br> or <p> tags
                    else if (isAlreadyHTML && hasLiteralNewlines) {
                        console.log('[initializeInsightPanel] Converting literal newlines in HTML content');
                        // Split on double newlines for paragraphs, single newlines for <br>
                        notesContent = notesContent
                            .split(/\n\n+/)
                            .map(block => {
                                const trimmed = block.trim();
                                if (!trimmed) return '';
                                // If block already starts with a block element, return as-is
                                if (trimmed.match(/^<(h[1-6]|ul|ol|pre|li|table|div|p)/)) {
                                    return trimmed;
                                }
                                // Convert single newlines within block to <br>
                                const withBreaks = trimmed.replace(/\n/g, '<br>');
                                return '<p>' + withBreaks + '</p>';
                            })
                            .filter(block => block) // Remove empty blocks
                            .join('');
                    }
                }
                
                try {
                    await this.initializeInsightEditor(document.getElementById('insightNotesEditor'), notesContent);
                    console.log('[initializeInsightPanel] Editor initialization completed');
                } catch (error) {
                    console.error('[initializeInsightPanel] Error initializing editor:', error);
                }
                
                // After editor initialization, check what was parsed
                if (this.currentInsightEditor) {
                    setTimeout(() => {
                        const html = this.currentInsightEditor.getHTML();
                        console.log('[initializeInsightPanel] Editor HTML after initialization:', html);
                        console.log('[initializeInsightPanel] Editor HTML contains img:', html.includes('<img'));
                        const editorElement = document.getElementById('insightNotesEditor');
                        if (editorElement) {
                            const images = editorElement.querySelectorAll('img');
                            console.log('[initializeInsightPanel] Found', images.length, 'img elements in DOM');
                            if (images.length === 0) {
                                console.warn('[initializeInsightPanel]  No images found in DOM!');
                                console.warn('[initializeInsightPanel] Editor element:', editorElement);
                                console.warn('[initializeInsightPanel] Editor element innerHTML:', editorElement.innerHTML.substring(0, 1000));
                            }
                            images.forEach((img, idx) => {
                                console.log(`[initializeInsightPanel] Image ${idx}:`, {
                                    src: img.src,
                                    complete: img.complete,
                                    naturalWidth: img.naturalWidth,
                                    naturalHeight: img.naturalHeight,
                                    onerror: img.onerror
                                });
                            });
                        } else {
                            console.error('[initializeInsightPanel] Editor element not found!');
                        }
                    }, 500);
                } else {
                    console.error('[initializeInsightPanel] Editor not created - currentInsightEditor is null!');
                }
            },
            
            async initializeInsightEditor(editorElement, initialContent) {
                console.log('[initializeInsightEditor] Called with initialContent:', initialContent);
                console.log('[initializeInsightEditor] InitialContent contains img:', initialContent?.includes('<img'));
                console.log('[initializeInsightEditor] InitialContent contains iframe:', initialContent?.includes('<iframe'));
                
                // Clean up existing editor if any
                if (this.currentInsightEditor) {
                    this.currentInsightEditor.destroy();
                    this.currentInsightEditor = null;
                }
                
                // Clean up context menu handlers
                this.cleanupEditorContextMenu();
                
                // Clean up image click handlers
                if (this.imageClickHandler && this.currentEditorElement) {
                    this.currentEditorElement.removeEventListener('click', this.imageClickHandler);
                    this.imageClickHandler = null;
                }
                
                if (!editorElement) return;
                
                // Initialize Tiptap editor using ES modules
                try {
                    // Dynamically import Tiptap modules
                    const { Editor, Extension, Node, mergeAttributes } = await import('https://esm.sh/@tiptap/core@2.1.13');
                    const StarterKitModule = await import('https://esm.sh/@tiptap/starter-kit@2.1.13');
                    const StarterKit = StarterKitModule.default || StarterKitModule;
                    const { TaskList } = await import('https://esm.sh/@tiptap/extension-task-list@2.1.13');
                    const { TaskItem } = await import('https://esm.sh/@tiptap/extension-task-item@2.1.13');
                    const { Image } = await import('https://esm.sh/@tiptap/extension-image@2.1.13');
                    const HighlightModule = await import('https://esm.sh/@tiptap/extension-highlight@2.1.13');
                    console.log('[Highlight Debug] HighlightModule:', HighlightModule);
                    console.log('[Highlight Debug] HighlightModule keys:', Object.keys(HighlightModule));
                    const Highlight = HighlightModule.Highlight || HighlightModule.default;
                    console.log('[Highlight Debug] Highlight extension:', Highlight);
                    console.log('[Highlight Debug] Highlight.name:', Highlight?.name);
                    
                    // Create a custom iframe extension for Loom embeds
                    const Iframe = Node.create({
                        name: 'iframe',
                        group: 'block',
                        atom: true,
                        addAttributes() {
                            return {
                                src: {
                                    default: null,
                                },
                                width: {
                                    default: '100%',
                                },
                                height: {
                                    default: '500px',
                                },
                                frameborder: {
                                    default: '0',
                                },
                                allowfullscreen: {
                                    default: true,
                                },
                                style: {
                                    default: 'width: 100%; border-radius: 0.5rem; aspect-ratio: 16/9; margin: 1rem 0; border: none;',
                                },
                            };
                        },
                        parseHTML() {
                            return [{
                                tag: 'iframe',
                            }];
                        },
                        renderHTML({ HTMLAttributes }) {
                            return ['iframe', mergeAttributes(HTMLAttributes)];
                        },
                    });
                    
                    // Store reference to this for use in handlers
                    const self = this;
                    
                    // Function to insert image/video immediately and upload in background
                    const insertAndUploadMedia = async (file, isVideo = false) => {
                        const objectURL = URL.createObjectURL(file);
                        const editor = self.currentInsightEditor;
                        
                        // Insert immediately with object URL
                        if (isVideo) {
                            console.log('[insertAndUploadMedia] Inserting video with object URL');
                            editor.chain().focus().insertContent(`<video src="${objectURL}" controls width="100%" style="max-width: 100%; height: auto; border-radius: 0.5rem; margin: 1rem 0;"></video>`).run();
                        } else {
                            console.log('[insertAndUploadMedia] Inserting image with object URL');
                            editor.chain().focus().setImage({ src: objectURL }).run();
                            console.log('[insertAndUploadMedia] Image inserted, current HTML:', editor.getHTML());
                        }
                        
                        // Upload in background and replace URL when done
                        try {
                            const permanentURL = await uploadMediaToBlob(file);
                            
                            // Use Tiptap's transaction API to find and update the image node
                            const { state } = editor.view;
                            const { tr } = state;
                            
                            let foundImage = false;
                            
                            // Find the image node with the object URL and update it
                            tr.doc.descendants((node, pos) => {
                                if (node.type.name === 'image' && node.attrs.src === objectURL) {
                                    tr.setNodeMarkup(pos, undefined, { ...node.attrs, src: permanentURL });
                                    foundImage = true;
                                }
                            });
                            
                            // Handle videos (which are raw HTML)
                            if (isVideo) {
                                const currentHTML = editor.getHTML();
                                const escapedObjectURL = objectURL.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                const updatedHTML = currentHTML.replace(new RegExp(escapedObjectURL, 'g'), permanentURL);
                                editor.commands.setContent(updatedHTML, false);
                            } else {
                                // For images, use the transaction
                                if (foundImage) {
                                    editor.view.dispatch(tr);
                                } else {
                                    // Fallback: try HTML replacement
                                    const currentHTML = editor.getHTML();
                                    const escapedObjectURL = objectURL.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    const updatedHTML = currentHTML.replace(new RegExp(escapedObjectURL, 'g'), permanentURL);
                                    editor.commands.setContent(updatedHTML, false);
                                }
                            }
                            
                            URL.revokeObjectURL(objectURL);
                        } catch (error) {
                            console.error('Error uploading media:', error);
                        }
                    };
                    
                    this.currentInsightEditor = new Editor({
                        element: editorElement,
                        extensions: [
                            StarterKit,
                            TaskList,
                            TaskItem.configure({
                                nested: true,
                            }),
                            Image.configure({
                                inline: true,
                                allowBase64: false,
                                HTMLAttributes: {
                                    class: 'insight-image',
                                },
                            }),
                            (() => {
                                const configuredHighlight = Highlight.configure({
                                    HTMLAttributes: {
                                        class: 'highlight-brand',
                                    },
                                });
                                console.log('[Highlight Debug] Configured Highlight extension:', configuredHighlight);
                                console.log('[Highlight Debug] Configured options:', configuredHighlight?.options);
                                return configuredHighlight;
                            })(),
                            Iframe,
                        ],
                        content: initialContent || '', // Set content directly in constructor
                        editorProps: {
                            attributes: {
                                class: 'prose prose-sm max-w-none focus:outline-none',
                                style: 'min-height: 400px;'
                            },
                            handlePaste: (view, event, slice) => {
                                console.log('[Editor Setup] Paste handler called for self.currentInsightEditor');
                                const handler = createMediaPasteHandler(() => {
                                    console.log('[Editor Setup] Getting editor, current value:', self.currentInsightEditor);
                                    return self.currentInsightEditor;
                                }, insertAndUploadMedia);
                                return handler(view, event, slice);
                            },
                            handleDrop: createMediaDropHandler(insertAndUploadMedia)
                        },
                        onUpdate: ({ editor }) => {
                            // Only auto-save if we're in edit mode, not create mode
                            if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                                const html = editor.getHTML();
                                console.log('[onUpdate] Editor updated, mode:', this.currentMode, 'insightId:', this.currentInsightId);
                                console.log('[onUpdate] HTML content:', html);
                                console.log('[onUpdate] HTML contains img tags:', html.includes('<img'));
                                
                                // Check for blob URLs - warn if found
                                if (html.includes('blob:')) {
                                    console.warn('[onUpdate] WARNING: HTML contains blob URLs - these will not persist!', html);
                                }
                                
                                this.debouncedSaveInsightNotes(this.currentInsightId, html);
                            } else {
                                console.log('[onUpdate] Not saving - mode:', this.currentMode, 'insightId:', this.currentInsightId);
                            }
                        },
                        onSelectionUpdate: ({ editor }) => {
                            // Show context menu when text is selected
                            if (this.editorContextMenuHandlers && this.editorContextMenuHandlers.showMenuOnSelection) {
                                this.editorContextMenuHandlers.showMenuOnSelection(editor);
                            }
                        }
                    });
                    
                    // Log immediately after editor creation
                    console.log('[initializeInsightEditor] Editor created successfully');
                    console.log('[initializeInsightEditor] Editor HTML immediately after creation:', this.currentInsightEditor.getHTML());
                    console.log('[initializeInsightEditor] Editor HTML contains img:', this.currentInsightEditor.getHTML().includes('<img'));
                    
                    // Check DOM directly after editor is ready
                    setTimeout(() => {
                        const html = this.currentInsightEditor.getHTML();
                        console.log('[initializeInsightEditor] Editor HTML after delay:', html);
                        console.log('[initializeInsightEditor] Editor HTML contains iframe:', html.includes('<iframe'));
                        const images = editorElement.querySelectorAll('img');
                        const iframes = editorElement.querySelectorAll('iframe');
                        console.log('[initializeInsightEditor] Found', images.length, 'img elements in DOM');
                        console.log('[initializeInsightEditor] Found', iframes.length, 'iframe elements in DOM');
                        if (images.length > 0) {
                            images.forEach((img, idx) => {
                                console.log(`[initializeInsightEditor] Image ${idx}:`, {
                                    src: img.src,
                                    complete: img.complete,
                                    naturalWidth: img.naturalWidth,
                                    naturalHeight: img.naturalHeight,
                                    width: img.width,
                                    height: img.height,
                                    style: img.style.cssText
                                });
                                // Test if image loads
                                img.onload = () => console.log(`[initializeInsightEditor] Image ${idx} loaded successfully`);
                                img.onerror = (e) => console.error(`[initializeInsightEditor] Image ${idx} failed to load:`, e);
                            });
                        } else {
                            console.warn('[initializeInsightEditor]  No images found in DOM!');
                            console.warn('[initializeInsightEditor] Editor HTML:', html);
                            console.warn('[initializeInsightEditor] Editor element innerHTML:', editorElement.innerHTML.substring(0, 500));
                        }
                        if (iframes.length === 0 && initialContent?.includes('<iframe')) {
                            console.warn('[initializeInsightEditor]  Iframe in content but not in DOM!');
                            console.warn('[initializeInsightEditor] Initial content:', initialContent);
                            console.warn('[initializeInsightEditor] Parsed HTML:', html);
                        }
                    }, 300);
                    
                    // Set up context menu for formatting
                    // IMPORTANT: This must be called AFTER editor creation so onSelectionUpdate callback can access the handlers
                    this.setupEditorContextMenu(editorElement);
                    
                    // Set up image click handlers to open modal
                    this.setupImageClickHandlers(editorElement);
                } catch (error) {
                    console.error('[initializeInsightEditor] Error initializing editor:', error);
                    console.error('[initializeInsightEditor] Error stack:', error.stack);
                    if (editorElement && editorElement.parentElement) {
                        editorElement.parentElement.innerHTML = `<div style="padding: 24px; color: #666;">Error initializing editor: ${error.message}</div>`;
                    }
                    throw error; // Re-throw so caller knows it failed
                }
            },
            
            setupEditorContextMenu(editorElement) {
                // Clean up existing context menu setup if any
                if (this.editorContextMenuHandlers) {
                    this.cleanupEditorContextMenu();
                }
                
                // Get or create context menu element
                let contextMenu = document.getElementById('editorContextMenu');
                if (!contextMenu) {
                    contextMenu = document.createElement('div');
                    contextMenu.id = 'editorContextMenu';
                    contextMenu.className = 'editor-context-menu';
                    contextMenu.style.display = 'none';
                    contextMenu.innerHTML = `
                        <div class="context-menu-item" data-action="heading-1">H1</div>
                        <div class="context-menu-item" data-action="heading-2">H2</div>
                        <div class="context-menu-item" data-action="heading-3">H3</div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="bold">Bold</div>
                        <div class="context-menu-item" data-action="highlight">Highlight</div>
                        <div class="context-menu-item" data-action="bulletList">Bullets</div>
                        <div class="context-menu-item" data-action="taskList">Checklist</div>
                        <div class="context-menu-item" data-action="blockquote">Callout</div>
                    `;
                    document.body.appendChild(contextMenu);
                } else {
                    // Hide menu if it was previously visible
                    contextMenu.style.display = 'none';
                }
                
                // Store current editor element for cleanup
                this.currentEditorElement = editorElement;
                
                // Function to show menu when text is selected
                const showMenuOnSelection = (editor) => {
                    if (!editor) {
                        editor = this.currentInsightEditor;
                    }
                    if (!editor) {
                        return;
                    }
                    
                    const { from, to } = editor.state.selection;
                    const isEmpty = from === to;
                    
                    if (isEmpty) {
                        // Hide menu if no text is selected
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    // Get selection coordinates from the editor view
                    const view = editor.view;
                    if (!view) {
                        return;
                    }
                    
                    const coords = view.coordsAtPos(to);
                    
                    if (coords) {
                        // Position menu near the end of the selection
                        // coordsAtPos returns viewport coordinates, so we need position: fixed
                        contextMenu.style.position = 'fixed';
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = `${coords.right}px`;
                        contextMenu.style.top = `${coords.bottom + 5}px`;
                        
                        // Ensure menu stays within viewport
                        requestAnimationFrame(() => {
                            const menuRect = contextMenu.getBoundingClientRect();
                            
                            if (menuRect.right > window.innerWidth) {
                                contextMenu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
                            }
                            if (menuRect.bottom > window.innerHeight) {
                                contextMenu.style.top = `${coords.top - menuRect.height - 5}px`;
                            }
                            if (menuRect.left < 0) {
                                contextMenu.style.left = '10px';
                            }
                            if (menuRect.top < 0) {
                                contextMenu.style.top = '10px';
                            }
                        });
                        
                        // Update active states
                        this.updateContextMenuStates(contextMenu, editor);
                    }
                };
                
                // Handle menu item clicks
                const menuClickHandler = (e) => {
                    e.stopPropagation(); // Prevent event from bubbling to document
                    e.preventDefault();
                    
                    const action = e.target.getAttribute('data-action');
                    if (!action) {
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    const editor = this.currentInsightEditor;
                    if (!editor) {
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    // Hide menu first to prevent conflicts
                    contextMenu.style.display = 'none';
                    
                    // Small delay to ensure menu is hidden before applying command
                    setTimeout(() => {
                        switch (action) {
                            case 'heading-1':
                                editor.chain().focus().toggleHeading({ level: 1 }).run();
                                break;
                            case 'heading-2':
                                editor.chain().focus().toggleHeading({ level: 2 }).run();
                                break;
                            case 'heading-3':
                                editor.chain().focus().toggleHeading({ level: 3 }).run();
                                break;
                            case 'bold':
                                editor.chain().focus().toggleBold().run();
                                break;
                            case 'highlight':
                                console.log('[Highlight Debug] Before toggle:');
                                console.log('[Highlight Debug] isActive:', editor.isActive('highlight'));
                                console.log('[Highlight Debug] Current HTML:', editor.getHTML());
                                
                                editor.chain().focus().toggleHighlight().run();
                                
                                setTimeout(() => {
                                    console.log('[Highlight Debug] After toggle:');
                                    console.log('[Highlight Debug] isActive:', editor.isActive('highlight'));
                                    console.log('[Highlight Debug] New HTML:', editor.getHTML());
                                    
                                    // Check what mark elements exist in the DOM
                                    const editorEl = document.getElementById('insightNotesEditor');
                                    if (editorEl) {
                                        const marks = editorEl.querySelectorAll('mark');
                                        console.log('[Highlight Debug] Found mark elements:', marks.length);
                                        marks.forEach((mark, i) => {
                                            console.log(`[Highlight Debug] Mark ${i}:`, {
                                                className: mark.className,
                                                outerHTML: mark.outerHTML,
                                                computedBg: window.getComputedStyle(mark).backgroundColor
                                            });
                                        });
                                    }
                                }, 100);
                                break;
                            case 'bulletList':
                                editor.chain().focus().toggleBulletList().run();
                                break;
                            case 'taskList':
                                editor.chain().focus().toggleTaskList().run();
                                break;
                            case 'blockquote':
                                // Toggle blockquote
                                if (editor.isActive('blockquote')) {
                                    // If already in blockquote, lift it
                                    editor.chain().focus().lift('blockquote').run();
                                } else {
                                    // Wrap the current block in blockquote
                                    // This works for both selections and empty cursor positions
                                    editor.chain().focus().wrapIn('blockquote').run();
                                }
                                break;
                        }
                    }, 10);
                };
                
                contextMenu.addEventListener('click', menuClickHandler);
                
                // Hide menu on click outside, scroll, or escape key
                const hideMenu = (e) => {
                    if (contextMenu.style.display !== 'none') {
                        // Don't hide if clicking inside the menu itself or the editor
                        if (!contextMenu.contains(e.target) && (!editorElement || !editorElement.contains(e.target))) {
                            contextMenu.style.display = 'none';
                        }
                    }
                };
                
                const scrollHandler = () => {
                    contextMenu.style.display = 'none';
                };
                
                const keydownHandler = (e) => {
                    if (e.key === 'Escape' && contextMenu.style.display !== 'none') {
                        contextMenu.style.display = 'none';
                    }
                };
                
                // Use capture phase to handle clicks before they bubble
                document.addEventListener('click', hideMenu, true);
                document.addEventListener('scroll', scrollHandler, true);
                document.addEventListener('keydown', keydownHandler);
                
                // Store handlers for cleanup
                this.editorContextMenuHandlers = {
                    showMenuOnSelection, // Function to show menu on text selection
                    menuClickHandler,
                    hideMenu,
                    scrollHandler,
                    keydownHandler,
                    editorElement,
                    contextMenu
                };
            },
            
            setupImageClickHandlers(editorElement) {
                if (!editorElement) return;
                
                // Clean up existing handler if any
                if (this.imageClickHandler && this.currentEditorElement) {
                    this.currentEditorElement.removeEventListener('click', this.imageClickHandler);
                }
                
                // Store editor element reference for cleanup
                this.currentEditorElement = editorElement;
                
                // Use event delegation to handle clicks on images
                // This works for both existing and dynamically added images
                const clickHandler = (e) => {
                    // Check if the clicked element or its parent is an image
                    let img = e.target;
                    if (img.tagName !== 'IMG') {
                        img = img.closest('img');
                    }
                    
                    if (img && (img.classList.contains('insight-image') || editorElement.contains(img))) {
                        e.preventDefault();
                        e.stopPropagation();
                        openImageModal(img.src);
                    }
                };
                
                // Store handler for cleanup
                this.imageClickHandler = clickHandler;
                
                // Add click listener to editor element
                editorElement.addEventListener('click', clickHandler);
            },
            
            cleanupEditorContextMenu() {
                if (!this.editorContextMenuHandlers) return;
                
                const { menuClickHandler, hideMenu, scrollHandler, keydownHandler, editorElement, contextMenu } = this.editorContextMenuHandlers;
                
                // No event listeners to remove for selection-based menu (handled by Tiptap's onSelectionUpdate)
                if (contextMenu && menuClickHandler) {
                    contextMenu.removeEventListener('click', menuClickHandler);
                }
                if (hideMenu) {
                    document.removeEventListener('click', hideMenu, true);
                }
                if (scrollHandler) {
                    document.removeEventListener('scroll', scrollHandler, true);
                }
                if (keydownHandler) {
                    document.removeEventListener('keydown', keydownHandler);
                }
                
                // Hide menu if visible
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
                
                // Clear handlers
                this.editorContextMenuHandlers = null;
                this.currentEditorElement = null;
            },
            
            updateContextMenuStates(menu, editor) {
                const items = menu.querySelectorAll('.context-menu-item');
                items.forEach(item => {
                    const action = item.getAttribute('data-action');
                    let isActive = false;
                    
                    switch (action) {
                        case 'heading-1':
                            isActive = editor.isActive('heading', { level: 1 });
                            break;
                        case 'heading-2':
                            isActive = editor.isActive('heading', { level: 2 });
                            break;
                        case 'heading-3':
                            isActive = editor.isActive('heading', { level: 3 });
                            break;
                        case 'bold':
                            isActive = editor.isActive('bold');
                            break;
                        case 'highlight':
                            isActive = editor.isActive('highlight');
                            break;
                        case 'bulletList':
                            isActive = editor.isActive('bulletList');
                            break;
                        case 'taskList':
                            isActive = editor.isActive('taskList');
                            break;
                        case 'blockquote':
                            isActive = editor.isActive('blockquote');
                            break;
                    }
                    
                    if (isActive) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            },
            
            saveTimeout: null,
            fieldSaveTimeout: null,
            
            debouncedSaveInsightNotes(insightId, content) {
                clearTimeout(this.saveTimeout);
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = 'oklch(0.556 0 0)';
                    statusEl.style.opacity = '1';
                    statusEl.style.pointerEvents = 'auto';
                }
                
                this.saveTimeout = setTimeout(async () => {
                    await this.saveInsightNotes(insightId, content);
                }, 500);
            },
            
            debouncedSaveInsightField(fieldName, value) {
                clearTimeout(this.fieldSaveTimeout);
                
                this.fieldSaveTimeout = setTimeout(async () => {
                    await this.saveInsightField(fieldName, value);
                }, 500);
            },
            
            async saveInsightField(fieldName, value) {
                if (!currentClientId || !this.currentInsightId) return;
                
                try {
                    const updateData = {};
                    updateData[fieldName] = value;
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${this.currentInsightId}`, {
                        method: 'PUT',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(updateData)
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save field');
                    }
                    
                    // Update local data
                    if (this.currentInsightData) {
                        this.currentInsightData[fieldName] = value;
                    }
                } catch (error) {
                    console.error('Error saving field:', error);
                }
            },
            
            async saveInsightNotes(insightId, content) {
                console.log('[saveInsightNotes] Called with insightId:', insightId, 'currentClientId:', currentClientId);
                console.log('[saveInsightNotes] Content length:', content?.length);
                console.log('[saveInsightNotes] Content preview:', content?.substring(0, 200));
                console.log('[saveInsightNotes] Content contains img:', content?.includes('<img'));
                console.log('[saveInsightNotes] Full content:', content);
                
                if (!currentClientId || !insightId) {
                    console.warn('[saveInsightNotes] Missing clientId or insightId, aborting');
                    return;
                }
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                
                try {
                    const payload = { notes: content };
                    console.log('[saveInsightNotes] Sending payload:', JSON.stringify(payload).substring(0, 300));
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${insightId}`, {
                        method: 'PUT',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    console.log('[saveInsightNotes] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('[saveInsightNotes] Error response:', errorText);
                        throw new Error('Failed to save notes');
                    }
                    
                    const responseData = await response.json();
                    console.log('[saveInsightNotes] Save successful, response:', responseData);
                    console.log('[saveInsightNotes] Saved notes content (first 500 chars):', responseData.notes?.substring(0, 500));
                    console.log('[saveInsightNotes] Saved notes contains img:', responseData.notes?.includes('<img'));
                    
                    // Check if image URL is complete
                    if (responseData.notes?.includes('<img')) {
                        const imgMatch = responseData.notes.match(/<img[^>]+src="([^"]+)"/);
                        if (imgMatch) {
                            const imgSrc = imgMatch[1];
                            console.log('[saveInsightNotes] Image src found:', imgSrc);
                            console.log('[saveInsightNotes] Image src length:', imgSrc.length);
                            console.log('[saveInsightNotes] Image src ends with .png:', imgSrc.endsWith('.png'));
                            if (!imgSrc.endsWith('.png') && !imgSrc.endsWith('.jpg') && !imgSrc.endsWith('.gif')) {
                                console.warn('[saveInsightNotes]  Image URL appears truncated!');
                            }
                        }
                    }
                    
                    if (statusEl) {
                        statusEl.textContent = 'Saved';
                        statusEl.style.color = '#B9F040'; /* Brand lime green */
                        statusEl.style.opacity = '1';
                        statusEl.style.pointerEvents = 'auto';
                        setTimeout(() => {
                            if (statusEl) {
                                statusEl.style.opacity = '0';
                                setTimeout(() => {
                                    if (statusEl) {
                                        statusEl.textContent = '';
                                        statusEl.style.pointerEvents = 'none';
                                    }
                                }, 200); // Wait for fade out animation
                            }
                        }, 2000);
                    }
                } catch (error) {
                    console.error('[saveInsightNotes] Error saving notes:', error);
                    if (statusEl) {
                        statusEl.textContent = 'Error saving';
                        statusEl.style.color = 'oklch(0.577 0.245 27.325)'; /* Destructive red from style guide */
                        statusEl.style.opacity = '1';
                        statusEl.style.pointerEvents = 'auto';
                    }
                }
            },
            
            close() {
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const subtitle = document.getElementById('slideoutSubtitle');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                const title = document.getElementById('slideoutTitle');
                
                // Reset expanded state when closing
                if (panel) {
                    panel.classList.remove('expanded');
                }
                if (overlay) {
                    overlay.style.width = '500px'; // Reset to default width
                }
                
                // Clean up editor
                if (this.currentInsightEditor) {
                    this.currentInsightEditor.destroy();
                    this.currentInsightEditor = null;
                }
                
                // Clean up context menu handlers
                this.cleanupEditorContextMenu();
                
                // Reset title to default (remove contenteditable for non-insight modes)
                if (title) {
                    title.removeAttribute('contenteditable');
                    title.setAttribute('data-placeholder', '');
                    title.textContent = 'AI-Generated Insights';
                }
                
                if (panel) panel.classList.remove('open');
                if (overlay) overlay.classList.remove('visible');
                if (subtitle) subtitle.style.display = 'none';
                
                // Re-enable body scroll
                document.body.classList.remove('slideout-open');
                
                // Update search bar z-index when slideout closes
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                this.isOpen = false;
                // Only reset currentMode if we're not in history mode (history mode persists)
                // Actually, we should reset it - when closing, we want to clear the mode
                this.currentMode = null;
                this.currentInsightId = null;
                this.currentInsightData = null;
                this.currentOverviewInsightId = null;
                this.createInsightContext = null;
                this.createInsightOrigin = null;
                this.navigationStack = [];  // Reset navigation stack
                
                // Hide back button
                const backButton = document.getElementById('slideoutBackButton');
                if (backButton) backButton.style.display = 'none';
                
                // Clear save timeouts
                if (this.saveTimeout) {
                    clearTimeout(this.saveTimeout);
                    this.saveTimeout = null;
                }
                if (this.fieldSaveTimeout) {
                    clearTimeout(this.fieldSaveTimeout);
                    this.fieldSaveTimeout = null;
                }
            },
            
            // Fetch data source name from API
            async fetchDataSourceName(dataSourceId) {
                console.log('[BreadcrumbNav] fetchDataSourceName called with:', dataSourceId);
                if (!dataSourceId) {
                    console.log('[BreadcrumbNav] No data source ID provided');
                    return null;
                }
                
                // Check cache first
                if (this.dataSourceNameCache[dataSourceId]) {
                    console.log('[BreadcrumbNav] Using cached data source name:', this.dataSourceNameCache[dataSourceId]);
                    return this.dataSourceNameCache[dataSourceId];
                }
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/data-sources/${dataSourceId}`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        console.warn('[BreadcrumbNav] Failed to fetch data source:', response.status);
                        return null;
                    }
                    
                    const dataSource = await response.json();
                    const name = dataSource.name || dataSource.source_name || null;
                    
                    if (name) {
                        this.dataSourceNameCache[dataSourceId] = name;
                        console.log('[BreadcrumbNav] Cached data source name:', name);
                    }
                    
                    return name;
                } catch (error) {
                    console.error('[BreadcrumbNav] Error fetching data source name:', error);
                    return null;
                }
            },
            
            // Update back button visibility
            updateBackButton() {
                const backButton = document.getElementById('slideoutBackButton');
                if (backButton) {
                    if (this.navigationStack.length > 0) {
                        backButton.style.display = 'flex';
                        console.log('[BreadcrumbNav] Back button shown, stack length:', this.navigationStack.length);
                    } else {
                        backButton.style.display = 'none';
                        console.log('[BreadcrumbNav] Back button hidden');
                    }
                }
            },
            
            // Navigate back through navigation stack
            async navigateBack() {
                console.log('[BreadcrumbNav] navigateBack called, stack:', this.navigationStack);
                
                if (this.navigationStack.length === 0) {
                    console.warn('[BreadcrumbNav] Navigation stack is empty, cannot navigate back');
                    return;
                }
                
                const previousState = this.navigationStack.pop();
                console.log('[BreadcrumbNav] Popped state:', previousState);
                
                // Get all UI elements
                const content = document.getElementById('slideoutContent');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                const backButton = document.getElementById('slideoutBackButton');
                
                // Start transition: fade out ALL UI elements simultaneously
                if (content) content.classList.add('transitioning');
                if (title) title.classList.add('transitioning');
                if (subtitle) subtitle.classList.add('transitioning');
                if (searchBox) searchBox.classList.add('transitioning');
                if (settingsBtn) settingsBtn.classList.add('transitioning');
                
                // Wait for fade out
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Update ALL UI elements simultaneously before restoring content
                // This ensures everything changes at once, not sequentially
                this.updateBackButton();
                
                // Restore previous view based on level (this will update content)
                if (previousState.level === 'insight') {
                    // Restore insight view - load data first, then update all UI at once
                    if (previousState.data.insightId) {
                        // Load insight data
                        const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${previousState.data.insightId}`, {
                            headers: getAuthHeaders()
                        });
                        
                        if (response.ok) {
                            const insight = await response.json();
                            this.currentInsightData = insight;
                            this.currentMode = 'insight-notes';
                            this.currentInsightId = previousState.data.insightId;
                            
                            // Update ALL UI elements at once (before content update)
                            if (title) {
                                title.textContent = toPascalCase(insight.name || '');
                                title.setAttribute('contenteditable', 'true');
                                title.setAttribute('data-placeholder', 'Insight Title');
                            }
                            if (subtitle) subtitle.style.display = 'none';
                            if (searchBox) searchBox.style.display = 'none';
                            const searchContainer = document.getElementById('slideoutSearchContainer');
                            if (searchContainer) searchContainer.style.display = 'none';
                            if (settingsBtn) settingsBtn.style.display = 'none';
                            
                            // Update content (this happens after all UI elements are set)
                            await this.initializeInsightPanel(content, insight);
                        }
                    }
                } else if (previousState.level === 'chart') {
                    // Restore chart view
                    this.currentMode = 'chart';
                    
                    // Update ALL UI elements at once (before content update)
                    if (title) {
                        if (previousState.data.topicName && previousState.data.categoryName) {
                            title.textContent = `${previousState.data.categoryName} / ${previousState.data.topicName}`;
                        } else if (previousState.data.categoryName) {
                            title.textContent = previousState.data.categoryName;
                        } else {
                            title.textContent = 'Topics by Category';
                        }
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    if (subtitle) subtitle.style.display = 'none';
                    if (searchBox) searchBox.style.display = 'none';
                    const searchContainer = document.getElementById('slideoutSearchContainer');
                    if (searchContainer) searchContainer.style.display = 'none';
                    if (settingsBtn) settingsBtn.style.display = 'none';
                    
                    // Update content (this happens after all UI elements are set)
                    await this.renderChartView(
                        previousState.data.categoryName,
                        previousState.data.topicName,
                        previousState.data.dataSourceId,
                        previousState.data.dimensionName,
                        true // Skip UI updates, already done above
                    );
                }
                
                // End transition: fade in all elements (re-get elements in case DOM was updated)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                // Force reflow and remove transitioning class from all elements
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
            },
            
            // Navigate to chart view from breadcrumb
            async navigateToChart(categoryName, topicName, dataSourceId, dimensionName) {
                console.log('[BreadcrumbNav] navigateToChart called:', { categoryName, topicName, dataSourceId, dimensionName });
                
                // Save current state to navigation stack
                if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                    this.navigationStack.push({
                        level: 'insight',
                        data: { insightId: this.currentInsightId },
                        view: 'insight'
                    });
                    console.log('[BreadcrumbNav] Pushed insight state to stack');
                }
                
                // Navigate to chart view
                await this.renderChartView(categoryName, topicName, dataSourceId, dimensionName);
            },
            
            // Render chart view in slideout
            async renderChartView(categoryName, topicName, dataSourceId, dimensionName, skipUIUpdates = false) {
                console.log('[BreadcrumbNav] renderChartView called:', { categoryName, topicName, dataSourceId, dimensionName, skipUIUpdates });
                
                this.currentMode = 'chart';
                // Track current chart state
                this.currentChartCategoryName = categoryName;
                this.currentChartTopicName = topicName;
                this.currentChartDataSourceId = dataSourceId;
                this.currentChartDimensionName = dimensionName;
                
                // Update UI (unless already updated by caller)
                if (!skipUIUpdates) {
                    const panel = document.getElementById('slideoutPanel');
                    const overlay = document.getElementById('slideoutOverlay');
                    const title = document.getElementById('slideoutTitle');
                    const searchBox = document.getElementById('slideoutSearch');
                    const settingsBtn = document.getElementById('slideoutSettingsBtn');
                    const subtitle = document.getElementById('slideoutSubtitle');
                    
                    // Hide search and settings
                    if (searchBox) searchBox.style.display = 'none';
                    if (settingsBtn) settingsBtn.style.display = 'none';
                    if (subtitle) subtitle.style.display = 'none';
                    
                    // Set title
                    if (title) {
                        if (topicName && categoryName) {
                            title.textContent = `${categoryName} / ${topicName}`;
                        } else if (categoryName) {
                            title.textContent = categoryName;
                        } else {
                            title.textContent = 'Topics by Category';
                        }
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    
                    // Update back button
                    this.updateBackButton();
                    
                    // Open panel if not already open
                    if (panel && !panel.classList.contains('open')) {
                        panel.classList.add('open');
                    }
                    if (overlay && !overlay.classList.contains('visible')) {
                        overlay.classList.add('visible');
                    }
                    this.isOpen = true;
                    document.body.classList.add('slideout-open');
                    
                    // Update search bar z-index when slideout opens
                    if (typeof updateTreemapSearchZIndex === 'function') {
                        updateTreemapSearchZIndex();
                    }
                }
                
                const content = document.getElementById('slideoutContent');
                
                // Process chart data using existing function
                const { categories: allCategories, totalTopicInstances } = processBarChartData();
                const colorPalette = generateCategoryColorPalette();
                
                // Filter to only show the specified category if categoryName is provided
                const categories = categoryName 
                    ? allCategories.filter(c => c.name === categoryName)
                    : allCategories;
                
                // Calculate total for filtered categories
                const filteredTotal = categories.reduce((sum, cat) => sum + cat.count, 0);
                
                // Get max percent for scaling (use filtered categories)
                const maxPercent = categories.length > 0 
                    ? Math.max(...categories.map(c => c.percent))
                    : 0;
                
                // Render chart in content
                if (!content) {
                    console.error('[BreadcrumbNav] Content container not found');
                    return;
                }
                
                // Build chart HTML
                let chartHTML = `
                    <div style="padding: 1rem 1.5rem; display: flex; flex-direction: column; height: 100%; overflow-y: auto;">
                        <div style="margin-bottom: 1rem; font-size: 0.875rem; color: oklch(0.556 0 0);">
                            Frequency (n=${filteredTotal})
                        </div>
                        <div id="chartViewContainer" style="display: flex; flex-direction: column; gap: 1rem;">
                `;
                
                // Render each category (now filtered to only show the selected one if categoryName provided)
                const categoryColorsLocal = window.colorSchemesCATEGORY_COLORS || [
                    '#A97FFF', '#77D9D6', '#F8A04C', '#58B3F0', '#6ED49B', '#F47280', '#9A7B6C', '#FFB366', '#B794F6', '#4ECDC4'
                ];
                categories.forEach((category, catIndex) => {
                    const categoryId = `chart-cat-${catIndex}`;
                    const baseColor = colorPalette[category.name] || categoryColorsLocal[catIndex % categoryColorsLocal.length];
                    
                    // Category header
                    chartHTML += `
                        <div class="chart-category-group" style="border: 1px solid oklch(0.922 0 0); border-radius: 4px; padding: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <div style="flex: 1; font-weight: 600; font-size: 0.875rem; color: oklch(0.145 0 0);">${escapeHtmlFn(category.name)}</div>
                                <div style="font-size: 0.875rem; color: oklch(0.556 0 0);">${category.percent.toFixed(1)}%</div>
                            </div>
                            
                            <!-- Category bar -->
                            <div style="margin-bottom: 0.5rem; cursor: pointer;"
                                 onclick="SlideoutPanel.navigateToVerbatimsFromChart(null, '${escapeHtmlFn(category.name).replace(/'/g, "\\'")}')">
                                <div style="position: relative; height: 24px; background: oklch(0.97 0 0); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${(category.percent / maxPercent) * 100}%; background: ${baseColor}; transition: width 0.3s ease;"></div>
                                    <div style="position: absolute; top: 50%; left: 8px; transform: translateY(-50%); font-size: 0.75rem; color: ${category.percent / maxPercent > 0.15 ? '#fff' : 'oklch(0.145 0 0)'}; font-weight: 500;">
                                        ${category.percent.toFixed(1)}%
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Topics panel -->
                            <div id="${categoryId}" style="display: block; margin-top: 0.5rem; padding-left: 0;">
                                ${category.topics.map((topic, topicIndex) => {
                                    const isTopicHighlighted = topicName && topic.name === topicName;
                                    const topicColor = adjustColorLightness(baseColor, (topicIndex % 3 - 1) * 15);
                                    return `
                                        <div class="chart-topic-row" 
                                             style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; border-radius: 4px; ${isTopicHighlighted ? 'background: oklch(0.97 0.05 120); border-left: 3px solid #B9F040; padding-left: 8px;' : ''}"
                                             onclick="SlideoutPanel.navigateToVerbatimsFromChart('${escapeHtmlFn(topic.name).replace(/'/g, "\\'")}', '${escapeHtmlFn(category.name).replace(/'/g, "\\'")}')">
                                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${topicColor}; opacity: 0.6;"></div>
                                            <div style="flex: 1; font-size: 0.875rem; color: oklch(0.145 0 0);">${escapeHtmlFn(topic.name)}</div>
                                            <div style="font-size: 0.75rem; color: oklch(0.556 0 0);">${topic.percent.toFixed(1)}%</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                });
                
                chartHTML += `
                        </div>
                    </div>
                `;
                
                content.innerHTML = chartHTML;
                
                // Remove transitioning class from all elements (for smooth fade-in)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
                
                console.log('[BreadcrumbNav] Chart view rendered');
            },
            
            // Toggle category expansion in chart view
            
            // Navigate to verbatims from breadcrumb (direct navigation, skipping chart)
            async navigateToVerbatimsFromBreadcrumb(topicName, categoryName, dataSource, dimensionRef) {
                console.log('[BreadcrumbNav] navigateToVerbatimsFromBreadcrumb called:', { topicName, categoryName, dataSource, dimensionRef });
                
                // Ensure we're in the correct context (data source and dimension)
                if (dataSource || dimensionRef) {
                    await ensureContextForInsightNavigation(dataSource, dimensionRef);
                }
                
                // Save current insight state to navigation stack
                if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                    this.navigationStack.push({
                        level: 'insight',
                        data: { insightId: this.currentInsightId },
                        view: 'insight'
                    });
                    console.log('[BreadcrumbNav] Pushed insight state to stack from breadcrumb');
                }
                
                // Get verbatims from chart data (now that we're in the correct context)
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    // Get verbatims for specific topic
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                }
                
                console.log('[BreadcrumbNav] Found verbatims from breadcrumb:', verbatims.length);
                
                // Navigate to verbatims view
                this.openVerbatims(verbatims, topicName, categoryName);
            },
            
            // Navigate to verbatims from chart view
            navigateToVerbatimsFromChart(topicName, categoryName) {
                console.log('[BreadcrumbNav] navigateToVerbatimsFromChart called:', { topicName, categoryName });
                
                // Save current chart state to navigation stack (use current chart state, not navigation target)
                this.navigationStack.push({
                    level: 'chart',
                    data: { 
                        categoryName: this.currentChartCategoryName || null,
                        topicName: this.currentChartTopicName || null,
                        dataSourceId: this.currentChartDataSourceId || null,
                        dimensionName: this.currentChartDimensionName || null
                    },
                    view: 'chart'
                });
                console.log('[BreadcrumbNav] Pushed current chart state to stack:', {
                    categoryName: this.currentChartCategoryName,
                    topicName: this.currentChartTopicName,
                    dataSourceId: this.currentChartDataSourceId,
                    dimensionName: this.currentChartDimensionName
                });
                
                // Get verbatims from chart data
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    // Get verbatims for specific topic
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                } else if (categoryName) {
                    // Get all verbatims for category
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        category.topics.forEach(topic => {
                            if (topic.verbatims) {
                                verbatims.push(...topic.verbatims);
                            }
                        });
                    }
                }
                
                console.log('[BreadcrumbNav] Found verbatims:', verbatims.length);
                
                // Navigate to verbatims view - pass skipStackPush=true since we already pushed chart state
                this.openVerbatims(verbatims, topicName || categoryName, categoryName, false, true);
            },
            
            // Extract all available metadata fields from verbatims
            extractAvailableMetadataFields(verbatims) {
                const fields = new Set();
                
                verbatims.forEach(v => {
                    if (!v) return;
                    
                    // Add special composite fields
                    if (v.sentiment) fields.add('sentiment');
                    if (v.city || v.country) fields.add('location');
                    if (v.index !== undefined || v.row_id !== undefined) fields.add('index');
                    
                    // Add all other fields from the verbatim object
                    Object.keys(v).forEach(key => {
                        // Skip internal/metadata fields that are handled as special cases
                        if (key !== 'text' && 
                            key !== 'sentiment' && 
                            key !== 'city' &&  // Handled as part of 'location'
                            key !== 'country' &&  // Handled as part of 'location'
                            key !== 'index' && 
                            key !== 'row_id' &&
                            key !== 'category' &&
                            key !== 'topic') {
                            const value = v[key];
                            // Only add fields that have non-empty values
                            if (value !== null && value !== undefined && value !== '') {
                                fields.add(key);
                            }
                        }
                    });
                });
                
                return Array.from(fields).sort();
            },
            
            // Generate metadata settings panel with dynamic checkboxes
            generateMetadataSettingsPanel(availableFields, preserveState = false) {
                const panel = document.getElementById('slideoutSettingsPanel');
                if (!panel) return;
                
                // Preserve existing checkbox states if requested
                const savedStates = {};
                if (preserveState) {
                    availableFields.forEach(field => {
                        const checkbox = document.getElementById(`showMetadata_${field}`);
                        if (checkbox) {
                            savedStates[field] = checkbox.checked;
                        }
                    });
                }
                
                // Clear existing content
                panel.innerHTML = '';
                
                // Add header
                const header = document.createElement('h3');
                header.style.cssText = 'font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #333;';
                header.textContent = 'Display Metadata';
                panel.appendChild(header);
                
                // Helper to create a checkbox option
                const createCheckboxOption = (fieldName, label, defaultValue = false) => {
                    const option = document.createElement('div');
                    option.className = 'settings-option';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `showMetadata_${fieldName}`;
                    // Use saved state if available, otherwise use default
                    checkbox.checked = preserveState && savedStates.hasOwnProperty(fieldName) 
                        ? savedStates[fieldName] 
                        : defaultValue;
                    checkbox.onchange = () => updateSlideoutSettings();
                    
                    const labelEl = document.createElement('label');
                    labelEl.htmlFor = `showMetadata_${fieldName}`;
                    labelEl.textContent = label;
                    
                    option.appendChild(checkbox);
                    option.appendChild(labelEl);
                    return option;
                };
                
                // Add standard fields first (if available)
                if (availableFields.includes('sentiment')) {
                    panel.appendChild(createCheckboxOption('sentiment', 'Sentiment', false));
                }
                if (availableFields.includes('location')) {
                    panel.appendChild(createCheckboxOption('location', 'Location', false));
                }
                if (availableFields.includes('index')) {
                    panel.appendChild(createCheckboxOption('index', 'Index', false));
                }
                
                // Add other metadata fields
                availableFields.forEach(field => {
                    if (field !== 'sentiment' && field !== 'location' && field !== 'index') {
                        // Format field name for display (convert snake_case to Title Case)
                        const displayName = field
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        panel.appendChild(createCheckboxOption(field, displayName, false));
                    }
                });
            },
            
            renderVerbatims(verbatims, topicName, categoryName) {
                console.log('SlideoutPanel.renderVerbatims called with:', { 
                    verbatimsCount: verbatims?.length, 
                    topicName, 
                    categoryName 
                });
                
                // Ensure escapeHtml is available with fallback
                const escapeHtmlFn = window.escapeHtml;
                
                const content = document.getElementById('slideoutContent');
                if (!content) {
                    console.error('slideoutContent element not found!');
                    return;
                }
                
                // Setup search input (preserve existing value if re-rendering)
                const searchInput = document.getElementById('slideoutSearch');
                const clearBtn = document.getElementById('slideoutSearchClear');
                if (searchInput) {
                    // Only clear if this is a fresh render (verbatimSearchTerm is empty)
                    if (!this.verbatimSearchTerm) {
                        searchInput.value = '';
                    } else {
                        // Preserve the search term
                        searchInput.value = this.verbatimSearchTerm;
                    }
                    searchInput.style.display = 'block';
                    searchInput.placeholder = 'Search verbatims...';
                    
                    // Show/hide clear button based on search term
                    if (clearBtn) {
                        clearBtn.style.display = this.verbatimSearchTerm && this.verbatimSearchTerm.trim() ? 'flex' : 'none';
                    }
                }
                
                // Show settings button
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                if (settingsBtn) settingsBtn.style.display = 'flex';
                
                // Extract available metadata fields and generate settings panel
                this.availableMetadataFields = this.extractAvailableMetadataFields(verbatims);
                // Preserve checkbox states if they already exist (when re-rendering)
                const hasExistingCheckboxes = document.getElementById('slideoutSettingsPanel')?.querySelector('input[type="checkbox"]') !== null;
                this.generateMetadataSettingsPanel(this.availableMetadataFields, hasExistingCheckboxes);
                
                // Filter verbatims by search term
                let displayVerbatims = verbatims;
                const searchTerm = (this.verbatimSearchTerm || '').trim();
                if (searchTerm) {
                    const searchLower = searchTerm.toLowerCase();
                    displayVerbatims = verbatims.filter(v => 
                        (v.text || '').toLowerCase().includes(searchLower)
                    );
                }
                
                console.log('Rendering', displayVerbatims.length, 'verbatim cards');
                
                // Render verbatim cards
                content.innerHTML = '';
                
                if (displayVerbatims.length === 0) {
                    content.innerHTML = '<div class="ai-error" style="background: #f8f9fa; border: none; margin: 20px 0;"><p>No verbatims match your search.</p></div>';
                    return;
                }
                
                displayVerbatims.forEach((v, index) => {
                    const card = document.createElement('div');
                    card.className = 'verbatim-card';
                    
                    // Highlight search terms if there's a search
                    const highlightedText = searchTerm ? highlightSearchTerms(v.text || 'No text available', searchTerm) : escapeHtmlFn(v.text || 'No text available');
                    
                    // Build metadata HTML based on settings
                    const metaItems = [];
                    
                    // Helper function to check if a metadata field should be shown
                    const shouldShowField = (fieldName) => {
                        const checkbox = document.getElementById(`showMetadata_${fieldName}`);
                        return checkbox?.checked !== false; // Default to true if checkbox doesn't exist
                    };
                    
                    // Check and render sentiment
                    if (shouldShowField('sentiment') && v.sentiment) {
                        const sentimentClass = `sentiment-${v.sentiment}`;
                        const sentimentLabel = v.sentiment.charAt(0).toUpperCase() + v.sentiment.slice(1);
                        metaItems.push(`<span class="verbatim-metadata-item ${sentimentClass}">${sentimentLabel}</span>`);
                    }
                    
                    // Check and render location (combines city and country)
                    if (shouldShowField('location')) {
                        let locationValue = '';
                        if (v.city && v.country) {
                            locationValue = `${escapeHtmlFn(v.city)}, ${escapeHtmlFn(v.country)}`;
                        } else if (v.country) {
                            locationValue = escapeHtmlFn(v.country);
                        } else if (v.city) {
                            locationValue = escapeHtmlFn(v.city);
                        }
                        if (locationValue) {
                            metaItems.push(`<span class="verbatim-metadata-item">${locationValue}</span>`);
                        }
                    }
                    
                    // Check and render index
                    if (shouldShowField('index')) {
                        const indexValue = v.index !== undefined ? v.index : (v.row_id !== undefined ? v.row_id : index + 1);
                        metaItems.push(`<span class="verbatim-metadata-item">#${indexValue}</span>`);
                    }
                    
                    // Render all other metadata fields dynamically
                    (this.availableMetadataFields || []).forEach(field => {
                        if (field === 'sentiment' || field === 'location' || field === 'index') {
                            return; // Already handled above
                        }
                        
                        if (!shouldShowField(field)) {
                            return; // Skip if checkbox is unchecked
                        }
                        
                        const value = v[field];
                        if (value !== null && value !== undefined && value !== '') {
                            // Format value based on type
                            let displayValue = value;
                            if (typeof value === 'object') {
                                displayValue = JSON.stringify(value);
                            } else if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) {
                                // Looks like a date, try to format it nicely
                                try {
                                    const date = new Date(value);
                                    if (!isNaN(date.getTime())) {
                                        displayValue = date.toLocaleDateString();
                                    }
                                } catch (e) {
                                    // Keep original value if parsing fails
                                }
                            }
                            
                            metaItems.push(`<span class="verbatim-metadata-item">${escapeHtmlFn(String(displayValue))}</span>`);
                        }
                    });
                    
                    const metaHTML = metaItems.length > 0 
                        ? `<div class="verbatim-metadata">${metaItems.join('')}</div>` 
                        : '';
                    
                    // Store verbatim data in a data attribute for the onclick handler
                    // Include all fields from v, plus category and topic if not already present
                    const verbatimObj = {
                        ...v,
                        category: v.category || categoryName,
                        topic: v.topic || topicName
                    };
                    // Use base64 encoding with Unicode-safe encoding (matches handleFavouriteClick format)
                    const verbatimJson = JSON.stringify(verbatimObj);
                    const verbatimData = btoa(unescape(encodeURIComponent(verbatimJson)));
                    card.innerHTML = `
                        <div class="verbatim-card-header">
                            <div class="verbatim-text" style="flex: 1; margin-bottom: 0; padding-right: 8px;">${highlightedText}</div>
                            <button class="create-insight-button" data-verbatim="${verbatimData}" onclick="createInsightFromVerbatim(this)" title="Create insight from this verbatim" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; color: oklch(0.556 0 0); transition: all 0.2s ease;" onmouseover="this.style.color='#B9F040'" onmouseout="this.style.color='oklch(0.556 0 0)'">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 5v14M5 12h14"/>
                                </svg>
                            </button>
                        </div>
                        ${metaHTML}
                    `;
                    
                    content.appendChild(card);
                });
                
                console.log('Finished rendering', displayVerbatims.length, 'cards to slideoutContent');
                
                // Remove transitioning class from all elements (for smooth fade-in)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
            },
            
            async loadSummary(forceRegenerate = false) {
                const content = document.getElementById('slideoutContent');
                if (!content) return;
                
                // Hide search and settings for AI insights
                const searchInput = document.getElementById('slideoutSearch');
                if (searchInput) searchInput.style.display = 'none';
                
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                if (settingsBtn) settingsBtn.style.display = 'none';
                
                // Show loading
                content.innerHTML = `
                    <div class="ai-loading">
                        <div class="ai-loading-spinner"></div>
                        <p>${forceRegenerate ? 'Regenerating insights...' : 'Loading AI insights...'}</p>
                        <small>This may take a few seconds</small>
                    </div>
                `;
                
                try {
                    const { client_uuid, data_source, dimension_ref } = this.currentContext;
                    const url = `${API_BASE_URL}/api/dimensions/${client_uuid}/${data_source}/${dimension_ref}/summary${forceRegenerate ? '?force_regenerate=true' : ''}`;
                    
                    console.log('Fetching AI summary from:', url);
                    
                    const response = await fetch(url, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
                        throw new Error(error.detail || 'Failed to load summary');
                    }
                    
                    const data = await response.json();
                    console.log('AI summary loaded:', data);
                    this.renderSummary(data);
                    
                } catch (error) {
                    console.error('Error loading AI summary:', error);
                    content.innerHTML = `
                        <div class="ai-error">
                            <h3> Error Loading Insights</h3>
                            <p>${error.message}</p>
                            <button onclick="SlideoutPanel.loadSummary()">Try Again</button>
                        </div>
                    `;
                }
            },
            
            // Simple markdown to HTML converter
            convertMarkdown(text) {
                if (!text) return '';
                return text
                    // Fix malformed bold: **TEXT\n\n** -> **TEXT:**
                    .replace(/\*\*([A-Z\s]+)\n\n\*\*/g, '**$1:**')
                    // Fix incomplete bold at line end: **TEXT\n -> **TEXT:**\n
                    .replace(/\*\*([A-Z\s]+)$/gm, '**$1:**')
                    // Remove orphaned ** at start of line (after whitespace/newlines)
                    .replace(/^[\s\n]*\*\*\s+/gm, '')
                    // Remove orphaned ** in the middle of sentences
                    .replace(/\s+\*\*\s+/g, ' ')
                    // Bold: **text** -> <strong>text</strong>
                    .replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>')
                    // Italic: *text* -> <em>text</em>
                    .replace(/\*([^*\n]+)\*/g, '<em>$1</em>')
                    // Line breaks (but keep double breaks as paragraphs)
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');
            },
            
            renderSummary(data) {
                const { summary, status, generated_at, duration_ms, from_cache } = data;
                const content = document.getElementById('slideoutContent');
                if (!content) return;
                
                const statusBadge = from_cache
                    ? '<span class="ai-status-badge ai-status-cached"> From cache</span>'
                    : '<span class="ai-status-badge ai-status-generated"> Freshly generated</span>';
                
                // Parse summary paragraphs with markdown support
                const paragraphs = summary.summary_text.split('\n\n')
                    .map(para => `<p class="ai-summary-text">${this.convertMarkdown(para)}</p>`)
                    .join('');
                
                // Format key insights with markdown support
                const insightsList = (summary.key_insights || [])
                    .map(insight => `<li>${this.convertMarkdown(insight)}</li>`)
                    .join('');
                
                // Format category snapshot with markdown support
                const categoryItems = summary.category_snapshot 
                    ? Object.entries(summary.category_snapshot).map(([cat, desc]) => `
                        <div class="ai-category-item">
                            <div class="ai-category-name">${this.convertMarkdown(cat)}</div>
                            <div>${this.convertMarkdown(desc)}</div>
                        </div>
                    `).join('')
                    : '<p>No category breakdown available</p>';
                
                content.innerHTML = `
                    <div class="ai-summary-section">
                        <h3> Summary</h3>
                        ${paragraphs}
                    </div>
                    
                    ${insightsList ? `
                        <div class="ai-summary-section">
                            <h3> Key Insights</h3>
                            <ul class="ai-insights-list">
                                ${insightsList}
                            </ul>
                        </div>
                    ` : ''}
                    
                    ${categoryItems ? `
                        <div class="ai-summary-section">
                            <h3> Category Breakdown</h3>
                            ${categoryItems}
                        </div>
                    ` : ''}
                    
                    ${summary.patterns ? `
                        <div class="ai-summary-section">
                            <h3> Patterns</h3>
                            <div class="ai-patterns-box">${this.convertMarkdown(summary.patterns)}</div>
                        </div>
                    ` : ''}
                    
                    <div class="ai-metadata">
                        <div>
                            ${statusBadge}
                            Generated ${new Date(generated_at).toLocaleDateString()}
                            ${summary.tokens_used ? `  ${summary.tokens_used} tokens` : ''}
                            ${duration_ms ? `  ${(duration_ms / 1000).toFixed(1)}s` : ''}
                        </div>
                        <div>
                            ${summary.sample_size} / ${summary.total_responses} responses analyzed
                        </div>
                    </div>
                    
                    <button class="ai-regenerate-btn" onclick="SlideoutPanel.loadSummary(true)">
                         Regenerate Insights
                    </button>
                `;
            },
            
            getCurrentDataSource() {
                // Try to find current data source from the UI state
                // This is a simple implementation - adjust based on your app's state management
                const sourceSelect = document.getElementById('sourceSelect');
                if (sourceSelect && sourceSelect.value) {
                    return sourceSelect.value;
                }
                return 'all';  // Default fallback
            }
        };
        
        // Initialize Slideout Panel when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => SlideoutPanel.init());
        } else {
            SlideoutPanel.init();
        }
        
        // Make it globally accessible
        window.SlideoutPanel = SlideoutPanel;
        // Keep backward compatibility
        window.AIInsightsPanel = SlideoutPanel;

        // History Page Functions
        async function initHistoryPage() {
            // Check if already initialized
            if (window.historyInitialized) {
                return;
            }
            
            // Wait for auth to be available
            let attempts = 0;
            while (typeof getAuthHeaders === 'undefined' && attempts < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            const urlParams = new URLSearchParams(window.location.search);
            historyCurrentClientId = urlParams.get('client_uuid') || currentClientId;
            
            const authTokenFromUrl = urlParams.get('auth_token');
            if (authTokenFromUrl) {
                localStorage.setItem('visualizd_auth_token', authTokenFromUrl);
            }

            if (!historyCurrentClientId) {
                // Wait for currentClientId to be set (with timeout)
                let retryAttempts = 0;
                const maxRetries = 50; // 5 seconds max wait
                while (!currentClientId && retryAttempts < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retryAttempts++;
                }
                
                if (currentClientId) {
                    historyCurrentClientId = currentClientId;
                } else {
                    const tbody = document.getElementById('historyPageTableBody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="2" class="empty-state"><h3>No client specified</h3><p style="font-size: 12px; color: #999;">Please select a client first</p></td></tr>';
                    }
                    window.historyInitialized = true;
                    return;
                }
            }

            
            await loadHistoryPage();
            window.historyInitialized = true;
        }

        async function loadHistoryPage() {
            if (!historyCurrentClientId) {
                return;
            }

            const tbody = document.getElementById('historyPageTableBody');
            if (!tbody) {
                return;
            }
            
            tbody.innerHTML = '<tr><td colspan="2" class="loading">Loading history...</td></tr>';

            try {
                const headers = getAuthHeadersSafe();
                const url = `${API_BASE_URL}/api/clients/${historyCurrentClientId}/actions`;
                
                const response = await fetch(url, { headers });

                if (!response.ok) {
                    if (response.status === 401) {
                        if (typeof Auth !== 'undefined') {
                            Auth.showLogin();
                        }
                        return;
                    }
                    const error = await response.json().catch(() => ({ detail: response.statusText }));
                    throw new Error(error.detail || `Failed to load history: ${response.statusText}`);
                }

                const actions = await response.json();
                
                historyAllActions = actions;
                renderHistoryTable();
                
            } catch (error) {
                if (tbody) {
                    const escapeHtmlFn = window.escapeHtml;
                    tbody.innerHTML = `<tr><td colspan="2" class="error">Error loading history: ${escapeHtmlFn(error.message)}</td></tr>`;
                }
            }
        }

        // renderHistoryTable - uses history renderer module after syncing state
        function renderHistoryTable() {
            // Sync local state to module before calling renderer
            window.historyStateSetHistoryAllActions(historyAllActions);
            window.historyStateSetHistorySearchTerm(historySearchTerm);
            window.historyStateSetHistoryCurrentSortBy(historyCurrentSortBy);
            window.historyStateSetHistorySortOrder(historySortOrder);
            
            window.historyRendererRenderHistoryTable();
            selectedHistoryIds.clear();
        }

        function handleHistoryCheckboxChange() {
            selectedHistoryIds.clear();
            const checkboxes = document.querySelectorAll('.history-checkbox:checked');
            checkboxes.forEach(checkbox => {
                const actionId = checkbox.getAttribute('data-action-id');
                if (actionId) {
                    selectedHistoryIds.add(actionId);
                }
            });
            updateHistoryDeleteButton();
            updateHistorySelectAllCheckbox();
        }

        function toggleSelectAllHistory(checked) {
            const checkboxes = document.querySelectorAll('.history-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
                const actionId = checkbox.getAttribute('data-action-id');
                if (checked && actionId) {
                    selectedHistoryIds.add(actionId);
                } else if (actionId) {
                    selectedHistoryIds.delete(actionId);
                }
            });
            updateHistoryDeleteButton();
        }

        function updateHistorySelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('historySelectAll');
            if (!selectAllCheckbox) return;
            
            const checkboxes = document.querySelectorAll('.history-checkbox');
            const checkedCount = document.querySelectorAll('.history-checkbox:checked').length;
            selectAllCheckbox.checked = checkboxes.length > 0 && checkedCount === checkboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < checkboxes.length;
        }

        function updateHistoryDeleteButton() {
            const deleteBtn = document.getElementById('historyDeleteBtn');
            if (!deleteBtn) return;
            
            const shouldShow = selectedHistoryIds.size > 0;
            
            if (shouldShow) {
                deleteBtn.removeAttribute('style');
                deleteBtn.style.display = 'block';
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        async function deleteSelectedHistory() {
            if (!historyCurrentClientId) return;
            if (selectedHistoryIds.size === 0) return;

            const count = selectedHistoryIds.size;
            const message = count === 1 
                ? 'Are you sure you want to delete this history item?'
                : `Are you sure you want to delete ${count} history items?`;
            
            if (!confirm(message)) return;

            try {
                const deletePromises = Array.from(selectedHistoryIds).map(actionId =>
                    fetch(`${API_BASE_URL}/api/clients/${historyCurrentClientId}/actions/${actionId}`, {
                        method: 'DELETE',
                        headers: getAuthHeadersSafe()
                    }).then(response => {
                        if (!response.ok) throw new Error(`Failed to delete action ${actionId}`);
                        return actionId;
                    })
                );

                await Promise.all(deletePromises);
                selectedHistoryIds.clear();
                loadHistoryPage();
            } catch (error) {
                console.error('Error deleting history items:', error);
                alert('Error deleting history items: ' + error.message);
                // Reload page to sync state even if some deletes failed
                loadHistoryPage();
            }
        }

        function handleHistorySearch() {
            const input = document.getElementById('historySearchInput');
            if (!input) return;
            
            historySearchTerm = input.value.trim();
            updateHistorySearchClearButton();
            renderHistoryTable();
        }

        function clearHistorySearch() {
            const input = document.getElementById('historySearchInput');
            if (input) {
                input.value = '';
                historySearchTerm = '';
                updateHistorySearchClearButton();
                renderHistoryTable();
            }
        }

        function updateHistorySearchClearButton() {
            const input = document.getElementById('historySearchInput');
            const clearBtn = document.getElementById('historySearchClear');
            if (input && clearBtn) {
                clearBtn.style.display = input.value.trim() ? 'flex' : 'none';
            }
        }

        function sortHistoryBy(column) {
            if (historyCurrentSortBy === column) {
                historySortOrder = historySortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                historyCurrentSortBy = column;
                historySortOrder = column === 'created_at' ? 'desc' : 'asc';
            }
            
            // Update sort indicators
            document.querySelectorAll('#history-section .sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });
            
            const header = document.querySelector(`#history-section th[data-column="${column}"]`);
            if (header) {
                const indicator = header.querySelector('.sort-indicator');
                if (indicator) {
                    indicator.textContent = historySortOrder === 'asc' ? '' : '';
                }
            }
            
            renderHistoryTable();
        }

        async function openHistoryAction(actionId) {
            if (!historyCurrentClientId) {
                alert('No client selected');
                return;
            }
            
            try {
                const headers = getAuthHeadersSafe();
                const url = `${API_BASE_URL}/api/clients/${historyCurrentClientId}/actions/${actionId}`;
                const response = await fetch(url, { headers });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        if (typeof Auth !== 'undefined') {
                            Auth.showLogin();
                        }
                        return;
                    }
                    const error = await response.json().catch(() => ({ detail: response.statusText }));
                    throw new Error(error.detail || 'Failed to load action');
                }
                
                const action = await response.json();
                
                // Get prompt name for display
                let promptName = 'AI Expert Output';
                if (action.prompt_purpose) {
                    const abbreviations = ['SEO', 'CRO', 'UX', 'UI', 'API', 'CRM', 'CMS', 'CTA', 'ROI', 'KPI', 'A/B', 'AB', 'PPC', 'SEM', 'SERP', 'SaaS', 'B2B', 'B2C', 'GDPR', 'LTV', 'CAC', 'MVP', 'FAQ', 'URL', 'HTML', 'CSS', 'JS', 'JSON', 'XML', 'REST', 'HTTP', 'HTTPS', 'SSL', 'TLS', 'CDN', 'DNS', 'IP', 'PDF', 'CSV', 'XLS', 'XLSX'];
                    promptName = action.prompt_purpose
                        .replace(/_/g, ' ')
                        .replace(/-/g, ' ')
                        .split(' ')
                        .map(word => {
                            const upperWord = word.toUpperCase();
                            if (abbreviations.includes(upperWord)) {
                                return upperWord;
                            }
                            return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
                        })
                        .join(' ');
                }
                
                // Get content from actions.actions.content
                const content = action.actions?.content || '';
                
                // Open slideout with the content and full action data
                if (window.SlideoutPanel && window.SlideoutPanel.openHistoryAction) {
                    window.SlideoutPanel.openHistoryAction(actionId, promptName, content, action);
                } else {
                    // Fallback: use simple rendering
                    const panel = document.getElementById('slideoutPanel');
                    const overlay = document.getElementById('slideoutOverlay');
                    const titleEl = document.getElementById('slideoutTitle');
                    const contentEl = document.getElementById('slideoutContent');
                    
                    if (!panel || !overlay || !titleEl || !contentEl) {
                        alert('Slideout panel not available');
                        return;
                    }
                    
                    titleEl.textContent = promptName;
                    const formattedContent = content
                        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                        .replace(/\n\n/g, '</p><p>')
                        .replace(/\n/g, '<br>');
                    contentEl.innerHTML = `<div class="prompt-result-content"><p>${formattedContent}</p></div>`;
                    
                    panel.classList.add('open');
                    overlay.classList.add('visible');
                    document.body.classList.add('slideout-open');
                }
                
            } catch (error) {
                console.error('[openHistoryAction] Error:', error);
                alert('Error loading action: ' + error.message);
            }
        }

        // Add openHistoryAction method to SlideoutPanel
        if (window.SlideoutPanel) {
            window.SlideoutPanel.openHistoryAction = async function(actionId, promptName, content, actionData) {
                // Use the same rendering approach as prompt engineering page
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const titleEl = document.getElementById('slideoutTitle');
                const contentEl = document.getElementById('slideoutContent');
                
                if (!panel || !overlay || !titleEl || !contentEl) {
                    console.error('[openHistoryAction] Slideout elements not found');
                    return;
                }
                
                // Set mode to 'history' so setCurrentDimension won't close the panel
                this.currentMode = 'history';
                this.isOpen = true;
                
                // Use origin from action if available, otherwise create a minimal default origin
                const historyOrigin = actionData?.origin || {
                    origin_type: 'category', // Default to category since we don't have specific context
                    process_voc_id: null,
                    project_name: null,
                    data_source: null,
                    dimension_ref: null,
                    dimension_name: null,
                    category: null,
                    topic_label: null
                };
                
                // Store the origin and voc_json so idea card listeners can use them
                this.createInsightOrigin = historyOrigin;
                this.currentActionVocJson = actionData?.voc_json || null;
                
                // Remove any transitioning classes to prevent fade effects
                contentEl.classList.remove('transitioning');
                if (titleEl) titleEl.classList.remove('transitioning');
                
                // Open the panel
                panel.classList.add('open');
                overlay.classList.add('visible');
                document.body.classList.add('slideout-open');
                
                // Set title
                titleEl.textContent = promptName;
                
                // Clear content immediately without fade
                contentEl.innerHTML = '';
                
                // Try to use ActionRenderer.renderActionItem if available (same as prompt engineering)
                if (window.ActionRenderer && window.ActionRenderer.renderActionItem) {
                    // Use ActionRenderer to render the action item with proper styling
                    // Use the action data from API, ensuring all required fields are present
                    const actionObject = actionData || {
                        id: actionId,
                        actions: {
                            content: content,
                            model: null,
                            tokens_used: null
                        },
                        created_at: new Date().toISOString(),
                        prompt_name: promptName,
                        prompt_version: null,
                        prompt_system_message: null,
                        prompt_text_sent: ''
                    };
                    
                    // Ensure actions.content is set
                    if (!actionObject.actions) {
                        actionObject.actions = {};
                    }
                    if (!actionObject.actions.content && content) {
                        actionObject.actions.content = content;
                    }
                    
                    // Render using ActionRenderer (same as prompt engineering page)
                    const renderedHTML = window.ActionRenderer.renderActionItem(
                        actionObject,
                        // onCopy callback
                        async (actionId) => {
                            const action = actionObject;
                            const textToCopy = action.actions?.content || '';
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                console.log('[openHistoryAction] Content copied to clipboard');
                            } catch (err) {
                                console.error('[openHistoryAction] Failed to copy:', err);
                            }
                        },
                        // onDelete callback (not applicable for client history, but required by renderActionItem)
                        null
                    );
                    
                    contentEl.innerHTML = renderedHTML;
                    
                    // Attach system message toggle listeners
                    if (window.ActionRenderer.attachSystemMessageToggles) {
                        window.ActionRenderer.attachSystemMessageToggles(contentEl);
                    }
                    
                    // Attach idea card listeners if available
                    // This enables the add button on idea cards to create insights
                    if (window.ActionRenderer.attachIdeaCardListeners) {
                        window.ActionRenderer.attachIdeaCardListeners(contentEl);
                    }
                    
                    // Attach copy button listeners
                    const copyButton = contentEl.querySelector('.btn-copy-output');
                    if (copyButton) {
                        copyButton.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            const textToCopy = actionObject.actions?.content || '';
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                console.log('[openHistoryAction] Content copied to clipboard');
                            } catch (err) {
                                console.error('[openHistoryAction] Failed to copy:', err);
                            }
                        });
                    }
                    
                    // Hide delete button and navigation buttons for client history (not applicable)
                    const deleteButton = contentEl.querySelector('.btn-delete-output');
                    const navPrevButton = contentEl.querySelector('.btn-nav-prev');
                    const navNextButton = contentEl.querySelector('.btn-nav-next');
                    if (deleteButton) deleteButton.style.display = 'none';
                    if (navPrevButton) navPrevButton.style.display = 'none';
                    if (navNextButton) navNextButton.style.display = 'none';
                    
                } else if (window.MarkdownConverter && window.MarkdownConverter.convertMarkdown) {
                    // Fallback: Use MarkdownConverter if ActionRenderer not available
                    const { convertMarkdown } = window.MarkdownConverter;
                    const formattedContent = convertMarkdown(content);
                    contentEl.innerHTML = `
                        <div class="prompt-output-item">
                            <div class="prompt-output-header">
                                <div class="prompt-output-meta">
                                    <div style="margin-bottom: 4px;">
                                        <strong>${escapeHtml(promptName)}</strong>
                                        <span style="color: var(--muted); font-size: 12px; margin-left: 12px;">${new Date().toLocaleString()}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="prompt-result-content">${formattedContent}</div>
                        </div>
                    `;
                    
                    // Attach idea card listeners even in fallback mode
                    if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                        window.ActionRenderer.attachIdeaCardListeners(contentEl);
                    }
                } else {
                    // Final fallback: simple HTML rendering with basic markdown formatting
                    const formattedContent = content
                        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                        .replace(/\n\n/g, '</p><p>')
                        .replace(/\n/g, '<br>');
                    contentEl.innerHTML = `
                        <div class="prompt-output-item">
                            <div class="prompt-output-header">
                                <div class="prompt-output-meta">
                                    <div style="margin-bottom: 4px;">
                                        <strong>${escapeHtml(promptName)}</strong>
                                        <span style="color: var(--muted); font-size: 12px; margin-left: 12px;">${new Date().toLocaleString()}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="prompt-result-content"><p>${formattedContent}</p></div>
                        </div>
                    `;
                    
                    // Attach idea card listeners even in final fallback mode
                    if (window.ActionRenderer && window.ActionRenderer.attachIdeaCardListeners) {
                        window.ActionRenderer.attachIdeaCardListeners(contentEl);
                    }
                }
            };
        }

        // Insights Panel Management
        let insightsAutoFilter = true;
        let insightsCurrentFilters = {};
        let allInsights = [];
        // insightsSearchTerm, insightsFilters, and insightsSortOrder are already declared above (lines 9225, 9222, 9224)
        let insightsSortBy = 'name';

        // Toggle insights panel - uses UI controller module
        function toggleInsightsPanel() {
            return window.uiControllerToggleInsightsPanel();
        }

        // Toggle insights add dropdown - uses UI controller module
        function toggleInsightsAddDropdown(event) {
            return window.uiControllerToggleInsightsAddDropdown(event);
        }

        // Close insights add dropdown - uses UI controller module
        function closeInsightsAddDropdown() {
            return window.uiControllerCloseInsightsAddDropdown();
        }

        async function handleInsightsAddOption(option) {
            closeInsightsAddDropdown();
            if (option === 'manual') {
                openAddInsightFromVisualizations();
                return;
            }
            if (option === 'overview') {
                await openAIOverviewFromVisualizations();
            }
        }

        function openAddInsightFromVisualizations() {
            console.log('[openAddInsightFromVisualizations] Function called');
            
            if (!currentClientId) {
                alert('Please select a client first');
                return;
            }
            
            // Check if SlideoutPanel is available
            if (typeof SlideoutPanel === 'undefined' || !SlideoutPanel.openCreateInsight) {
                console.error('[openAddInsightFromVisualizations] SlideoutPanel not available');
                alert('Error: Unable to open insight creation panel');
                return;
            }
            
            // Get current context from global variables
            const contextData = {
                dimension_ref: currentQuestionRefKey || null,
                project_name: currentProjectName || null,
                data_source: currentDataSourceId || null,
                dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
            };
            
            console.log('[openAddInsightFromVisualizations] Context data:', contextData);
            console.log('[openAddInsightFromVisualizations] Calling SlideoutPanel.openCreateInsight');
            
            SlideoutPanel.openCreateInsight(contextData);
        }

        async function openAIOverviewFromVisualizations() {
            if (!currentClientId) {
                alert('Please select a client first');
                return;
            }
            if (!window.ClientPromptAPI) {
                alert('Error: Client prompt API not loaded');
                return;
            }
            if (!hierarchyData || !hierarchyData.children || hierarchyData.children.length === 0) {
                alert('No visualization data available. Please load data first.');
                return;
            }

            let overviewPromptId = null;
            try {
                const prompts = await window.ClientPromptAPI.listPrompts(currentClientId);
                console.log('[openAIOverviewFromVisualizations] Available prompts:', prompts);
                
                // Search for overview prompt with flexible matching
                const overviewPrompt = (prompts || []).find(prompt => {
                    const name = (prompt.name || '').trim().toLowerCase();
                    // Match various forms: "overview", "ai overview", "Overview Summary", etc.
                    return name === 'overview' || 
                           name === 'ai overview' || 
                           name.includes('overview') ||
                           name.includes('ai_overview');
                });
                
                if (overviewPrompt) {
                    overviewPromptId = overviewPrompt.id;
                    console.log('[openAIOverviewFromVisualizations] Found overview prompt:', overviewPrompt);
                } else {
                    console.warn('[openAIOverviewFromVisualizations] No overview prompt found. Available prompts:', 
                        prompts.map(p => p.name));
                }
            } catch (error) {
                console.error('[openAIOverviewFromVisualizations] Failed to load prompts:', error);
            }

            if (!overviewPromptId) {
                const availablePrompts = await window.ClientPromptAPI.listPrompts(currentClientId).catch(() => []);
                const promptNames = availablePrompts.map(p => p.name).join(', ');
                alert(`Unable to find the "overview" prompt. Available prompts: ${promptNames || 'none'}. Please create a prompt with "overview" in its name.`);
                return;
            }

            const summaryPayload = buildOverviewSummaryFromHierarchy();
            await SlideoutPanel.openAIOverviewSummary(summaryPayload, overviewPromptId);
        }

        document.addEventListener('click', (event) => {
            const dropdown = document.querySelector('.insights-add-dropdown');
            const menu = document.getElementById('insightsAddDropdownMenu');
            if (!menu || !dropdown) return;
            if (!dropdown.contains(event.target)) {
                menu.classList.remove('open');
            }
        });

        // AI Button Dropdown Functions
        function toggleAIDropdown(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const menu = document.getElementById('aiDropdownMenu');
            if (!menu) return;
            const isOpen = menu.classList.contains('open');
            menu.classList.toggle('open', !isOpen);
            
            // If opening, populate AI Expert options
            if (!isOpen) {
                populateAIExpertOptions();
            }
        }

        function closeAIDropdown() {
            const menu = document.getElementById('aiDropdownMenu');
            if (menu) {
                menu.classList.remove('open');
            }
        }

        async function populateAIExpertOptions() {
            const container = document.getElementById('aiExpertOptionsContainer');
            if (!container) return;

            if (!currentClientId || !window.ClientPromptAPI) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = '';

            try {
                const prompts = await window.ClientPromptAPI.listPrompts(currentClientId);
                if (prompts && prompts.length > 0) {
                    // Filter out the "overview" prompt since it's already shown as a separate option
                    const expertPrompts = prompts.filter(prompt => {
                        const name = (prompt.name || '').trim().toLowerCase();
                        // Exclude overview prompts (various forms)
                        return name !== 'overview' && 
                               name !== 'ai overview' && 
                               !name.includes('overview') && 
                               !name.includes('ai_overview');
                    });

                    if (expertPrompts.length === 0) {
                        container.innerHTML = '';
                        return;
                    }

                    // Format prompt names with title case and abbreviation preservation
                    const abbreviations = ['SEO', 'CRO', 'UX', 'UI', 'API', 'CRM', 'CMS', 'CTA', 'ROI', 'KPI', 'A/B', 'AB', 'PPC', 'SEM', 'SERP', 'SaaS', 'B2B', 'B2C', 'GDPR', 'CTA', 'LTV', 'CAC', 'MVP', 'FAQ', 'URL', 'HTML', 'CSS', 'JS', 'JSON', 'XML', 'REST', 'HTTP', 'HTTPS', 'SSL', 'TLS', 'CDN', 'DNS', 'IP', 'PDF', 'CSV', 'XLS', 'XLSX'];
                    
                    container.innerHTML = expertPrompts.map(prompt => {
                        const name = prompt.name || '';
                        const titleCaseName = name
                            .replace(/_/g, ' ')
                            .replace(/-/g, ' ')
                            .split(' ')
                            .map(word => {
                                const upperWord = word.toUpperCase();
                                if (abbreviations.includes(upperWord)) {
                                    return upperWord;
                                }
                                return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
                            })
                            .join(' ');
                        
                        // Escape HTML to prevent XSS
                        const escapedName = titleCaseName
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#039;');
                        
                        return `<button class="ai-dropdown-item" onclick="handleAIDropdownOption('expert', '${prompt.id}')">${escapedName}</button>`;
                    }).join('');
                } else {
                    container.innerHTML = '';
                }
            } catch (error) {
                console.error('Error loading AI Expert prompts:', error);
                container.innerHTML = '';
            }
        }

        async function handleAIDropdownOption(option, promptId) {
            closeAIDropdown();
            
            if (option === 'manual') {
                openAddInsightFromVisualizations();
                return;
            }
            
            if (option === 'overview') {
                await openAIOverviewFromVisualizations();
                return;
            }
            
            if (option === 'expert' && promptId) {
                await openAIExpertFromButton(promptId);
            }
        }

        async function openAIExpertFromButton(promptId) {
            if (!currentClientId) {
                alert('Please select a client first');
                return;
            }
            
            if (!window.ClientPromptAPI) {
                alert('Error: Client prompt API not loaded');
                return;
            }
            
            if (!hierarchyData || !hierarchyData.children || hierarchyData.children.length === 0) {
                alert('No visualization data available. Please load data first.');
                return;
            }

            // Use full aggregated data (same as AI Overview)
            await SlideoutPanel.openAIExpertInsight(null, promptId, true);
        }

        // Close AI dropdown when clicking outside
        document.addEventListener('click', (event) => {
            const aiButtonContainer = document.querySelector('.ai-button-container');
            const aiMenu = document.getElementById('aiDropdownMenu');
            if (!aiMenu || !aiButtonContainer) return;
            if (!aiButtonContainer.contains(event.target)) {
                aiMenu.classList.remove('open');
            }
        });

        function updateInsightsAutoFilter() {
            if (!currentClientId) return;
            
            // Always show all insights (no filtering)
            const badge = document.getElementById('insightsFilterBadge');
            if (badge) {
                badge.style.display = 'none';
            }
            
            insightsCurrentFilters = {};
            loadInsights({});
        }

        async function loadInsights(filters = {}) {
            if (!currentClientId) return;
            
            const tbody = document.getElementById('insightsTableBody');
            if (!tbody) return;
            
            try {
                const params = new URLSearchParams({
                    page: '1',
                    page_size: '1000',
                    sort_by: (insightsSortBy === 'name' || insightsSortBy === 'type' || insightsSortBy === 'created_at' || insightsSortBy === 'updated_at') ? insightsSortBy : 'created_at',
                    sort_order: insightsSortOrder,
                });
                
                // Merge auto-filters with manual filters
                const allFilters = { ...insightsCurrentFilters, ...filters };
                
                // Fetch insights using API module
                const data = await window.insightsApiLoadInsights(currentClientId, {
                    page: '1',
                    page_size: '1000',
                    sort_by: (insightsSortBy === 'name' || insightsSortBy === 'type' || insightsSortBy === 'created_at' || insightsSortBy === 'updated_at') ? insightsSortBy : 'created_at',
                    sort_order: insightsSortOrder,
                    filters: allFilters
                }, getAuthHeaders);
                
                allInsights = data.items || [];
                renderInsights();
            } catch (error) {
                console.error('Error loading insights:', error);
                if (tbody) {
                    const escapeHtmlFn = window.escapeHtml;
                    tbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>Error loading insights</h3><p>' + escapeHtmlFn(error.message) + '</p></td></tr>';
                }
            }
        }

        // renderInsights - uses insights renderer module
        function renderInsights(insights) {
            return window.insightsRendererRenderInsights(insights);
        }

        function handleInsightsSearch() {
            const searchInput = document.getElementById('insightsSearchInput');
            insightsSearchTerm = searchInput?.value.trim() || '';
            updateInsightsSearchClearButton();
            renderInsights();
        }

        function updateInsightsSearchClearButton() {
            const searchInput = document.getElementById('insightsSearchInput');
            const clearButton = document.getElementById('insightsSearchClear');
            if (!searchInput || !clearButton) return;

            if (searchInput.value.trim() !== '') {
                clearButton.style.display = 'flex';
            } else {
                clearButton.style.display = 'none';
            }
        }

        function clearInsightsSearch() {
            const searchInput = document.getElementById('insightsSearchInput');
            if (!searchInput) return;

            searchInput.value = '';
            insightsSearchTerm = '';
            updateInsightsSearchClearButton();
            renderInsights();
            searchInput.focus();
        }

        function sortInsightsBy(column) {
            // Update sort indicators
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('sorted');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            });

            const clickedTh = event.currentTarget;
            clickedTh.classList.add('sorted');
            const indicator = clickedTh.querySelector('.sort-indicator');

            if (insightsSortBy === column) {
                insightsSortOrder = insightsSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                insightsSortBy = column;
                insightsSortOrder = 'asc';
            }

            if (indicator) {
                indicator.textContent = insightsSortOrder === 'asc' ? '' : '';
            }

            renderInsights();
        }

        function updateInsightsFilterChips() {
            const chipsContainer = document.getElementById('insightsFilterChips');

            // Don't render filter chips - filters are shown as checkboxes in the dropdown
            if (chipsContainer) {
                chipsContainer.innerHTML = '';
            }
        }

        function removeInsightsFilter(key) {
            delete insightsFilters[key];
            updateInsightsFilterChips();
            renderInsights();
        }

        function resetInsightsFilters() {
            insightsFilters = {};
            insightsSearchTerm = '';
            const searchInput = document.getElementById('insightsSearchInput');
            if (searchInput) searchInput.value = '';
            updateInsightsSearchClearButton();
            updateInsightsFilterChips();
            renderInsights();
        }

        function openInsightsFilterMenu() {
            // Type filter removed
        }

        // escapeHtml function - now imported from js/utils/dom.js module
        // Available globally via window.escapeHtml

        function openCreateInsightModal() {
            // Build origin from current view context
            const origin = {
                origin_type: 'category', // Default
                project_name: currentProjectName || null,
                data_source: currentDataSourceId || null,
                dimension_ref: currentQuestionRefKey || null,
                dimension_name: null,
                category: null,
                topic_label: null,
                process_voc_id: null,
            };
            
            // Open create modal - for now, redirect to standalone page with context
            const params = new URLSearchParams({ client_uuid: currentClientId });
            if (currentQuestionRefKey) params.append('dimension_ref', currentQuestionRefKey);
            if (currentProjectName) params.append('project_name', currentProjectName);
            if (currentDataSourceId) params.append('data_source', currentDataSourceId);
            
            // Pass auth token via URL parameter (will be stored in localStorage on the new page)
            const token = getAuthToken();
            if (token) {
                params.append('auth_token', token);
            }
            
            // Use SPA navigation with hash routing
            const url = `${window.location.origin}${window.location.pathname}?${params.toString()}#/insights`;
            window.open(url, '_blank');
        }

        function editInsightFromView(insightId) {
            const params = new URLSearchParams({ client_uuid: currentClientId, insight_id: insightId });
            
            // Pass auth token via URL parameter
            const token = getAuthToken();
            if (token) {
                params.append('auth_token', token);
            }
            
            // Use SPA navigation with hash routing
            const url = `${window.location.origin}${window.location.pathname}?${params.toString()}#/insights`;
            window.open(url, '_blank');
        }

        // Update insights when view context changes
        const originalLoadDataSource = window.loadDataSource;
        if (typeof loadDataSource === 'function') {
            // Wrap to update insights after data loads
            const wrapper = async function(...args) {
                await originalLoadDataSource.apply(this, args);
                updateInsightsAutoFilter();
            };
            window.loadDataSource = wrapper;
        }

        // Context Menu Management
        let currentContextData = null;
        let contextMenuJustClicked = false;

        async function showContextMenu(event, contextData) {
            event.preventDefault();
            event.stopPropagation();
            
            const contextMenu = document.getElementById('contextMenu');
            if (!contextMenu) return;
            
            currentContextData = contextData;
            contextMenuJustClicked = false;
            
            // Ensure AI Expert submenu is closed when menu is first shown (remove inline style so CSS can control it)
            const aiExpertSubmenu = document.getElementById('aiExpertSubmenu');
            if (aiExpertSubmenu) {
                aiExpertSubmenu.style.display = '';
            }
            
            // Show/hide "Exclude Category" menu item based on context type
            const excludeCategoryItem = contextMenu.querySelector('[data-action="exclude-category"]');
            if (excludeCategoryItem) {
                if (contextData && contextData.type === 'category') {
                    excludeCategoryItem.style.display = 'block';
                } else {
                    excludeCategoryItem.style.display = 'none';
                }
            }
            
            // Populate AI Expert submenu with live prompts
            if (aiExpertSubmenu && currentClientId && window.ClientPromptAPI) {
                aiExpertSubmenu.innerHTML = '<div class="context-menu-submenu-item loading">Loading...</div>';
                try {
                    const prompts = await window.ClientPromptAPI.listPrompts(currentClientId);
                    if (prompts && prompts.length > 0) {
                        aiExpertSubmenu.innerHTML = prompts.map(prompt => {
                            const name = prompt.name || '';
                            // Common marketing abbreviations to keep in uppercase
                            const abbreviations = ['SEO', 'CRO', 'UX', 'UI', 'API', 'CRM', 'CMS', 'CTA', 'ROI', 'KPI', 'A/B', 'AB', 'PPC', 'SEM', 'SERP', 'SaaS', 'B2B', 'B2C', 'GDPR', 'CTA', 'LTV', 'CAC', 'MVP', 'FAQ', 'URL', 'HTML', 'CSS', 'JS', 'JSON', 'XML', 'REST', 'HTTP', 'HTTPS', 'SSL', 'TLS', 'CDN', 'DNS', 'IP', 'PDF', 'CSV', 'XLS', 'XLSX'];
                            
                            // Replace underscores and hyphens with spaces, then apply Title Case with abbreviation preservation
                            const titleCaseName = name
                                .replace(/_/g, ' ')
                                .replace(/-/g, ' ')
                                .split(' ')
                                .map(word => {
                                    // Check if word (case-insensitive) matches any abbreviation
                                    const upperWord = word.toUpperCase();
                                    if (abbreviations.includes(upperWord)) {
                                        return upperWord;
                                    }
                                    // Apply Title Case
                                    return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
                                })
                                .join(' ');
                            return `<div class="context-menu-submenu-item" data-action="ai-expert-prompt" data-prompt-id="${prompt.id}">${escapeHtml(titleCaseName)}</div>`;
                        }).join('');
                    } else {
                        aiExpertSubmenu.innerHTML = '<div class="context-menu-submenu-item loading">No prompts available</div>';
                    }
                } catch (error) {
                    console.error('Error loading prompts:', error);
                    aiExpertSubmenu.innerHTML = '<div class="context-menu-submenu-item loading">Error loading prompts</div>';
                }
            }
            
            // Position menu at cursor, ensuring it stays within viewport
            // First, make menu visible but off-screen to measure its dimensions
            contextMenu.style.visibility = 'hidden';
            contextMenu.style.display = 'block';
            contextMenu.style.left = '0px';
            contextMenu.style.top = '0px';
            
            // Get menu dimensions after it's rendered
            const rect = contextMenu.getBoundingClientRect();
            const menuWidth = rect.width;
            const menuHeight = rect.height;
            
            // Calculate position ensuring menu stays within viewport
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const margin = 10; // Margin from viewport edge
            
            let left = event.clientX;
            let top = event.clientY;
            
            // If menu would overflow right edge, position it to the left of cursor
            if (left + menuWidth > viewportWidth - margin) {
                left = Math.max(margin, viewportWidth - menuWidth - margin);
            }
            
            // If menu would overflow bottom edge, position it above cursor
            if (top + menuHeight > viewportHeight - margin) {
                top = Math.max(margin, viewportHeight - menuHeight - margin);
            }
            
            // Apply final position and make visible
            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
            contextMenu.style.visibility = 'visible';
            
            // Setup improved hover behavior for submenu
            setupSubmenuHover();
        }
        
        // Improved hover behavior for submenu with delay
        let submenuHideTimeout = null;
        let submenuEventListeners = { item: null, submenu: null };
        let submenuPositionDecided = false; // Track if position was already calculated for current menu display
        
        function setupSubmenuHover() {
            const aiExpertItem = document.querySelector('[data-action="ai-expert"]');
            const aiExpertSubmenu = document.getElementById('aiExpertSubmenu');
            
            if (!aiExpertItem || !aiExpertSubmenu) return;
            
            // Clear any existing timeout
            if (submenuHideTimeout) {
                clearTimeout(submenuHideTimeout);
                submenuHideTimeout = null;
            }
            
            // Remove existing listeners if any
            if (submenuEventListeners.item) {
                aiExpertItem.removeEventListener('mouseenter', submenuEventListeners.item.show);
                aiExpertItem.removeEventListener('mouseleave', submenuEventListeners.item.hide);
            }
            if (submenuEventListeners.submenu) {
                aiExpertSubmenu.removeEventListener('mouseenter', submenuEventListeners.submenu.show);
                aiExpertSubmenu.removeEventListener('mouseleave', submenuEventListeners.submenu.hide);
            }
            
            // Show submenu on mouseenter (parent item or submenu)
            const showSubmenu = () => {
                if (submenuHideTimeout) {
                    clearTimeout(submenuHideTimeout);
                    submenuHideTimeout = null;
                }
                aiExpertSubmenu.style.display = 'block';
                
                // Only calculate position on first hover - don't recalculate when moving to submenu
                if (submenuPositionDecided) {
                    return;
                }
                
                // Check if submenu would overflow viewport and flip to left if needed
                const contextMenu = document.getElementById('contextMenu');
                if (contextMenu) {
                    const submenuRect = aiExpertSubmenu.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const margin = 10;
                    
                    // Check horizontal overflow - flip to left side if needed
                    if (submenuRect.right > viewportWidth - margin) {
                        // Position submenu to the left of the main menu
                        aiExpertSubmenu.style.left = 'auto';
                        aiExpertSubmenu.style.right = '100%';
                        aiExpertSubmenu.style.marginLeft = '0';
                        aiExpertSubmenu.style.marginRight = '-4px';
                    } else {
                        // Reset to default right-side position
                        aiExpertSubmenu.style.left = '100%';
                        aiExpertSubmenu.style.right = 'auto';
                        aiExpertSubmenu.style.marginLeft = '-4px';
                        aiExpertSubmenu.style.marginRight = '0';
                    }
                    
                    // Check vertical overflow - adjust top position if needed
                    const newSubmenuRect = aiExpertSubmenu.getBoundingClientRect();
                    if (newSubmenuRect.bottom > viewportHeight - margin) {
                        const overflow = newSubmenuRect.bottom - viewportHeight + margin;
                        aiExpertSubmenu.style.top = `${-overflow}px`;
                    } else {
                        aiExpertSubmenu.style.top = '0';
                    }
                    
                    // Mark that position has been decided for this menu display
                    submenuPositionDecided = true;
                }
            };
            
            // Hide submenu on mouseleave with delay
            const hideSubmenu = () => {
                if (submenuHideTimeout) {
                    clearTimeout(submenuHideTimeout);
                }
                submenuHideTimeout = setTimeout(() => {
                    aiExpertSubmenu.style.display = '';
                    // Reset position styles to CSS defaults so next calculation starts fresh
                    aiExpertSubmenu.style.left = '';
                    aiExpertSubmenu.style.right = '';
                    aiExpertSubmenu.style.marginLeft = '';
                    aiExpertSubmenu.style.marginRight = '';
                    aiExpertSubmenu.style.top = '';
                    submenuPositionDecided = false;
                    submenuHideTimeout = null;
                }, 150); // 150ms delay to allow mouse movement
            };
            
            // Store listeners for cleanup
            submenuEventListeners.item = { show: showSubmenu, hide: hideSubmenu };
            submenuEventListeners.submenu = { show: showSubmenu, hide: hideSubmenu };
            
            // Add event listeners to parent item
            aiExpertItem.addEventListener('mouseenter', showSubmenu);
            aiExpertItem.addEventListener('mouseleave', hideSubmenu);
            
            // Add event listeners to submenu
            aiExpertSubmenu.addEventListener('mouseenter', showSubmenu);
            aiExpertSubmenu.addEventListener('mouseleave', hideSubmenu);
        }

        // Helper function to escape HTML
        // escapeHtml function - now imported from js/utils/dom.js module
        // Available globally via window.escapeHtml

        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            // Clear submenu hide timeout
            if (submenuHideTimeout) {
                clearTimeout(submenuHideTimeout);
                submenuHideTimeout = null;
            }
            // Reset submenu position decision flag for next menu display
            submenuPositionDecided = false;
            // Ensure submenu is closed when hiding context menu (remove inline style so CSS can control it)
            const aiExpertSubmenu = document.getElementById('aiExpertSubmenu');
            if (aiExpertSubmenu) {
                aiExpertSubmenu.style.display = '';
            }
            currentContextData = null;
            contextMenuJustClicked = false;
        }

        // Handle context menu item clicks and closing menu on click outside
        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            const isMenuVisible = contextMenu && contextMenu.style.display !== 'none';
            
            // Check if click is on a context menu item
            const item = e.target.closest('.context-menu-item');
            const clickedInMenu = contextMenu && contextMenu.contains(e.target);
            
            console.log('Click detected:', {
                isMenuVisible,
                clickedInMenu,
                item: !!item,
                target: e.target,
                targetClass: e.target.className,
                targetTag: e.target.tagName
            });
            
            // Check if click is on a submenu item
            const submenuItem = e.target.closest('.context-menu-submenu-item');
            if (submenuItem && isMenuVisible) {
                e.preventDefault();
                e.stopPropagation();
                contextMenuJustClicked = true;
                
                const action = submenuItem.getAttribute('data-action');
                if (action === 'ai-expert-prompt') {
                    const promptId = submenuItem.getAttribute('data-prompt-id');
                    if (promptId && currentContextData) {
                        const savedContextData = JSON.parse(JSON.stringify(currentContextData));
                        setTimeout(() => {
                            hideContextMenu();
                            if (window.SlideoutPanel && window.SlideoutPanel.openAIExpertInsight) {
                                window.SlideoutPanel.openAIExpertInsight(savedContextData, promptId);
                            } else {
                                alert('Error: AI Expert feature not available');
                            }
                        }, 10);
                    }
                }
                return;
            }
            
            if (item && isMenuVisible) {
                e.preventDefault();
                e.stopPropagation();
                contextMenuJustClicked = true;
                
                const action = item.getAttribute('data-action');
                console.log('=== CONTEXT MENU CLICK ===');
                console.log('Action:', action);
                console.log('Current context data:', currentContextData);
                console.log('Event target:', e.target);
                console.log('Closest item:', item);
                
                if (action === 'ai-expert') {
                    // Submenu is controlled by hover only, no click action needed
                    return; // Don't close menu when hovering over AI Expert
                } else if (action === 'create-insight') {
                    console.log('Create insight action triggered');
                    if (currentContextData) {
                        console.log('Context data exists:', currentContextData);
                        // Save context data before hiding menu (which clears it)
                        // Use JSON parse/stringify to ensure deep copy
                        const savedContextData = JSON.parse(JSON.stringify(currentContextData));
                        console.log('Saved context data:', savedContextData);
                        // Use setTimeout to ensure click event completes
                        setTimeout(() => {
                            console.log('About to open slideout panel with saved data:', savedContextData);
                            hideContextMenu();
                            SlideoutPanel.openCreateInsight(savedContextData, true);
                        }, 10);
                    } else {
                        console.error('No context data available when clicking create insight');
                        alert('Error: No context data available. Please try right-clicking again.');
                    }
                } else if (action === 'exclude-category') {
                    console.log('=== EXCLUDE CATEGORY ACTION ===');
                    console.log('Current context data:', currentContextData);
                    if (currentContextData && currentContextData.type === 'category' && currentContextData.category) {
                        const categoryName = currentContextData.category;
                        console.log('Excluding category:', categoryName);
                        console.log('Current filterRules before update:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                            type: r.type,
                            mode: r.mode,
                            values: Array.from(r.values)
                        })))));
                        
                        // Find or create a category filter rule with mode 'exclude'
                        let existingRuleIndex = filterRules.findIndex(r => r.type === 'category');
                        console.log('Existing category rule index:', existingRuleIndex);
                        
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            const existingRule = filterRules[existingRuleIndex];
                            console.log('Existing rule before update:', {
                                type: existingRule.type,
                                mode: existingRule.mode,
                                values: Array.from(existingRule.values)
                            });
                            // If mode is 'include', we need to switch to exclude mode
                            if (existingRule.mode === 'include') {
                                // Switch to exclude mode and clear existing selections
                                console.log('Switching from include to exclude mode');
                                existingRule.mode = 'exclude';
                                existingRule.values = new Set([categoryName]);
                            } else {
                                // Already in exclude mode, add the category to the set
                                console.log('Adding category to existing exclude rule');
                                existingRule.values.add(categoryName);
                            }
                            console.log('Existing rule after update:', {
                                type: existingRule.type,
                                mode: existingRule.mode,
                                values: Array.from(existingRule.values)
                            });
                        } else {
                            // Create new exclude rule
                            console.log('Creating new exclude rule');
                            filterRules.push({
                                type: 'category',
                                mode: 'exclude',
                                values: new Set([categoryName])
                            });
                        }
                        
                        console.log('FilterRules after update:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                            type: r.type,
                            mode: r.mode,
                            values: Array.from(r.values)
                        })))));
                        console.log('Category rule values after update:', Array.from(filterRules.find(r => r.type === 'category')?.values || []));
                        console.log('availableCategories:', availableCategories);
                        
                        // Save filters for current dimension
                        saveFiltersForDimension(currentQuestionRefKey);
                        console.log('Saved filters for dimension:', currentQuestionRefKey);
                        
                        // Check filter dropdown state before updating
                        const filterDropdown = document.getElementById('filterDropdown');
                        const filterSelectionView = document.getElementById('filterSelectionView');
                        const filterTypeView = document.getElementById('filterTypeView');
                        const isDropdownVisible = filterDropdown && window.getComputedStyle(filterDropdown).display !== 'none';
                        const isSelectionViewVisible = filterSelectionView && window.getComputedStyle(filterSelectionView).display !== 'none';
                        const isTypeViewVisible = filterTypeView && window.getComputedStyle(filterTypeView).display !== 'none';
                        
                        console.log('Filter dropdown state:', {
                            filterDropdownExists: !!filterDropdown,
                            isDropdownVisible: isDropdownVisible,
                            filterSelectionViewExists: !!filterSelectionView,
                            isSelectionViewVisible: isSelectionViewVisible,
                            filterTypeViewExists: !!filterTypeView,
                            isTypeViewVisible: isTypeViewVisible,
                            currentFilterType: currentFilterType,
                            currentFilterSelections: Array.from(currentFilterSelections || [])
                        });
                        
                        // Update filter UI to show the active filter (this updates the badge)
                        updateFilterUI();
                        console.log('Called updateFilterUI()');
                        
                        // If filter dropdown is open and showing category filter selection view, refresh it
                        if (isDropdownVisible && isSelectionViewVisible) {
                            if (currentFilterType === 'category') {
                                console.log('Filter dropdown is open showing category filter - refreshing view');
                                // Refresh the filter selection view to show the newly added category as checked
                                showFilterSelectionView();
                                console.log('Called showFilterSelectionView()');
                            } else {
                                console.log('Filter dropdown is open but showing different filter type:', currentFilterType);
                                console.log('Setting currentFilterType to category and refreshing view');
                                // Set currentFilterType to category and refresh the view
                                currentFilterType = 'category';
                                showFilterSelectionView();
                                console.log('Called showFilterSelectionView() with category type');
                            }
                        } else if (isDropdownVisible && isTypeViewVisible) {
                            console.log('Filter dropdown is open but showing type view - just updating active filters list');
                            // If showing type view, updateFilterUI already refreshed the active filters list
                        } else {
                            console.log('Filter dropdown is not open or not showing selection view');
                            console.log('isDropdownVisible:', isDropdownVisible, 'isSelectionViewVisible:', isSelectionViewVisible);
                        }
                        
                        // Apply filters and re-render charts
                        console.log('Applying filters and re-rendering...');
                        applyFiltersAndRender();
                        console.log('Filters applied and charts re-rendered');
                        
                        // Hide the context menu
                        hideContextMenu();
                        console.log('Context menu hidden');
                    } else {
                        console.error('Invalid context data for exclude category action:', currentContextData);
                        alert('Error: Unable to exclude category. Please try right-clicking again.');
                    }
                } else if (action === 'copy-json') {
                    console.log('=== COPY JSON ACTION ===');
                    if (currentContextData) {
                        try {
                            // Get the full data structure
                            const fullData = getFullDataForContext(currentContextData);
                            
                            if (!fullData) {
                                alert('Error: Unable to retrieve data. Please try right-clicking again.');
                                hideContextMenu();
                                return;
                            }
                            
                            // Extract clean verbatims (text and id only)
                            const cleanVerbatims = extractCleanVerbatims(fullData);
                            
                            // Convert to formatted JSON string
                            const jsonString = JSON.stringify(cleanVerbatims, null, 2);
                            
                            // Copy to clipboard
                            navigator.clipboard.writeText(jsonString).then(() => {
                                console.log('JSON copied to clipboard successfully');
                                // Provide user feedback (simple console log, can be enhanced with UI notification)
                                // Hide the context menu
                                hideContextMenu();
                            }).catch(err => {
                                console.error('Failed to copy JSON to clipboard:', err);
                                alert('Error: Failed to copy to clipboard. Please try again.');
                                hideContextMenu();
                            });
                        } catch (error) {
                            console.error('Error copying JSON:', error);
                            alert('Error: Unable to copy JSON. Please try again.');
                            hideContextMenu();
                        }
                    } else {
                        console.error('No context data available when copying JSON');
                        alert('Error: No context data available. Please try right-clicking again.');
                        hideContextMenu();
                    }
                } else {
                    console.warn('Unknown action:', action);
                }
                return; // Don't close menu when clicking menu item
            }
            
            // Close context menu on click outside
            if (isMenuVisible && !contextMenuJustClicked && !contextMenu.contains(e.target)) {
                hideContextMenu();
            }
            
            // Reset flag after processing
            if (contextMenuJustClicked) {
                contextMenuJustClicked = false;
            }
        });
        
        // Close context menu on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideContextMenu();
                const modal = document.getElementById('createInsightModal');
                if (modal && modal.style.display !== 'none') {
                    closeCreateInsightModal();
                }
            }
        });

        // Open create insight modal from context menu
        function openCreateInsightModalFromContext(contextData) {
            console.log('=== OPENING CREATE INSIGHT MODAL ===');
            console.log('Context data:', contextData);
            const modal = document.getElementById('createInsightModal');
            const form = document.getElementById('createInsightForm');
            console.log('Modal element:', modal);
            console.log('Form element:', form);
            
            if (!modal) {
                console.error('Modal element not found!');
                alert('Error: Modal element not found. Please check the console.');
                return;
            }
            if (!form) {
                console.error('Form element not found!');
                alert('Error: Form element not found. Please check the console.');
                return;
            }
            
            // Reset form
            form.reset();
            
            // Validate contextData
            if (!contextData) {
                console.error('contextData is null or undefined');
                alert('Error: Context data is missing. Please try right-clicking again.');
                return;
            }
            
            console.log('Creating origin from contextData:', contextData);
            
            // Pre-populate origin data
            const origin = {
                origin_type: contextData.type, // 'category' or 'topic'
                project_name: contextData.project_name || null,
                data_source: contextData.data_source || null,
                dimension_ref: contextData.dimension_ref || null,
                dimension_name: contextData.dimension_name || null,
                category: contextData.category || null,
                topic_label: contextData.topic_label || null,
                process_voc_id: null,
            };
            
            console.log('Created origin object:', origin);
            
            // Store origin for form submission
            window.currentInsightOrigin = origin;
            
            // Display origin preview
            const originPreview = document.getElementById('insightModalOriginPreview');
            if (originPreview) {
                const originText = [];
                if (origin.origin_type === 'category') {
                    originText.push(`<strong>Type:</strong> Category`);
                    if (origin.category) originText.push(`<strong>Category:</strong> ${escapeHtml(origin.category)}`);
                } else if (origin.origin_type === 'topic') {
                    originText.push(`<strong>Type:</strong> Topic`);
                    if (origin.category) originText.push(`<strong>Category:</strong> ${escapeHtml(origin.category)}`);
                    if (origin.topic_label) originText.push(`<strong>Topic:</strong> ${escapeHtml(origin.topic_label)}`);
                }
                if (origin.project_name) originText.push(`<strong>Project:</strong> ${escapeHtml(origin.project_name)}`);
                if (origin.data_source) originText.push(`<strong>Data Source:</strong> ${escapeHtml(origin.data_source)}`);
                if (origin.dimension_ref) {
                    const dimensionDisplay = origin.dimension_name || origin.dimension_ref;
                    originText.push(`<strong>Dimension:</strong> ${escapeHtml(dimensionDisplay)}`);
                }
                
                originPreview.innerHTML = originText.join('<br>') || 'No origin information';
            }
            
            // Show modal
            modal.style.display = 'flex';
            console.log('Modal should now be visible');
        }

        function closeCreateInsightModal() {
            console.log('Closing create insight modal');
            const modal = document.getElementById('createInsightModal');
            if (modal) {
                modal.style.display = 'none';
            }
            const form = document.getElementById('createInsightForm');
            if (form) {
                form.reset();
            }
            window.currentInsightOrigin = null;
        }
        
        // Make functions globally accessible
        window.closeCreateInsightModal = closeCreateInsightModal;
        window.openCreateInsightModalFromContext = openCreateInsightModalFromContext;

        async function handleCreateInsightSubmit(event) {
            event.preventDefault();
            
            if (!currentClientId) {
                alert('No client selected');
                return;
            }
            
            const name = document.getElementById('insightModalName').value.trim();
            const description = document.getElementById('insightModalDescription').value.trim() || null;
            
            if (!name) {
                alert('Please fill in required fields (Name)');
                return;
            }
            
            const origin = window.currentInsightOrigin;
            if (!origin) {
                alert('Origin information is missing');
                return;
            }
            
            const insightData = {
                name,
                type: null,  // Type not available when creating from visualizations view
                application: null,  // Application not available when creating from visualizations view
                description,
                origins: [origin],
            };
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    alert('You are not logged in. Please log in and try again.');
                    return;
                }
                
                // Get auth headers
                const getAuthHeadersFn = () => {
                    return {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    };
                };
                
                // Create insight using API module
                await window.insightsApiCreateInsight(currentClientId, insightData, getAuthHeadersFn);
                
                // Success - close modal and refresh insights panel
                closeCreateInsightModal();
                
                // Always refresh insights list so new insight appears when navigating to insights tab
                // Check if insights section is visible to refresh it immediately
                const insightsSection = document.getElementById('insights-section');
                const isInsightsViewActive = insightsSection && insightsSection.classList.contains('active');
                
                console.log('[handleCreateInsightSubmit] Insights section check:', {
                    element: !!insightsSection,
                    isActive: isInsightsViewActive,
                    hasLoadInsightsPage: typeof loadInsightsPage === 'function',
                    hasLoadInsights: typeof loadInsights === 'function'
                });
                
                // Always try to refresh insights page first (for insights tab)
                if (typeof loadInsightsPage === 'function') {
                    console.log('[handleCreateInsightSubmit] Refreshing insights list via loadInsightsPage()');
                    loadInsightsPage();
                }
                
                // Also refresh the other insights view if it exists (for compatibility)
                if (typeof loadInsights === 'function') {
                    console.log('[handleCreateInsightSubmit] Refreshing insights list via loadInsights()');
                    loadInsights();
                }
                
                // Reset insights initialization flag so it can reload if needed
                if (window.insightsInitialized) {
                    window.insightsInitialized = false;
                }
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 12px 24px; border-radius: 6px; z-index: 10004; box-shadow: 0 4px 12px rgba(0,0,0,0.2);';
                successMsg.textContent = 'Insight created successfully!';
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);
                
            } catch (error) {
                console.error('Error creating insight:', error);
                alert('Error creating insight: ' + error.message);
            }
        }

        // Image Modal Functions
        function openImageModal(imageSrc) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('imageModalImg');
            
            if (modal && modalImg) {
                modalImg.src = imageSrc;
                modal.classList.add('active');
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) {
                modal.classList.remove('active');
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }
        
        // Close modal on backdrop click
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('createInsightModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeCreateInsightModal();
                    }
                });
            }
            
            // Set up image modal backdrop click
            const imageModal = document.getElementById('imageModal');
            const imageModalContent = imageModal?.querySelector('.image-modal-content');
            
            if (imageModal) {
                // Prevent clicks on content from closing modal
                if (imageModalContent) {
                    imageModalContent.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }
                
                // Close when clicking on overlay background
                imageModal.addEventListener('click', (e) => {
                    if (e.target === imageModal) {
                        closeImageModal();
                    }
                });
            }
            
            // Close image modal on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const imageModal = document.getElementById('imageModal');
                    if (imageModal && imageModal.classList.contains('active')) {
                        closeImageModal();
                    }
                }
            });
        });
    </script>
    
    <!-- Marketing site header -->
    <script src="/header.js"></script>
    
    <!-- Slideout Panel (AI Insights / Verbatims) -->
    <div id="slideoutTab" class="ai-insights-tab" style="display: none !important;">
        <span> AI Insights</span>
    </div>
    
    <div id="slideoutPanel" class="ai-insights-panel">
        <div class="ai-insights-header">
            <button id="slideoutExpandButton" class="slideout-expand-btn" title="Expand slideout">
                <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/insights/1767922251837-rvam8.png" alt="Expand" width="20" height="20">
            </button>
            <button id="slideoutBackButton" class="slideout-back-button" onclick="SlideoutPanel.navigateBack()" title="Back">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 4l-6 6 6 6"/>
                </svg>
            </button>
            <div style="flex: 1;">
                <div id="slideoutTitle" 
                     contenteditable="true" 
                     style="font-size: 1.5rem; font-weight: 600; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); outline: none; min-height: 1.75rem; line-height: 1.2;"
                     data-placeholder="Insight Title">AI-Generated Insights</div>
                <p id="slideoutSubtitle" class="overlay-subtitle" style="display: none; margin-top: 4px; font-size: 13px; color: #666;"></p>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <button id="slideoutSettingsBtn" class="settings-button" onclick="toggleSlideoutSettings()" title="Card Settings" style="display: none;">
                    <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/settings.svg" alt="Settings" width="18" height="18">
                </button>
                <button id="closeSlideoutPanel" class="ai-close-btn">&times;</button>
            </div>
        </div>
        
        <!-- Settings panel for verbatims -->
        <div id="slideoutSettingsPanel" class="settings-panel" style="display: none; margin-top: 12px; padding: 0 10px 10px 10px;">
            <!-- Metadata checkboxes will be dynamically generated here -->
        </div>
        
        <div id="slideoutContent" class="ai-insights-content">
            <!-- Content loaded dynamically -->
        </div>
    </div>
    
    <div id="slideoutOverlay" class="ai-insights-overlay"></div>
    
    <!-- Image Modal for Full-Size Image Viewing -->
    <div id="imageModal" class="image-modal-overlay">
        <div class="image-modal-content">
            <button class="image-modal-close" onclick="closeImageModal()" aria-label="Close image">&times;</button>
            <img id="imageModalImg" src="" alt="Full size image">
        </div>
    </div>
        </div> <!-- End visualizations-section -->

        <!-- Insights Section -->
        <div id="insights-section" class="spa-section">
            <div class="control-bar" style="position: relative;">
                <h1 style="margin: 0; font-size: 20px; font-weight: 600; color: #37352f; margin-right: 0.5rem;">Insights</h1>
                <div class="search-box insights-section-search">
                    <input
                        type="text"
                        id="searchInput"
                        placeholder="Search insights..."
                        oninput="handleSearch()"
                        onfocus="updateInsightsSectionSearchClearButton()"
                    >
                    <button
                        id="insightsSectionSearchClear"
                        onclick="clearInsightsSectionSearch()"
                        title="Clear search"
                        style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                    >&times;</button>
                </div>
                <div class="filter-chips" id="filterChips"></div>
                <div style="position: relative;">
                    <button class="filter-button" onclick="toggleFilterMenu(event)" id="filterMenuBtn" type="button" aria-label="Open filters">
                        <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/filter_list.svg" alt="" aria-hidden="true">
                        <span id="insightsListFilterBadge" class="filter-badge" aria-hidden="true"></span>
                    </button>
                    
                    <!-- Filter Dropdown Menu -->
                    <div class="filter-dropdown" id="filterDropdown">
                        <div class="filter-dropdown-search">
                            <input type="text" id="filterSearchInput" placeholder="Filter by..." oninput="filterFilterOptions()">
                        </div>
                        <div class="filter-dropdown-list" id="filterOptionsList">
                            <!-- Filter options will be populated here -->
                        </div>
                        <div class="filter-active-filters" id="activeFiltersSection" style="display: none;">
                            <div class="filter-active-filters-title">Active filters</div>
                            <div id="activeFiltersList"></div>
                        </div>
                    </div>
                </div>
                <button class="btn-delete" onclick="deleteSelectedInsights()" id="insightsSectionDeleteBtn" style="display: none;">Delete Selected</button>
                <button class="btn-new" onclick="openCreateModal()">+ New</button>
            </div>
            
            <!-- Filter Value Selection Dialog -->
            <div class="filter-dialog-overlay" id="filterDialogOverlay" onclick="closeFilterValueDialog()"></div>
            <div class="filter-value-dialog" id="filterValueDialog">
                <div class="filter-value-dialog-header">
                    <div class="filter-value-dialog-title" id="filterValueDialogTitle">Select value</div>
                    <button class="filter-value-dialog-close" onclick="closeFilterValueDialog()">&times;</button>
                </div>
                <div class="filter-value-dialog-body" id="filterValueDialogBody">
                    <!-- Filter value options will be populated here -->
                </div>
            </div>

            <div class="table-container">
                <table class="notion-table">
                    <thead>
                        <tr>
                            <th class="name-cell sorted draggable" data-column="name" draggable="true" onclick="sortBy('name')">
                                <span>Name</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="type" draggable="true" onclick="sortBy('type')">
                                <span>Type</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="application" draggable="true" onclick="sortBy('application')">
                                <span>Application</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="status" draggable="true" onclick="sortBy('status')">
                                <span>Status</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="origin" draggable="true" onclick="sortBy('origin')">
                                <span>Origin</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="created_at" draggable="true" onclick="sortBy('created_at')">
                                <span>Created</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="actions-cell">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="insightsPageTableBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Slideout Panel for Insight Notes -->
        <!-- Removed: insightNotesPanel and insightNotesOverlay - now using slideoutPanel and slideoutOverlay -->

        <!-- Create/Edit Modal -->
        <div id="insightModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalTitle">Create Insight</h2>
                    <button class="close-btn" onclick="closeModal()"></button>
                </div>
                <form id="insightForm" onsubmit="saveInsight(event)">
                    <div class="form-group">
                        <label>Insight Name *</label>
                        <input type="text" id="insightName" required>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="insightDescription" placeholder="Detailed description"></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn-secondary" onclick="closeModal()">Cancel</button>
                        <button type="submit" class="btn-save">Save</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- End insights-section -->

    <!-- History Section -->
    <div id="history-section" class="spa-section">
        <div class="control-bar" style="position: relative;">
            <h1 style="margin: 0; font-size: 20px; font-weight: 600; color: #37352f; margin-right: 0.5rem;">History</h1>
            <div class="search-box insights-section-search">
                <input
                    type="text"
                    id="historySearchInput"
                    placeholder="Search history..."
                    oninput="handleHistorySearch()"
                    onfocus="updateHistorySearchClearButton()"
                >
                <button
                    id="historySearchClear"
                    onclick="clearHistorySearch()"
                    title="Clear search"
                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                >&times;</button>
            </div>
            <button class="btn-delete" onclick="deleteSelectedHistory()" id="historyDeleteBtn" style="display: none;">Delete Selected</button>
        </div>

        <div class="table-container">
            <table class="notion-table">
                <thead>
                    <tr>
                        <th class="checkbox-cell">
                            <input type="checkbox" id="historySelectAll" onchange="toggleSelectAllHistory(this.checked)" onclick="event.stopPropagation()">
                        </th>
                        <th class="name-cell sorted draggable" data-column="name" draggable="true" onclick="sortHistoryBy('name')">
                            <span>Name</span>
                            <span class="sort-indicator"></span>
                        </th>
                        <th class="draggable" data-column="origin" draggable="true" onclick="sortHistoryBy('origin')">
                            <span>Origin</span>
                            <span class="sort-indicator"></span>
                        </th>
                        <th class="draggable" data-column="created_at" draggable="true" onclick="sortHistoryBy('created_at')">
                            <span>Created</span>
                            <span class="sort-indicator"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="historyPageTableBody">
                </tbody>
            </table>
        </div>
    </div> <!-- End history-section -->

    <!-- Ads Section -->
    <div id="ads-section" class="spa-section">
        <div class="control-bar" style="position: relative;">
            <h1 style="margin: 0; font-size: 20px; font-weight: 600; color: #37352f; margin-right: 0.5rem;">Saved Ads</h1>
            <div class="search-box ads-section-search">
                <input
                    type="text"
                    id="adsSearchInput"
                    placeholder="Search ads..."
                    oninput="handleAdsSearch()"
                    onfocus="updateAdsSearchClearButton()"
                >
                <button
                    id="adsSearchClear"
                    onclick="clearAdsSearch()"
                    title="Clear search"
                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                >&times;</button>
            </div>
            <div class="filter-chips" id="adsFilterChips"></div>
            <div style="position: relative;">
                <button class="filter-button" onclick="toggleAdsFilterMenu(event)" id="adsFilterMenuBtn" type="button" aria-label="Open filters">
                    <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/filter_list.svg" alt="" aria-hidden="true">
                    <span id="adsFilterBadge" class="filter-badge" aria-hidden="true"></span>
                </button>
                
                <!-- Filter Dropdown Menu -->
                <div class="filter-dropdown" id="adsFilterDropdown">
                    <div class="filter-dropdown-search">
                        <input type="text" id="adsFilterSearchInput" placeholder="Filter by..." oninput="filterAdsFilterOptions()">
                    </div>
                    <div class="filter-dropdown-list" id="adsFilterOptionsList">
                        <!-- Filter options will be populated here -->
                    </div>
                    <div class="filter-active-filters" id="adsActiveFiltersSection" style="display: none;">
                        <div class="filter-active-filters-title">Active filters</div>
                        <div id="adsActiveFiltersList"></div>
                    </div>
                </div>
            </div>
            <div style="position: relative;">
                <button class="sort-button" onclick="toggleAdsSortMenu(event)" id="adsSortMenuBtn" type="button" aria-label="Sort options">
                    <span id="adsSortLabel">Newest first</span>
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-left: 4px;">
                        <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                
                <!-- Sort Dropdown Menu -->
                <div class="sort-dropdown" id="adsSortDropdown">
                    <button class="sort-option" data-sort="desc" onclick="setAdsSortOrder('desc')">
                        <span>Newest first</span>
                        <span class="sort-check" id="adsSortCheckDesc"></span>
                    </button>
                    <button class="sort-option" data-sort="asc" onclick="setAdsSortOrder('asc')">
                        <span>Oldest first</span>
                        <span class="sort-check" id="adsSortCheckAsc"></span>
                    </button>
                </div>
            </div>
            
            <!-- View Toggle -->
            <div class="ads-view-toggle" id="adsViewToggle">
                <button type="button" class="ads-view-toggle__btn active" data-view="grid" title="Grid view" onclick="setAdsViewMode('grid')">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <rect x="1" y="1" width="4" height="14" rx="1"/>
                        <rect x="6" y="1" width="4" height="10" rx="1"/>
                        <rect x="11" y="1" width="4" height="12" rx="1"/>
                    </svg>
                </button>
                <button type="button" class="ads-view-toggle__btn" data-view="kanban" title="Kanban view" onclick="setAdsViewMode('kanban')">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <rect x="1" y="1" width="6" height="6" rx="1"/>
                        <rect x="9" y="1" width="6" height="6" rx="1"/>
                        <rect x="1" y="9" width="6" height="6" rx="1"/>
                        <rect x="9" y="9" width="6" height="6" rx="1"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Filter Value Selection Dialog -->
        <div class="filter-dialog-overlay" id="adsFilterDialogOverlay" onclick="closeAdsFilterValueDialog()"></div>
        <div class="filter-value-dialog" id="adsFilterValueDialog">
            <div class="filter-value-dialog-header">
                <div class="filter-value-dialog-title" id="adsFilterValueDialogTitle">Select value</div>
                <button class="filter-value-dialog-close" onclick="closeAdsFilterValueDialog()">&times;</button>
            </div>
            <div class="filter-value-dialog-body" id="adsFilterValueDialogBody">
                <!-- Filter value options will be populated here -->
            </div>
        </div>

        <div class="ads-container">
            <div id="adsGrid" class="ads-grid"></div>
        </div>
    </div> <!-- End ads-section -->

    <!-- Settings Section -->
    <div id="settings-section" class="spa-section">
        <div class="control-bar" style="position: relative;">
            <h1 style="margin: 0; font-size: 20px; font-weight: 600; color: #37352f;">Settings</h1>
        </div>

        <div class="settings-container">
            <div class="settings-form">
                <!-- Brand URL -->
                <div class="settings-card">
                    <h2 class="settings-card-title">Brand Website</h2>
                    <p class="settings-card-description">Your company's main website URL.</p>
                    
                    <div class="settings-field">
                        <label for="settingsClientUrl">Website URL</label>
                        <input type="url" id="settingsClientUrl" placeholder="https://www.example.com">
                    </div>
                </div>

                <!-- Logo Settings -->
                <div class="settings-card">
                    <h2 class="settings-card-title">Brand Logo</h2>
                    <p class="settings-card-description">Your company logo displayed in the app header.</p>
                    
                    <div class="settings-logo-preview" id="settingsLogoPreview">
                        <span class="settings-logo-placeholder">No logo set</span>
                    </div>
                    
                    <div class="settings-field">
                        <label for="settingsLogoUrl">Logo URL</label>
                        <input type="url" id="settingsLogoUrl" placeholder="https://example.com/logo.png">
                    </div>
                    
                    <div class="settings-field">
                        <label for="settingsHeaderColor">Header Background Color</label>
                        <div class="settings-color-input">
                            <input type="color" id="settingsHeaderColorPicker" value="#FFFFFF">
                            <input type="text" id="settingsHeaderColor" placeholder="#FFFFFF" maxlength="7">
                        </div>
                    </div>
                </div>

                <!-- Business Context -->
                <div class="settings-card">
                    <h2 class="settings-card-title">Business Context</h2>
                    <p class="settings-card-description">A summary of your business that helps AI understand your company when generating insights and recommendations.</p>
                    
                    <div class="settings-field">
                        <label for="settingsBusinessSummary">Business Summary</label>
                        <textarea id="settingsBusinessSummary" rows="6" placeholder="Describe your business, products/services, target audience, and unique value proposition..."></textarea>
                    </div>
                </div>

                <!-- Tone of Voice -->
                <div class="settings-card">
                    <h2 class="settings-card-title">Tone of Voice</h2>
                    <p class="settings-card-description">Define your brand's voice and communication style to ensure consistent messaging in generated ad copy and content.</p>
                    
                    <div class="settings-field">
                        <label for="settingsToneOfVoice">Brand Voice Description</label>
                        <textarea id="settingsToneOfVoice" rows="6" placeholder="Describe your brand's tone of voice. For example: professional yet approachable, using clear language, avoiding jargon, emphasizing trust and reliability..."></textarea>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="settings-actions">
                    <button type="button" class="settings-save-btn" onclick="saveClientSettings()" id="settingsSaveBtn">
                        Save Settings
                    </button>
                    <span class="settings-save-status" id="settingsSaveStatus"></span>
                </div>
            </div>
        </div>
    </div> <!-- End settings-section -->
</body>
</html>


