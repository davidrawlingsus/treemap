<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHSFGWQMSN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZHSFGWQMSN');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#667eea">
    <title>Vizualizd | Marketably.ai</title>
    
    <!-- Lato font for marketing site header -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&display=swap" rel="stylesheet">
    
    <!-- Marketing site styles -->
    <link rel="stylesheet" href="/styles.css">
    
    <script src="/config.js"></script>
    <script src="/auth.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Tiptap WYSIWYG Editor - will be loaded as ES module when needed -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Lato', sans-serif;
            background: #fafafa;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }
        
        body.slideout-open {
            overflow: hidden;
        }

        .container {
            width: 100%;
            min-height: 100vh;
            margin: 0;
            background: #fafafa;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: clamp(20px, 5vw, 32px);
            font-weight: 600;
            margin-bottom: 10px;
        }

        .header p {
            font-size: clamp(14px, 3vw, 16px);
            opacity: 0.9;
        }
        
        .header .breadcrumb-display {
            font-size: clamp(12px, 2.5vw, 14px);
            opacity: 0.85;
            margin-top: 8px;
            font-weight: 500;
        }

        /* Login Screen styles moved to styles.css */

        .hidden {
            display: none !important;
        }

        /* App Navigation */
        .app-navigation {
            background: oklch(1 0 0); /* White */
            border-bottom: 1px solid oklch(0.922 0 0); /* Border color */
            padding: 0.75rem 1.5rem; /* 12px 24px */
            display: flex;
            align-items: center;
            justify-content: flex-start;
            position: sticky;
            top: 0;
            z-index: 101;
            font-family: 'Lato', sans-serif;
        }

        .nav-menu {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-menu-item {
            padding: 0.5rem 1rem; /* 8px 16px */
            color: oklch(0.556 0 0); /* Muted foreground */
            text-decoration: none;
            font-size: 1rem; /* 16px */
            font-weight: 500;
            font-family: 'Lato', sans-serif;
            border-radius: 0.375rem; /* 6px */
            transition: all 0.2s ease;
            position: relative;
        }

        .nav-menu-item:hover {
            color: oklch(0.145 0 0); /* Near black */
            background: oklch(0.97 0 0); /* Light gray */
        }

        .nav-menu-item.active {
            color: oklch(0.145 0 0); /* Near black */
            font-weight: 600;
        }

        .nav-menu-item.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 1rem;
            right: 1rem;
            height: 2px;
            background: #B9F040; /* Lime green underline */
            border-radius: 1px;
        }

        /* SPA Section Visibility */
        .spa-section {
            display: none !important;
            height: 0 !important;
            min-height: 0 !important;
            max-height: 0 !important;
            overflow: hidden !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .spa-section.active {
            display: block !important;
            height: auto !important;
            min-height: auto !important;
            max-height: none !important;
            overflow: visible !important;
            margin: initial !important;
            padding: initial !important;
        }
        
        /* When showing insights, allow container to size naturally */
        #mainContainer[data-view="insights"] {
            min-height: auto !important;
            height: auto !important;
        }

        .data-source-selector {
            padding: 18px 28px 22px;
            background: white;
            border-bottom: 1px solid #e4e6eb;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 18px;
            position: sticky;
            top: 48px; /* Below navigation */
            z-index: 100;
        }
        
        #dimensionNameEditor {
            display: flex;
        }

        .data-source-selector label {
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .data-source-selector select {
            padding: 10px 35px 10px 14px;
            border: 1px solid #d6d9df;
            border-radius: 6px;
            font-size: 15px;
            line-height: 1.35;
            min-height: 44px;
            width: 100%;
            cursor: pointer;
            color: #222;
            background-color: #fff;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .data-source-selector select:focus {
            outline: none;
            border-color: #B9F040;
            box-shadow: 0 0 0 1px #B9F040;
        }

        .data-source-selector__content {
            display: flex;
            align-items: center;
            gap: 24px;
            width: 100%;
            flex-wrap: wrap;
        }

        .filter-panels {
            display: flex;
            align-items: center;
            gap: 24px;
            flex-wrap: nowrap;
            overflow: hidden;
            min-width: 0;
        }

        .filter-panel {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            min-width: 0;
        }

        .filter-panel label {
            font-weight: 500;
            color: #333;
            font-size: 14px;
            flex-shrink: 0;
        }

        .filter-panel select {
            width: auto;
            min-width: 0;
            max-width: none;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
        }

        #questionSelect {
            width: auto;
            min-width: 0;
            max-width: none;
        }
        
        .filter-panel select option {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .filter-tabs {
            display: none;
            width: 100%;
            gap: 28px;
            overflow-x: auto;
        }

        .filter-tabs::-webkit-scrollbar {
            display: none;
        }

        .filter-tab {
            position: relative;
            background: none;
            border: none;
            padding: 0 0 14px;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #5c606b;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .filter-tab::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 2px;
            background: transparent;
            transition: background-color 0.2s ease;
        }

        .filter-tab:hover {
            color: #1a1c21;
        }

        .filter-tab.active {
            color: #111;
        }

        .filter-tab.active::after {
            background: #111;
        }

        .filter-tab.complete:not(.active) {
            color: #2f3540;
        }

        .filter-tab[disabled],
        .filter-tab.is-disabled,
        .filter-tab[aria-disabled="true"] {
            cursor: not-allowed;
            color: #c3c6ce;
        }

        .filter-tab[disabled]::after,
        .filter-tab.is-disabled::after,
        .filter-tab[aria-disabled="true"]::after {
            background: transparent;
        }

        .filter-tab:focus-visible {
            outline: none;
            color: #111;
        }

        .filter-tab:focus-visible::after {
            background: #111;
        }

        .data-source-actions {
            margin-left: auto;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
        }

        .filter-menu {
            position: relative;
        }

        .filter-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            position: relative;
            border: 1px solid #d6d9df;
            border-radius: 6px;
            background: #fff;
            color: #111;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
        }

        .filter-button:hover {
            border-color: #111;
            color: #111;
        }

        .filter-button:focus,
        .filter-button:focus-visible {
            outline: none;
            border-color: #111;
            box-shadow: 0 0 0 1px #111;
        }

        .filter-button img {
            width: 18px;
            height: 18px;
        }

        @media (max-width: 768px) {
            .filter-button {
                border: none;
                border-radius: 0;
                background: transparent;
            }
            
            .filter-button:hover {
                border: none;
            }
            
            .filter-button:focus-visible {
                border: none;
                box-shadow: none;
            }
        }

        .filter-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            border-radius: 999px;
            background: #111;
            color: #fff;
            font-size: 11px;
            font-weight: 600;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #insights-section .filter-button {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        #insights-section .filter-button:hover,
        #insights-section .filter-button:focus,
        #insights-section .filter-button:focus-visible {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .breadcrumbs {
            padding: 16px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 56px;
        }

        .breadcrumb {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .breadcrumb-item {
            padding: 6px 14px;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .breadcrumb-item:hover {
            background: #e8e8e8;
            color: #333;
        }

        .breadcrumb-item.current {
            color: #667eea;
            font-weight: 600;
            cursor: default;
        }

        .breadcrumb-separator {
            color: #ccc;
            font-size: 14px;
        }

        .treemap-section {
            width: 100%;
            padding: 30px 30px 0 30px;
            background: #fafafa;
            flex-shrink: 0;
        }

         .treemap-container {
             width: 100%;
             height: 75vh;
             min-height: 500px;
             max-height: 800px;
             background: white;
             border-radius: 8px;
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
             display: flex;
             flex-direction: column;
             position: relative;
             overflow: hidden;
             transition: height 0.3s ease-out, min-height 0.3s ease-out, max-height 0.3s ease-out;
         }

         .treemap-container.collapsed {
             height: auto;
             min-height: auto;
             max-height: none;
         }

         @media (max-width: 768px) {
             .treemap-container {
                 height: 70vh;
                 min-height: 500px;
                 max-height: 700px;
             }

             .treemap-container.collapsed {
                 height: auto;
                 min-height: auto;
                 max-height: none;
             }
         }

         @media (max-width: 480px) {
             .treemap-container {
                 height: 75vh;
                 min-height: 550px;
                 max-height: none;
             }

             .treemap-container.collapsed {
                 height: auto;
                 min-height: auto;
                 max-height: none;
             }
         }

        .treemap-header {
            padding: 20px 24px 16px 24px;
            border-bottom: 1px solid #E6EBF3;
        }

        .treemap-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .treemap-title {
            font-family: 'Lato', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
            flex: 1;
        }

        .treemap-subtitle {
            font-family: 'Lato', sans-serif;
            font-size: 13px;
            color: #8B93A7;
            margin: 4px 0 0 0;
            transition: margin 0.3s ease-out, opacity 0.3s ease-out;
        }

        .treemap-container.collapsed .treemap-subtitle {
            opacity: 0.7;
        }

        .treemap-search-container {
            position: relative;
            padding: 12px 24px;
            border-bottom: 1px solid #E6EBF3;
        }

        .treemap-container.collapsed .treemap-search-container {
            display: none;
        }

        .treemap-search-input-wrapper {
            position: relative;
            display: inline-block;
        }

        /* Bring search input and clear button above slideout overlay when search is active and slideout is visible */
        body.slideout-open .treemap-search-container.search-active .treemap-search-input-wrapper {
            position: relative;
            z-index: 10001;
        }

        body.slideout-open .treemap-search-container.search-active .treemap-search-input {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        body.slideout-open .treemap-search-container.search-active .treemap-search-clear {
            z-index: 10002;
        }

        .treemap-search-input {
            width: 300px;
            padding: 10px 40px 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .treemap-search-input:focus {
            outline: none;
            border-color: #B9F040;
            box-shadow: 0 0 0 3px rgba(185, 240, 64, 0.1);
        }

        .treemap-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: none;
            color: #999;
            font-size: 18px;
            line-height: 1;
            width: 24px;
            height: 24px;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background-color 0.2s, color 0.2s;
        }

        .treemap-search-clear:hover {
            background-color: #f0f0f0;
            color: #667eea;
        }

        .treemap-svg-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            overflow: hidden;
            width: 100%;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out;
            max-height: 2000px;
            opacity: 1;
        }

        .treemap-container.collapsed .treemap-svg-container {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
            min-height: 0;
            overflow: hidden;
        }

        .treemap-container.collapsed .chart__toggle-icon {
            transform: rotate(-90deg);
        }
        
        .treemap-svg-container svg {
            display: block;
            /* SVG dimensions are set via attributes in JavaScript */
            /* SVG will be centered by parent flex container */
        }

        .visualizations-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 50/50 split */
            gap: 30px;
            padding: 30px;
            margin: 0;
            align-items: start;
        }
        
        .visualizations-grid > .chart-column,
        .visualizations-grid > .chart {
            min-width: 0; /* Prevent grid items from overflowing */
        }

        .chart-column {
            display: flex;
            flex-direction: column;
            gap: 30px;
            transition: all 0.3s ease-out;
            min-width: 0; /* Prevent flex items from overflowing */
            width: 100%; /* Ensure it takes full width of grid column */
        }

        .favourites-section {
            transition: all 0.3s ease-out;
        }

        @media (max-width: 1024px) {
            .visualizations-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }

            .chart-column {
                display: contents;
            }

            .chart-column > .chart {
                order: 1;
            }

            .chart[aria-label="All Topics"] {
                order: 2;
            }

            .favourites-section {
                order: 3;
            }

            .treemap-section {
                padding: 20px 20px 0 20px;
            }

            .data-source-selector__content {
                gap: 18px;
            }

            .filter-panels {
                gap: 18px;
            }
        }

        @media (max-width: 768px) {
            .treemap-section {
                padding: 16px 16px 0 16px;
            }

            .treemap-header {
                padding: 16px 20px 12px 20px;
            }

            .treemap-title {
                font-size: 18px;
            }

            .treemap-subtitle {
                font-size: 12px;
            }

            .filter-tabs {
                display: flex;
            }

            .data-source-selector {
                padding: 16px 20px;
                gap: 12px;
            }

            .data-source-selector__content {
                flex-direction: row;
                align-items: center;
                gap: 12px;
            }

            .filter-panels {
                flex-direction: column;
                gap: 0;
                flex: 1;
                min-width: 0;
            }

            .filter-panel {
                display: none;
                width: 100%;
            }

            .filter-panel.active {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 12px;
            }

            .filter-panel label {
                display: none;
            }

            .filter-panel select {
                flex: 1;
                width: 100%;
                min-width: 0;
                max-width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .data-source-actions {
                margin-left: 0;
                width: auto;
                flex-shrink: 0;
            }

            .filter-menu {
                width: auto;
            }

            .filter-menu > button {
                width: auto;
            }

            #filterDropdown {
                left: auto;
                right: 0;
                min-width: 350px;
                max-width: 450px;
                width: auto;
            }

            #dimensionNameEditor {
                width: 100%;
                flex-wrap: wrap;
                gap: 10px;
            }

            #dimensionNameEditor select,
            #dimensionNameEditor input {
                flex: 1;
                min-width: 140px;
            }
        }

        .node {
            cursor: pointer;
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 3px;
            transition: filter 0.3s ease-in-out, transform 0.2s ease-in-out;
            rx: 5px;
            ry: 5px;
            touch-action: manipulation; /* Prevents double-tap zoom on nodes */
        }

        .node:hover {
            filter: brightness(1.1);
        }

        .node:active {
            filter: brightness(0.95);
            transform: scale(0.98);
        }

        .node-text {
            pointer-events: none;
            font-family: 'Lato', sans-serif;
            font-size: clamp(10px, 1.5vw, 14px);
            font-weight: 500;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .node-label {
            pointer-events: none;
            font-family: 'Lato', sans-serif;
            font-size: clamp(9px, 1.3vw, 12px);
            font-weight: 500;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            opacity: 0.95;
        }

        .category-label {
            pointer-events: none;
            font-family: 'Lato', sans-serif;
            font-weight: 600;
            font-size: clamp(10px, 1.6vw, 14px);
            fill: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .category-percent {
            pointer-events: none;
            font-family: 'Lato', sans-serif;
            font-weight: 500;
            font-size: 0.8rem;
            fill: white;
            opacity: 0.9;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10001;
            animation: fadeIn 0.3s ease-in-out;
        }

        .overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10002;
            min-width: 180px;
            padding: 4px 0;
            display: none;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item:active {
            background-color: #e8e8e8;
        }

        /* Insight Modal Styles */
        .insight-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10003;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-in-out;
        }

        .insight-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .insight-modal-header {
            padding: 24px;
            border-bottom: 1px solid #EBEBEB;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .insight-modal-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            color: #1A2B3C;
        }

        .insight-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .insight-modal-close:hover {
            background: #f5f5f5;
            color: #333;
        }

        .insight-form-group {
            padding: 0 24px;
            margin-bottom: 20px;
        }

        .insight-form-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .insight-form-group input,
        .insight-form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #EBEBEB;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }

        .insight-form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .insight-origin-preview {
            padding: 12px;
            background: #f8f9fa;
            border: 1px solid #EBEBEB;
            border-radius: 6px;
            font-size: 13px;
            color: #666;
        }

        .insight-origin-preview strong {
            color: #333;
        }

        .insight-modal-actions {
            padding: 24px;
            border-top: 1px solid #EBEBEB;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .insight-modal-cancel,
        .insight-modal-submit {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .insight-modal-cancel {
            background: white;
            color: #1A2B3C;
            border: 1px solid #EBEBEB;
        }

        .insight-modal-cancel:hover {
            background: #f5f5f5;
        }

        .insight-modal-submit {
            background: #B9F040;
            color: #1A2B3C;
        }

        .insight-modal-submit:hover {
            background: #A5D837;
        }

        .overlay-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid #e8e8e8;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease-in-out;
            overflow: hidden;
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .overlay-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: #000000;
            color: white;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        .overlay-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .settings-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease-in-out;
            padding: 0;
        }

        .settings-button img {
            opacity: 1;
            filter: none;
            transition: filter 0.2s ease-in-out, opacity 0.2s ease-in-out;
        }

        .settings-button:hover {
            background: rgba(185, 240, 64, 0.2);
            border-color: #B9F040;
            color: #B9F040;
            transform: scale(1.1);
        }

        .settings-button:hover img {
            filter: brightness(0) saturate(100%) invert(72%) sepia(98%) saturate(1352%) hue-rotate(50deg) brightness(1.05);
        }

        .settings-button.active {
            background: rgba(185, 240, 64, 0.2);
            border-color: #B9F040;
            color: #B9F040;
        }

        .settings-button.active img {
            filter: brightness(0) saturate(100%) invert(72%) sepia(98%) saturate(1352%) hue-rotate(50deg) brightness(1.05);
        }

        .settings-panel {
            position: absolute;
            top: 70px;
            right: 30px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            padding: 20px;
            min-width: 220px;
            z-index: 10002;
            display: none;
            animation: slideDown 0.2s ease-out;
        }

        .settings-panel.active {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-panel h3 {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 16px 0;
            color: #333;
        }

        .settings-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .settings-option:last-child {
            margin-bottom: 0;
        }

        .settings-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #B9F040;
        }

        .settings-option label {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            color: #555;
            cursor: pointer;
            user-select: none;
        }

        .overlay-title {
            font-family: 'Lato', sans-serif;
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }

        .overlay-subtitle {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            opacity: 0.9;
            margin-top: 4px;
        }

        .close-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease-in-out;
            line-height: 1;
            padding: 0;
        }

        .close-button:hover {
            background: rgba(185, 240, 64, 0.2);
            border-color: #B9F040;
            color: #B9F040;
            transform: scale(1.1);
        }

        .verbatim-container {
            columns: 280px;
            column-gap: 20px;
            padding: 30px;
            background: #fafafa;
            overflow-y: auto;
            flex: 1;
            box-sizing: border-box;
        }

        .verbatim-card {
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease-in-out;
            min-height: 80px;
            height: auto;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: visible;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            break-inside: avoid;
            page-break-inside: avoid;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .verbatim-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border-color: #d0d0d0;
        }

        .verbatim-text {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 16px;
            flex: 0 1 auto;
            min-width: 0;
            width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            hyphens: auto;
        }

        .verbatim-text p {
            margin-bottom: 8px;
        }

        .search-highlight {
            background-color: rgba(185, 240, 64, 0.3) !important;
            padding: 2px 2px;
            border-radius: 2px;
            font-weight: 500;
            color: inherit;
        }

        .verbatim-meta {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #f0f0f0;
            padding-top: 12px;
            flex-shrink: 0;
        }

        .verbatim-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .verbatim-meta-label {
            font-weight: 600;
            color: #555;
        }

        .sentiment {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sentiment-positive {
            background: #E8F5E9;
            color: #2E7D32;
        }

        .sentiment-neutral {
            background: #E3F2FD;
            color: #1565C0;
        }

        .sentiment-negative {
            background: #FFEBEE;
            color: #C62828;
        }

        .verbatim-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #f0f0f0;
        }

        .verbatim-metadata-item {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            color: #555;
            white-space: nowrap;
            line-height: 1.4;
        }

        .verbatim-metadata-item.sentiment-positive {
            background: #E8F5E9;
            border-color: #C8E6C9;
            color: #2E7D32;
        }

        .verbatim-metadata-item.sentiment-neutral {
            background: #E3F2FD;
            border-color: #BBDEFB;
            color: #1565C0;
        }

        .verbatim-metadata-item.sentiment-negative {
            background: #FFEBEE;
            border-color: #FFCDD2;
            color: #C62828;
        }

        .verbatim-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .favourite-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ccc;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-left: 12px;
        }

        .favourite-button:hover {
            color: #ffa500;
            transform: scale(1.1);
        }

        .favourite-button.active {
            color: #ffa500;
        }

        .favourite-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .favourites-section {
            padding: 24px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .insights-panel-container {
            margin: 0; /* Remove margin since chart-column already has gap */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 2px solid #EBEBEB;
            width: 100%; /* Match width of chart above */
            min-width: 0; /* Prevent overflow */
        }

        .insights-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #EBEBEB;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        .insights-panel-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .insights-panel-header-left h2 {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .insights-filter-badge {
            background: #B9F040;
            color: #1A2B3C;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .insights-panel-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn-primary-small {
            background: #B9F040;
            color: #1A2B3C;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
        }

        .btn-link {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            text-decoration: underline;
        }

        .insights-panel-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s, transform 0.2s;
            border-radius: 4px;
        }
        
        .insights-panel-toggle:hover {
            color: #333;
            background: #f0f0f0;
        }
        
        .insights-panel-toggle-icon {
            transition: transform 0.2s;
        }
        
        .insights-panel-container.collapsed .insights-panel-toggle-icon {
            transform: rotate(-90deg);
        }

        .insights-panel-body {
            transition: max-height 0.3s ease-out;
            padding: 0 24px calc(24px + 0.5rem) 24px;
        }

        .insights-panel-body.collapsed {
            max-height: 0;
            overflow: hidden;
        }

        /* Insights Table Section */
        .insights-table-section {
            padding: 0;
        }

        /* Override table width for insights panel to fit container */
        .insights-table-section .table-container {
            overflow-x: visible;
        }

        .insights-table-section .notion-table {
            min-width: auto;
            width: 100%;
            table-layout: fixed;
        }

        /* Hide drag handles and column icons in insights panel */
        .insights-table-section .notion-table th .drag-handle,
        .insights-table-section .notion-table th .column-icon {
            display: none;
        }

        /* Override name-cell padding and width in insights panel (no checkbox column) */
        .insights-table-section .notion-table .name-cell,
        .insights-table-section .notion-table th.name-cell {
            padding-left: 0.75rem;
            min-width: auto;
            width: 60%;
            max-width: 60%;
        }

        /* Created column takes remaining space */
        .insights-table-section .notion-table th[data-column="created_at"],
        .insights-table-section .notion-table td[data-column="created_at"] {
            width: 40%;
            max-width: 40%;
        }

        /* Fixed width for Status column in insights section */
        #insights-section .notion-table th[data-column="status"],
        #insights-section .notion-table td[data-column="status"] {
            width: 190px;
            min-width: 190px;
            max-width: 190px;
            text-align: center;
        }

        /* Center the status dropdown in the column */
        #insights-section .notion-table td[data-column="status"] {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #insights-section .notion-table td[data-column="status"] .status-select {
            margin: 0;
        }

        /* Name column takes remaining space in insights section */
        #insights-section .notion-table .name-cell,
        #insights-section .notion-table th.name-cell {
            width: auto;
            min-width: 250px;
        }

        /* Font size for insight rows and pills */
        #insights-section .notion-table td {
            font-size: 15px;
        }

        #insights-section .tag {
            font-size: 15px;
        }

        /* Control Bar */
        .control-bar {
            position: relative;
            padding: 0.5rem 1.5rem;
            border-bottom: 1px solid oklch(0.922 0 0);
            background: oklch(1 0 0);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            min-height: 40px;
        }

        .search-box {
            display: flex;
            align-items: center;
            background: oklch(0.97 0 0);
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            min-width: 200px;
            flex: 0 0 auto;
        }

        .search-box input {
            border: none;
            background: transparent;
            outline: none;
            font-size: 0.875rem;
            font-family: 'Lato', sans-serif;
            padding: 0.125rem 0.25rem;
            flex: 1;
            color: oklch(0.145 0 0);
        }

        .search-box input::placeholder {
            color: oklch(0.556 0 0);
        }

        .filter-chips {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
            flex: 1;
        }

        .filter-chip {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.25rem 0.5rem;
            background: oklch(0.97 0 0);
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            color: oklch(0.145 0 0);
        }

        .filter-chip .remove {
            cursor: pointer;
            opacity: 0.6;
            padding: 0 0.125rem;
        }

        .filter-chip .remove:hover {
            opacity: 1;
        }

        /* Inline Filter Dropdown */
        .inline-filter-dropdown {
            position: relative;
            display: inline-block;
            margin-right: 0.5rem;
        }

        .inline-filter-header {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.25rem 0.5rem;
            background: oklch(0.97 0 0);
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            color: oklch(0.145 0 0);
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }

        .inline-filter-header:hover {
            background: oklch(0.95 0 0);
            border-color: rgba(55, 53, 47, 0.24);
        }

        .inline-filter-header.open {
            background: white;
            border-color: #B9F040;
            box-shadow: 0 0 0 2px rgba(185, 240, 64, 0.2);
        }

        .inline-filter-icon {
            opacity: 0.6;
            font-size: 0.875rem;
        }

        .inline-filter-label {
            flex: 1;
            font-weight: 500;
        }

        .inline-filter-chevron {
            opacity: 0.4;
            font-size: 0.75rem;
            transition: transform 0.2s;
        }

        .inline-filter-header.open .inline-filter-chevron {
            transform: rotate(180deg);
        }

        .inline-filter-options {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            background: white;
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 0.375rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 200px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
            padding: 4px 0;
        }

        .inline-filter-options.open {
            display: block;
        }

        .inline-filter-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            color: oklch(0.145 0 0);
            transition: background 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inline-filter-option:hover {
            background: rgba(55, 53, 47, 0.06);
        }

        .inline-filter-option.selected {
            background: rgba(185, 240, 64, 0.2);
            font-weight: 500;
        }

        .inline-filter-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            margin: 0;
            flex-shrink: 0;
            accent-color: #B9F040;
            appearance: checkbox;
            -webkit-appearance: checkbox;
            -moz-appearance: checkbox;
        }
        
        /* Debug: Force checkbox visibility */
        .inline-filter-checkbox:checked {
            accent-color: #B9F040 !important;
        }
        
        /* Additional debug styling */
        .inline-filter-checkbox::before {
            content: '';
            display: none;
        }

        .inline-filter-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inline-filter-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: white;
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: rgba(55, 53, 47, 0.6);
            z-index: 10;
            transition: all 0.2s;
            line-height: 1;
        }

        .inline-filter-remove:hover {
            background: rgba(220, 38, 38, 0.1);
            border-color: rgba(220, 38, 38, 0.3);
            color: rgba(220, 38, 38, 0.8);
        }

        .btn-filter {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: none;
            color: oklch(0.556 0 0);
            cursor: pointer;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
        }

        .btn-filter:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
        }

        .btn-reset {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: none;
            color: oklch(0.556 0 0);
            cursor: pointer;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
        }

        .btn-reset:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
        }

        .btn-delete {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: none;
            color: oklch(0.556 0 0);
            cursor: pointer;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
        }

        .btn-delete:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.8 0.15 25);
        }

        /* Filter Dropdown Menu */
        .filter-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 280px;
            max-width: 320px;
            max-height: 500px;
            z-index: 1000;
            display: none;
            overflow: hidden;
            margin-top: 4px;
        }

        .filter-dropdown.active {
            display: block;
        }

        .filter-dropdown-search {
            padding: 12px;
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
        }

        .filter-dropdown-search input {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid #4285f4;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            outline: none;
            box-sizing: border-box;
        }

        .filter-dropdown-search input::placeholder {
            color: rgba(55, 53, 47, 0.4);
        }

        .filter-dropdown-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 4px 0;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            color: rgba(55, 53, 47, 0.8);
            transition: background 0.1s;
        }

        .filter-option:hover {
            background: rgba(55, 53, 47, 0.06);
        }

        .filter-option-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.6;
            font-size: 14px;
        }

        .filter-option-text {
            flex: 1;
        }

        .filter-active-filters {
            padding: 8px 12px;
            border-top: 1px solid rgba(55, 53, 47, 0.09);
            background: rgba(55, 53, 47, 0.03);
            max-height: 150px;
            overflow-y: auto;
        }

        .filter-active-filters-title {
            font-size: 12px;
            font-weight: 500;
            color: rgba(55, 53, 47, 0.6);
            margin-bottom: 6px;
        }

        .filter-active-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 8px;
            margin-bottom: 4px;
            background: white;
            border-radius: 3px;
            font-size: 12px;
        }

        .filter-active-item-remove {
            cursor: pointer;
            opacity: 0.6;
            padding: 0 4px;
            font-size: 16px;
            line-height: 1;
        }

        .filter-active-item-remove:hover {
            opacity: 1;
        }

        .filter-value-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            min-width: 300px;
            max-width: 400px;
            max-height: 500px;
            z-index: 2000;
            display: none;
        }

        .filter-value-dialog.active {
            display: block;
        }

        .filter-value-dialog-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-value-dialog-title {
            font-size: 14px;
            font-weight: 600;
            color: rgba(55, 53, 47, 0.8);
            font-family: 'Lato', sans-serif;
        }

        .filter-value-dialog-close {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: rgba(55, 53, 47, 0.6);
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background 0.1s;
        }

        .filter-value-dialog-close:hover {
            background: rgba(55, 53, 47, 0.06);
        }

        .filter-value-dialog-body {
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .filter-value-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
            margin-bottom: 4px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            color: rgba(55, 53, 47, 0.8);
            transition: background 0.1s;
        }

        .filter-value-option:hover {
            background: rgba(55, 53, 47, 0.06);
        }

        .filter-value-option.selected {
            background: rgba(185, 240, 64, 0.2);
            font-weight: 500;
        }

        .filter-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1999;
            display: none;
        }

        .filter-dialog-overlay.active {
            display: block;
        }

        /* Table */
        .table-container {
            overflow-x: auto;
            background: oklch(1 0 0);
        }

        .notion-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1200px;
        }

        .notion-table thead {
            background: oklch(0.98 0 0);
            border-bottom: 1px solid oklch(0.922 0 0);
        }

        .notion-table th {
            padding: 0.5rem 0.75rem;
            text-align: left;
            font-weight: 500;
            font-size: 0.8125rem;
            font-family: 'Lato', sans-serif;
            color: oklch(0.556 0 0);
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            position: relative;
            border-right: 1px solid oklch(0.92 0 0);
            border-bottom: 1px solid oklch(0.92 0 0);
        }

        .notion-table th:hover {
            background: oklch(0.97 0 0);
        }

        .notion-table th .sort-indicator {
            margin-left: 0.25rem;
            opacity: 0.4;
        }

        .notion-table th.sorted .sort-indicator {
            opacity: 1;
        }

        .notion-table th .column-icon {
            margin-right: 0.375rem;
            opacity: 0.4;
        }

        .notion-table tbody tr {
            transition: background 0.1s;
        }

        .notion-table tbody tr:hover {
            background: oklch(0.98 0 0);
        }

        .notion-table tbody tr:hover .insight-open-btn-table {
            display: flex !important;
        }

        .insight-open-btn-table {
            display: none;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(55, 53, 47, 0.1);
            border-radius: 0.375rem;
            color: oklch(0.556 0 0);
            font-size: 0.75rem;
            font-weight: 500;
            font-family: 'Lato', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .insight-open-btn-table:hover {
            background: oklch(0.95 0 0);
            color: oklch(0.145 0 0);
        }

        .notion-table td {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-family: 'Lato', sans-serif;
            vertical-align: middle;
            border-right: 1px solid oklch(0.92 0 0);
            border-bottom: 1px solid oklch(0.92 0 0);
        }

        .notion-table .checkbox-cell {
            width: 32px;
            padding: 0.5rem;
            text-align: center;
        }

        .notion-table .checkbox {
            width: 16px;
            height: 16px;
            border: 1.5px solid oklch(0.85 0 0);
            border-radius: 0.375rem;
            cursor: pointer;
            display: inline-block;
            transition: all 0.2s ease;
        }

        .notion-table .checkbox:hover {
            border-color: oklch(0.7 0 0);
        }

        .notion-table .name-cell {
            min-width: 250px;
            font-weight: 500;
            padding-left: 35px;
        }

        .notion-table th.name-cell {
            padding-left: 35px;
        }

        .notion-table .name-cell .name-content {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            position: relative;
            /* No padding-right - OPEN button overlays on hover */
        }

        .notion-table .name-cell .doc-icon {
            width: 16px;
            height: 16px;
            opacity: 0.4;
            flex-shrink: 0;
        }

        /* Tags/Pills */
        .tag {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            font-weight: 400;
            font-family: 'Lato', sans-serif;
            margin-right: 0.25rem;
            margin-bottom: 0.125rem;
        }

        .tag-type {
            background: rgba(46, 170, 220, 0.15);
            color: #2eaadc;
        }

        .tag-project {
            background: rgba(255, 171, 0, 0.15);
            color: #ffab00;
        }

        .tag-data-source {
            background: rgba(99, 71, 169, 0.15);
            color: #6347a9;
        }

        /* Status */
        .status {
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-dot.not-started {
            background: #d1d1d1;
        }

        .status-dot.in-progress {
            background: #0b85ff;
        }

        .status-dot.done {
            background: #0f7b0f;
        }

        .status-select {
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            background: white;
            color: #37352f;
            cursor: pointer;
            min-width: 140px;
            font-family: 'Lato', sans-serif;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239ca3af' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 32px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .status-select:hover {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .status-select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(185, 240, 64, 0.15), 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .status-select:active {
            transform: translateY(0);
        }

        /* Actions */
        .actions-cell {
            width: 80px;
        }

        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            color: oklch(0.7 0 0);
            font-size: 0.875rem;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
        }

        /* Checkbox Column */
        .checkbox-cell {
            width: 40px;
            text-align: center;
            padding: 0.5rem;
        }

        .checkbox-cell input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .notion-table tbody tr:hover .checkbox-cell {
            background: oklch(0.98 0 0);
        }

        /* Empty State */
        .empty-state {
            padding: 3.75rem 1.5rem;
            text-align: center;
            color: oklch(0.556 0 0);
        }

        .empty-state h3 {
            font-size: 1rem;
            font-family: 'Lato', sans-serif;
            margin-bottom: 0.5rem;
            color: oklch(0.556 0 0);
        }

        .loading {
            padding: 2.5rem;
            text-align: center;
            color: oklch(0.556 0 0);
            font-family: 'Lato', sans-serif;
        }

        .favourites-section h2 {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
        }

        .favourites-search-container {
            position: relative;
            margin-bottom: 24px;
        }

        .favourites-search-input {
            width: 100%;
            padding: 10px 40px 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .favourites-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .favourites-search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: none;
            color: #999;
            font-size: 18px;
            line-height: 1;
            width: 24px;
            height: 24px;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background-color 0.2s, color 0.2s;
        }

        .favourites-search-clear:hover {
            background-color: #f0f0f0;
            color: #667eea;
        }

        .favourites-search-clear.active {
            display: flex;
        }

        .favourites-container {
            columns: 280px;
            column-gap: 20px;
            padding: 0;
        }

        .favourites-empty {
            padding: 40px 20px 20px;
            column-span: all;
            width: 100%;
            display: block;
        }

        .favourites-empty-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            grid-auto-rows: 150px;
            gap: 24px;
            justify-content: center;
            width: 100%;
        }

        @media (max-width: 1024px) {
            .favourites-empty-grid {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                grid-auto-rows: 150px;
            }
        }

        @media (max-width: 768px) {
            .favourites-empty-grid {
                grid-template-columns: minmax(0, 1fr);
                grid-auto-rows: 140px;
            }
        }

        .favourites-empty p {
            font-size: 16px;
            margin-bottom: 20px;
        }

        .skeleton-card {
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .skeleton-line {
            height: 12px;
            background: #f0f0f0;
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .skeleton-line:last-child {
            width: 60%;
        }

        .stats {
            padding: 24px 30px;
            background: white;
            border-bottom: 1px solid #e8e8e8;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 30px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Lato', sans-serif;
            font-size: 36px;
            font-weight: 700;
            color: #667eea;
            display: block;
            line-height: 1;
        }

        .stat-label {
            font-family: 'Lato', sans-serif;
            font-size: 13px;
            color: #888;
            margin-top: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .loading {
            text-align: center;
            font-size: 18px;
            color: #667eea;
            font-family: 'Lato', sans-serif;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Skeleton loading states */
        .is-loading {
            position: relative;
        }

        .skeleton-shimmer {
            animation: shimmer 1.2s infinite linear, pulse 2s infinite ease-in-out;
            background: linear-gradient(90deg, rgba(240,242,247,0.9) 25%, rgba(231,234,243,0.9) 37%, rgba(240,242,247,0.9) 63%);
            background-size: 400% 100%;
            border-radius: 6px;
        }

        @keyframes shimmer {
            0% { background-position: 100% 0; }
            100% { background-position: 0 0; }
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1);
            }
            50% { 
                opacity: 0.8;
                transform: scale(1.02);
            }
        }

        /* Treemap skeleton */
        .treemap-svg-container.is-loading::before {
            content: '';
            display: block;
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            bottom: 16px;
            min-height: 220px;
            background: #f3f5fa;
            border: 1px dashed #e2e6f0;
            border-radius: 8px;
            animation: pulse 2s infinite ease-in-out;
        }

        .treemap-svg-container.is-loading::after {
            content: '';
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            bottom: 16px;
            min-height: 220px;
            border-radius: 8px;
            opacity: 0.7;
        }

        /* Chart skeletons */
        .chart.is-loading .chart__labels,
        .chart.is-loading .chart__bars {
            position: relative;
            min-height: 140px;
        }

        .chart.is-loading .chart__labels::before,
        .chart.is-loading .chart__labels::after,
        .chart.is-loading .chart__bars::before,
        .chart.is-loading .chart__bars::after {
            content: '';
            display: block;
            height: 12px;
            margin: 10px 0;
            background: #eef1f7;
            border-radius: 6px;
            animation: pulse 2s infinite ease-in-out;
        }

        .chart.is-loading .chart__labels::before { 
            width: 60%; 
            animation-delay: 0s;
        }
        .chart.is-loading .chart__labels::after { 
            width: 45%; 
            animation-delay: 0.3s;
        }
        .chart.is-loading .chart__bars::before { 
            width: 80%; 
            animation-delay: 0.1s;
        }
        .chart.is-loading .chart__bars::after { 
            width: 35%; 
            animation-delay: 0.4s;
        }

        /* Hide real content when loading */
        .is-loading svg,
        .chart.is-loading .chart__labels > *,
        .chart.is-loading .chart__bars > * {
            opacity: 0;
            pointer-events: none;
        }

        .error {
            text-align: center;
            color: #dc3545;
            font-family: 'Lato', sans-serif;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @media (max-width: 768px) {
            .node {
                stroke-width: 2px;
            }

            .header {
                padding: 20px 16px;
            }

            .breadcrumbs {
                padding: 12px 16px;
                min-height: 48px;
            }

            .breadcrumb-item {
                padding: 5px 10px;
                font-size: 12px;
            }

            .overlay-content {
                width: 95%;
                height: 90vh;
                height: calc(var(--vh, 1vh) * 90);
                border-radius: 8px;
                overflow: hidden;
            }

            .overlay-header {
                padding: 16px 20px;
                border-radius: 8px 8px 0 0;
            }

            .overlay-title {
                font-size: 16px;
            }

            .overlay-subtitle {
                font-size: 12px;
            }

            .verbatim-container {
                columns: 1;
                column-gap: 16px;
                padding: 16px;
                min-height: 0;
                overflow-y: auto;
            }

            .favourites-container {
                columns: 1;
                column-gap: 16px;
            }

            .verbatim-card {
                padding: 16px;
            }

            .verbatim-text {
                font-size: 13px;
            }

            .close-button {
                width: 36px;
                height: 36px;
                font-size: 24px;
            }

            .stats {
                padding: 16px 20px;
                gap: 20px;
            }

            .stat-value {
                font-size: 28px;
            }

            .stat-label {
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 16px 12px;
            }

            .header h1 {
                margin-bottom: 6px;
            }

            .breadcrumbs {
                padding: 10px 12px;
            }

            .overlay-content {
                width: 100%;
                height: 100vh;
                height: calc(var(--vh, 1vh) * 100);
                border-radius: 0;
                max-height: none;
                overflow: hidden;
            }

            .overlay-header {
                padding: 12px 16px;
                border-radius: 0;
            }

            .verbatim-container {
                columns: 1;
                column-gap: 12px;
                padding: 12px;
                min-height: 0;
                overflow-y: auto;
            }

            .favourites-container {
                columns: 1;
                column-gap: 12px;
            }

            .verbatim-card {
                padding: 14px;
            }

            .stat-value {
                font-size: 24px;
            }
        }

        /* Tablet landscape orientation */
        @media (min-width: 769px) and (max-width: 1024px) {
            .verbatim-container {
                columns: 2;
            }

            .favourites-container {
                columns: 2;
            }
        }

        /* Very small screens - ensure cards are visible */
        @media (max-width: 360px) {
            .verbatim-container {
                columns: 1;
                column-gap: 8px;
                padding: 8px;
                min-height: 0;
                overflow-y: auto;
            }

            .favourites-container {
                columns: 1;
                column-gap: 8px;
            }
            
            .verbatim-card {
                padding: 12px;
                min-height: 60px;
                width: 100%;
                box-sizing: border-box;
            }
            
            .verbatim-text {
                font-size: 12px;
                line-height: 1.4;
            }
            
            .overlay-content {
                height: 100vh;
                height: calc(var(--vh, 1vh) * 100);
                max-height: 100vh;
            }
        }

        /* Dimension Editor Styles */
        .dimension-editor-container {
            padding: 30px;
            background: #fafafa;
            overflow-y: auto;
            flex: 1;
        }

        .dimension-editor-item {
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            transition: all 0.3s ease-in-out;
        }

        .dimension-editor-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .dimension-ref {
            font-weight: 600;
            color: #667eea;
            min-width: 80px;
            font-size: 14px;
        }

        .dimension-select {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            transition: all 0.2s ease-in-out;
            background: white;
            cursor: pointer;
        }

        .dimension-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .dimension-custom-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Lato', sans-serif;
            transition: all 0.2s ease-in-out;
            display: none;
        }

        .dimension-custom-input.active {
            display: block;
        }

        .dimension-custom-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .dimension-controls {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        .manage-options-btn {
            padding: 8px 16px;
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }

        .manage-options-btn:hover {
            background: #e0e0e0;
        }

        .dimension-actions {
            display: flex;
            gap: 8px;
        }

        .dimension-save-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }

        .dimension-save-btn:hover {
            background: #5568d3;
        }

        .dimension-save-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .dimension-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e8e8e8;
        }

        .dimension-editor-actions {
            display: flex;
            gap: 12px;
        }

        .save-all-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
        }

        .save-all-btn:hover {
            background: #5568d3;
        }

        .save-all-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .dimension-status {
            font-size: 13px;
            color: #666;
            font-style: italic;
        }

        .dimension-status.saved {
            color: #2E7D32;
        }

        .dimension-status.unsaved {
            color: #C62828;
        }

        /* Bar Chart Styles */
        .chart {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: padding 0.3s ease-out;
            width: 100%; /* Ensure chart takes full width of its container */
            min-width: 0; /* Prevent overflow */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .chart.collapsed {
            padding: 16px 24px;
            align-self: start;
            height: auto;
        }

        .chart.collapsed .chart__header {
            margin-bottom: 0;
        }

        .chart__header {
            margin-bottom: 8px;
        }

        .chart__header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .chart__title {
            font-family: 'Lato', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
            flex: 1;
        }

        .chart__toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: color 0.2s, transform 0.2s;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .chart__toggle:hover {
            color: #333;
            background: #f0f0f0;
        }

        .chart__toggle-icon {
            transition: transform 0.2s;
        }

        .chart.collapsed .chart__toggle-icon {
            transform: rotate(-90deg);
        }

        .chart__subtitle {
            font-family: 'Lato', sans-serif;
            font-size: 13px;
            color: #8B93A7;
            margin: 4px 0 16px 0;
            transition: margin 0.3s ease-out, opacity 0.3s ease-out;
        }

        .chart.collapsed .chart__subtitle {
            margin-bottom: 0;
            opacity: 0.7;
        }

        .chart__body {
            position: relative;
            display: flex;
            gap: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out;
            max-height: 2000px;
            opacity: 1;
        }

        .chart.collapsed .chart__body {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
            min-height: 0;
        }

        .chart__footer {
            transition: opacity 0.3s ease-out, max-height 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out;
            overflow: hidden;
        }

        .chart.collapsed .chart__footer {
            opacity: 0;
            max-height: 0;
            margin: 0;
            padding: 0;
        }

        .chart__labels {
            width: 240px;
            flex-shrink: 0;
        }

        .chart__bars {
            flex: 1;
            position: relative;
            min-width: 0;
        }

        .gridlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 24px;
            pointer-events: none;
        }

        .gridline {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #E6EBF3;
        }

        .axis--bottom {
            display: flex;
            position: relative;
            height: 20px;
            margin-top: 4px;
        }

        .axis__label {
            position: absolute;
            font-size: 12px;
            color: #98A1B3;
            transform: translateX(-50%);
        }

        .group {
            margin-bottom: 3px;
        }

        .group__header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            height: 32px;
        }

        .toggle {
            width: 20px;
            height: 20px;
            border: 1px solid #E5EAF2;
            border-radius: 4px;
            background: white;
            color: #7A8194;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding: 0;
            margin: 0;
            transition: background 0.2s ease-in-out;
        }

        .toggle:hover {
            background: #F4F6FA;
        }

        .toggle:focus {
            outline: none;
        }

        .group__label-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-left: 6px;
            flex: 1;
            min-width: 0;
        }

        .group__label {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #5B6275;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .group__bar-container {
            position: relative;
            height: 32px;
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .bar__track {
            position: absolute;
            left: 0;
            height: 16px;
            background: rgba(0, 0, 0, 0.04);
            border-radius: 9999px;
            width: 100%;
        }

        .bar__fill {
            position: absolute;
            left: 0;
            height: 16px;
            border-radius: 9999px;
            transition: width 0.6s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .bar__value {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 1;
        }

        .bar__value--inside {
            position: relative;
            color: white;
            padding-right: 8px;
        }

        .bar__value--outside {
            position: absolute;
            color: #6B7280;
            padding-left: 8px;
        }

         .group__panel {
             overflow: hidden;
             transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
         }

         .group__panel[hidden] {
             display: block;
             max-height: 0;
             opacity: 0;
             pointer-events: none;
         }

         .group__panel:not([hidden]) {
             max-height: 2000px;
             opacity: 1;
             pointer-events: auto;
         }

         .topic {
             display: flex;
             align-items: center;
             margin-bottom: 6px;
             height: 32px;
             cursor: pointer;
             transition: background-color 0.2s ease-in-out;
             border-radius: 4px;
             padding: 2px 0;
             box-sizing: border-box;
         }

         .topic:hover {
             background-color: rgba(102, 126, 234, 0.05);
         }

         .topic:hover .topic__label {
             color: #667eea;
         }

         .topic__label-wrapper {
             display: flex;
             align-items: center;
             gap: 8px;
             padding-left: 28px;
         }

        .bullet {
            width: 10px;
            height: 6px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .topic__label {
            font-family: 'Lato', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #6B7280;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

         .topic__bar-container {
             position: relative;
             height: 32px;
             display: flex;
             align-items: center;
             margin-bottom: 6px;
         }

         .topic__bar-container[style*="cursor: pointer"]:hover .bar__fill {
             filter: brightness(1.1);
         }

        .topic .bar__fill {
            height: 14px;
        }

        .topic .bar__track {
            height: 14px;
        }
        
        .group__panel .topic__bar-container {
            margin-bottom: 6px;
        }

        .chart__footer {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #E6EBF3;
            font-size: 12px;
            color: #8B93A7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .chart__labels {
                width: 180px;
            }

            .group__label {
                font-size: 13px;
            }

            .topic__label {
                font-size: 12px;
            }

            .bar__fill, .bar__track {
                height: 14px !important;
            }

            .topic .bar__fill, .topic .bar__track {
                height: 12px !important;
            }
        }
        
        /* AI Insights Slideout Styles */
        .ai-insights-tab {
            position: fixed;
            right: 0;
            top: calc(50% + 60px);
            transform: translateY(-50%);
            background: linear-gradient(135deg, #b9f040 0%, #a0d635 100%);
            color: #1a1a1a;
            padding: 16px 12px;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            box-shadow: -2px 2px 8px rgba(0,0,0,0.15);
            z-index: 10001;
            transition: all 0.3s ease;
            display: none; /* Hidden by default until dimension is selected */
        }
        
        /* TEMPORARILY HIDDEN: AI Insights tab hidden until further notice */
        #slideoutTab {
            display: none !important;
        }

        .ai-insights-tab:hover {
            background: linear-gradient(135deg, #c7ff4d 0%, #b9f040 100%);
            padding-right: 16px;
        }

        .ai-insights-panel {
            position: fixed;
            right: -520px;
            top: 0;
            width: 500px;
            height: 100vh;
            background: oklch(1 0 0); /* White from style guide */
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            z-index: 10000;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border-top: 3px solid #B9F040; /* Brand lime green */
        }

        .ai-insights-panel.open {
            right: 0;
        }

        .ai-insights-header {
            padding: 1.25rem 1.5rem 1rem 1.5rem; /* 20px 24px 16px 24px */
            border-bottom: 1px solid oklch(0.922 0 0); /* Border color from style guide */
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: oklch(1 0 0); /* White */
            gap: 12px;
        }

        .slideout-back-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            display: none;
            align-items: center;
            justify-content: center;
            color: oklch(0.556 0 0);
            border-radius: 4px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .slideout-back-button:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
        }

        .slideout-back-button:active {
            transform: scale(0.95);
        }

        .insight-breadcrumb {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 0.875rem;
            font-family: 'Lato', sans-serif;
            color: oklch(0.556 0 0);
        }

        .insight-breadcrumb-item {
            color: oklch(0.556 0 0);
        }

        .insight-breadcrumb-item--clickable {
            color: oklch(0.4 0.15 240);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .insight-breadcrumb-item--clickable:hover {
            color: oklch(0.3 0.2 240);
            text-decoration: underline;
        }

        .insight-breadcrumb-separator {
            color: oklch(0.7 0 0);
            margin: 0 4px;
        }

        .chart-view-highlighted {
            background: oklch(0.95 0.1 120) !important;
            border: 2px solid #B9F040 !important;
            border-radius: 4px;
        }

        .chart-view-highlighted-topic {
            background: oklch(0.97 0.05 120) !important;
            border-left: 3px solid #B9F040 !important;
            padding-left: 8px !important;
        }

        .ai-insights-header h2,
        #slideoutTitle {
            font-size: 1.5rem; /* 24px */
            font-weight: 600;
            margin: 0;
            color: oklch(0.145 0 0);
            font-family: 'Lato', sans-serif;
        }

        #slideoutTitle[contenteditable="true"]:focus {
            outline: none;
        }

        #slideoutTitle[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: oklch(0.556 0 0);
        }

        /* Remove focus outline from Tiptap editor */
        .tiptap:focus,
        .ProseMirror:focus,
        .ProseMirror-focused {
            outline: none !important;
            border: none !important;
        }

        #insightNotesEditor .tiptap:focus,
        #insightNotesEditor .ProseMirror:focus,
        #insightNotesEditor .ProseMirror-focused {
            outline: none !important;
            border: none !important;
        }

        /* Minimize empty paragraphs in editor */
        #insightNotesEditor .tiptap p:empty,
        #insightNotesEditor .ProseMirror p:empty {
            min-height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            line-height: 1.2 !important;
        }

        /* Blockquote styling */
        #insightNotesEditor blockquote,
        .ProseMirror blockquote,
        .tiptap blockquote {
            border-left: 3px solid oklch(0.556 0 0) !important;
            padding-left: 1rem !important;
            margin: 1rem 0 !important;
            font-style: italic !important;
            color: oklch(0.556 0 0) !important;
            background: oklch(0.98 0 0) !important;
            padding: 0.75rem 1rem !important;
            border-radius: 0.375rem !important;
        }
        
        #insightNotesEditor blockquote p,
        .ProseMirror blockquote p,
        .tiptap blockquote p {
            margin: 0 !important;
        }

        /* Task List (Checklist) styling */
        #insightNotesEditor ul[data-type="taskList"],
        .ProseMirror ul[data-type="taskList"],
        .tiptap ul[data-type="taskList"] {
            list-style: none !important;
            padding-left: 0 !important;
        }

        #insightNotesEditor ul[data-type="taskList"] li,
        .ProseMirror ul[data-type="taskList"] li,
        .tiptap ul[data-type="taskList"] li {
            list-style: none !important;
            display: flex !important;
            align-items: flex-start !important;
            margin: 0.5rem 0 !important;
        }

        #insightNotesEditor ul[data-type="taskList"] li label,
        .ProseMirror ul[data-type="taskList"] li label,
        .tiptap ul[data-type="taskList"] li label {
            display: flex !important;
            align-items: center !important;
            cursor: pointer !important;
            margin-right: 0.5rem !important;
            flex-shrink: 0 !important;
        }

        #insightNotesEditor ul[data-type="taskList"] li label input[type="checkbox"],
        .ProseMirror ul[data-type="taskList"] li label input[type="checkbox"],
        .tiptap ul[data-type="taskList"] li label input[type="checkbox"] {
            margin: 0 !important;
            cursor: pointer !important;
            width: 1.125rem !important;
            height: 1.125rem !important;
        }

        #insightNotesEditor ul[data-type="taskList"] li > div,
        .ProseMirror ul[data-type="taskList"] li > div,
        .tiptap ul[data-type="taskList"] li > div {
            flex: 1 !important;
            margin: 0 !important;
        }

        #insightNotesEditor ul[data-type="taskList"] li > div p,
        .ProseMirror ul[data-type="taskList"] li > div p,
        .tiptap ul[data-type="taskList"] li > div p {
            margin: 0 !important;
            display: inline !important;
        }

        /* Image styling */
        #insightNotesEditor img,
        .ProseMirror img,
        .tiptap img,
        .insight-image {
            max-width: 100% !important;
            height: auto !important;
            border-radius: 0.5rem !important;
            margin: 1rem 0 !important;
            display: block !important;
            min-height: 50px !important; /* Ensure images take up space while loading */
            cursor: pointer !important; /* Indicate images are clickable */
        }
        
        /* Add error styling for broken images */
        #insightNotesEditor img[src=""],
        .ProseMirror img[src=""],
        .tiptap img[src=""] {
            border: 2px dashed #ccc;
            background: #f5f5f5;
        }
        
        /* Image Modal Styles */
        .image-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000; /* Higher than slideout panel */
            padding: 2rem;
            cursor: pointer;
        }
        
        .image-modal-overlay.active {
            display: flex;
        }
        
        .image-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .image-modal-content img {
            max-width: 100%;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 0.5rem;
            cursor: default;
        }
        
        .image-modal-close {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 2rem;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: background 0.2s;
            z-index: 100001; /* Above the modal overlay */
        }
        
        .image-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Video styling */
        #insightNotesEditor video,
        .ProseMirror video,
        .tiptap video,
        .video-embed {
            max-width: 100% !important;
            height: auto !important;
            border-radius: 0.5rem !important;
            margin: 1rem 0 !important;
            display: block !important;
        }

        /* Iframe styling (for Loom and other embeds) */
        #insightNotesEditor .embed-iframe,
        .ProseMirror .embed-iframe,
        .tiptap .embed-iframe,
        #insightNotesEditor iframe,
        .ProseMirror iframe,
        .tiptap iframe {
            width: 100% !important;
            border-radius: 0.5rem !important;
            aspect-ratio: 16/9 !important;
            margin: 1rem 0 !important;
            display: block !important;
            border: none !important;
        }

        /* Editor Context Menu */
        .editor-context-menu {
            position: fixed; /* Use fixed positioning for viewport coordinates */
            background: oklch(1 0 0); /* White */
            border: 1px solid oklch(0.922 0 0); /* Border color from style guide */
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 0.25rem;
            z-index: 10010; /* Higher than slideout panel (which is typically 10000) */
            min-width: 140px;
            font-family: 'Lato', sans-serif;
        }

        .context-menu-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: oklch(0.145 0 0); /* Near black */
            cursor: pointer;
            border-radius: 0.375rem;
            transition: background 0.2s ease;
        }

        .context-menu-item:hover {
            background: oklch(0.97 0 0); /* Light grey */
        }

        .context-menu-item.active {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
            font-weight: 600;
        }

        .context-menu-divider {
            height: 1px;
            background: oklch(0.922 0 0);
            margin: 0.25rem 0;
        }

        .ai-close-btn {
            background: none;
            border: none;
            color: oklch(0.556 0 0); /* Muted foreground */
            font-size: 1.75rem; /* 28px */
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem; /* 6px - radius-sm */
            transition: all 0.2s ease;
            font-family: 'Lato', sans-serif;
        }

        .ai-close-btn:hover {
            background: oklch(0.97 0 0); /* Light gray */
            color: oklch(0.145 0 0); /* Near black */
        }

        .ai-close-btn:focus-visible {
            outline: 2px solid #B9F040;
            outline-offset: 2px;
        }

        /* Insight Attributes Styling - Matching Style Guide */
        .insight-attribute-row {
            display: flex;
            align-items: center;
            min-height: 32px;
            padding: 0.25rem 0; /* 4px */
        }

        .insight-attribute-chip {
            background: oklch(0.97 0 0); /* Light gray from style guide */
            border-radius: 0.375rem; /* 6px - radius-sm */
            padding: 0.375rem 0.75rem; /* 6px 12px */
            font-size: 0.875rem; /* 14px */
            font-family: 'Lato', sans-serif;
            font-weight: 400;
            color: oklch(0.145 0 0); /* Near black foreground */
            cursor: text;
            outline: none;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .insight-attribute-chip:hover {
            background: oklch(0.95 0 0); /* Slightly darker gray */
        }

        .insight-attribute-chip:focus {
            background: oklch(1 0 0); /* White */
            border-color: #B9F040; /* Brand lime green */
            outline: none;
        }

        .insight-attribute-chip[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: oklch(0.556 0 0); /* Muted foreground */
        }

        /* Editable Title Focus Styles */
        #insightTitleEditable:focus {
            outline: 2px solid #B9F040;
            outline-offset: 2px;
            border-radius: 0.375rem; /* 6px */
        }


        .insights-panel-header-search {
            position: relative;
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: center;
        }

        .insights-panel-header-search .search-box {
            position: relative;
            min-width: 200px;
            max-width: 400px;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 36px 8px 12px;
        }

        #insightsSearchInput {
            color: #333 !important;
            transition: border-color 0.2s, box-shadow 0.2s;
            border: none;
            background: transparent;
            outline: none;
            font-size: 14px;
            width: 100%;
            padding: 0;
        }

        #insightsSearchInput::placeholder {
            color: rgba(55, 53, 47, 0.4);
        }

        .insights-panel-header-search .search-box:focus-within {
            border-color: #B9F040 !important;
            box-shadow: 0 0 0 3px rgba(185, 240, 64, 0.1) !important;
        }

        #insightsSearchInput:focus {
            outline: none;
        }

        #insightsSearchClear {
            transition: all 0.2s;
        }

        #insightsSearchClear:hover {
            background: #f5f5f5;
            color: #333;
        }

        .ai-insights-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            transition: opacity 0.2s ease;
        }

        .ai-insights-content.transitioning {
            opacity: 0;
        }

        #slideoutTitle.transitioning,
        #slideoutSubtitle.transitioning,
        #slideoutSettingsBtn.transitioning {
            opacity: 0;
        }
        
        #slideoutTitle,
        #slideoutSubtitle,
        #slideoutSettingsBtn {
            transition: opacity 0.2s ease;
        }

        .ai-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .ai-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e4e6eb;
            border-top-color: #b9f040;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .ai-summary-section {
            margin-bottom: 32px;
        }

        .ai-summary-section h3 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-summary-text {
            line-height: 1.6;
            color: #555;
            margin-bottom: 12px;
        }

        .ai-insights-list {
            list-style: none;
            padding: 0;
        }

        .ai-insights-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-left: 3px solid #b9f040;
            border-radius: 4px;
            color: #333;
            line-height: 1.5;
        }

        .ai-category-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #fff;
            border: 1px solid #e4e6eb;
            border-radius: 6px;
        }

        .ai-category-name {
            font-weight: 600;
            color: #85c024;
            margin-bottom: 4px;
        }

        .ai-patterns-box {
            padding: 16px;
            background: linear-gradient(135deg, rgba(185,240,64,0.1) 0%, rgba(160,214,53,0.1) 100%);
            border-radius: 8px;
            border: 1px solid rgba(185,240,64,0.3);
            color: #333;
            line-height: 1.6;
        }

        .ai-metadata {
            margin-top: 32px;
            padding-top: 16px;
            border-top: 1px solid #e4e6eb;
            font-size: 12px;
            color: #999;
        }

        .ai-status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .ai-status-cached {
            background: #d1fae5;
            color: #065f46;
        }

        .ai-status-generated {
            background: #dbeafe;
            color: #1e40af;
        }

        .ai-regenerate-btn {
            margin-top: 16px;
            padding: 10px 20px;
            background: white;
            border: 2px solid #b9f040;
            color: #85c024;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
        }

        .ai-regenerate-btn:hover {
            background: #b9f040;
            color: #1a1a1a;
        }

        .ai-insights-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .ai-insights-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* Insights Page Styles */
        .page-header {
            padding: 16px 35px;
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }

        .page-header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #37352f;
        }

        .btn-new {
            background: rgba(55, 53, 47, 0.08);
            color: #37352f;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn-new:hover {
            background: rgba(55, 53, 47, 0.12);
        }

        .control-bar {
            position: relative;
            padding: 8px 35px;
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
            background: white;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            min-height: 40px;
        }

        .search-box {
            display: flex;
            align-items: center;
            background: rgba(55, 53, 47, 0.06);
            border-radius: 3px;
            padding: 4px 8px;
            min-width: 200px;
            flex: 0 0 auto;
        }

        .search-box input {
            border: none;
            background: transparent;
            outline: none;
            font-size: 14px;
            padding: 2px 4px;
            flex: 1;
            color: #37352f;
        }

        .search-box input::placeholder {
            color: rgba(55, 53, 47, 0.4);
        }

        #insights-section .search-box {
            position: relative;
            align-items: center;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 36px 8px 12px;
            min-width: 200px;
            max-width: 360px;
            width: 260px;
            flex: 0 0 auto;
        }

        #insights-section .search-box input {
            border: none;
            background: transparent;
            outline: none;
            font-size: 14px;
            padding: 0;
            width: 100%;
        }

        #insights-section .search-box input::placeholder {
            color: rgba(55, 53, 47, 0.4);
        }

        #insights-section .search-box:focus-within {
            border-color: #B9F040 !important;
            box-shadow: 0 0 0 3px rgba(185, 240, 64, 0.1) !important;
        }

        .filter-chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            flex: 1;
        }

        .filter-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(55, 53, 47, 0.06);
            border-radius: 3px;
            font-size: 13px;
            color: #37352f;
        }

        .filter-chip .remove {
            cursor: pointer;
            opacity: 0.6;
            padding: 0 2px;
        }

        .filter-chip .remove:hover {
            opacity: 1;
        }

        .btn-filter {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: transparent;
            border: none;
            color: rgba(55, 53, 47, 0.6);
            cursor: pointer;
            font-size: 13px;
            border-radius: 3px;
        }

        .btn-filter:hover {
            background: rgba(55, 53, 47, 0.06);
            color: #37352f;
        }

        .btn-reset {
            padding: 4px 8px;
            background: transparent;
            border: none;
            color: rgba(55, 53, 47, 0.6);
            cursor: pointer;
            font-size: 13px;
            border-radius: 3px;
        }

        .btn-reset:hover {
            background: rgba(55, 53, 47, 0.06);
            color: #37352f;
        }

        .table-container {
            overflow-x: auto;
            background: white;
        }

        .notion-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1200px;
        }

        .notion-table thead {
            background: rgba(55, 53, 47, 0.03);
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
        }

        .notion-table th {
            padding: 8px 12px;
            text-align: left;
            font-weight: 500;
            font-size: 13px;
            color: rgba(55, 53, 47, 0.6);
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            position: relative;
            border-right: 1px solid rgba(55, 53, 47, 0.09);
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
        }

        .notion-table th.draggable {
            cursor: grab;
        }

        .notion-table th.draggable:active {
            cursor: grabbing;
        }

        .notion-table th.dragging {
            opacity: 0.5;
            background: rgba(185, 240, 64, 0.1);
        }

        .notion-table th.drag-over {
            border-left: 3px solid #B9F040;
            background: rgba(185, 240, 64, 0.05);
        }

        .notion-table th .drag-handle {
            display: inline-block;
            margin-right: 6px;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: grab;
            vertical-align: middle;
            font-size: 14px;
            line-height: 1;
            color: rgba(55, 53, 47, 0.4);
            user-select: none;
        }

        .notion-table th:hover .drag-handle {
            opacity: 0.4;
        }

        .notion-table th.draggable:hover .drag-handle {
            opacity: 0.6;
        }

        .notion-table th.draggable:active .drag-handle {
            opacity: 0.8;
        }

        .notion-table th:hover {
            background: rgba(55, 53, 47, 0.06);
        }

        .notion-table th .sort-indicator {
            margin-left: 4px;
            opacity: 0.4;
        }

        .notion-table th.sorted .sort-indicator {
            opacity: 1;
        }

        .notion-table th .column-icon {
            margin-right: 6px;
            opacity: 0.4;
        }

        .notion-table tbody tr {
            transition: background 0.1s;
        }

        .notion-table tbody tr:hover {
            background: rgba(55, 53, 47, 0.03);
        }

        .notion-table tbody tr:hover .insight-open-btn-table {
            display: flex !important;
        }

        .insight-open-btn-table {
            display: none;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(55, 53, 47, 0.1);
            border-radius: 3px;
            color: rgba(55, 53, 47, 0.6);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .insight-open-btn-table:hover {
            background: rgba(55, 53, 47, 0.12);
            color: #37352f;
        }

        .notion-table td {
            padding: 8px 12px;
            font-size: 14px;
            vertical-align: middle;
            border-right: 1px solid rgba(55, 53, 47, 0.09);
            border-bottom: 1px solid rgba(55, 53, 47, 0.09);
        }

        .notion-table .checkbox-cell {
            width: 32px;
            padding: 8px;
            text-align: center;
        }

        .notion-table .checkbox {
            width: 16px;
            height: 16px;
            border: 1.5px solid rgba(55, 53, 47, 0.3);
            border-radius: 3px;
            cursor: pointer;
            display: inline-block;
            transition: all 0.1s;
        }

        .notion-table .checkbox:hover {
            border-color: rgba(55, 53, 47, 0.5);
        }

        .notion-table .name-cell {
            min-width: 250px;
            font-weight: 500;
            padding-left: 35px;
        }

        .notion-table th.name-cell {
            padding-left: 35px;
        }

        .notion-table .name-cell .name-content {
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            /* No padding-right - OPEN button overlays on hover */
        }

        .notion-table .name-cell .doc-icon {
            width: 16px;
            height: 16px;
            opacity: 0.4;
            flex-shrink: 0;
        }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 13px;
            font-weight: 400;
            margin-right: 4px;
            margin-bottom: 2px;
        }

        .tag-type {
            background: rgba(46, 170, 220, 0.15);
            color: #2eaadc;
        }

        .tag-project {
            background: rgba(255, 171, 0, 0.15);
            color: #ffab00;
        }

        .tag-data-source {
            background: rgba(99, 71, 169, 0.15);
            color: #6347a9;
        }

        .insight-origin-pill {
            transition: all 0.2s ease;
        }

        .insight-origin-pill:hover {
            opacity: 0.8;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .insight-origin-pill.tag-project:hover {
            background: rgba(255, 171, 0, 0.25);
        }

        .insight-origin-pill.tag-data-source:hover {
            background: rgba(99, 71, 169, 0.25);
        }

        .tag-category {
            background: rgba(111, 212, 161, 0.15);
            color: #6fd4a1;
        }

        .tag-topic {
            background: rgba(116, 199, 232, 0.15);
            color: #74c7e8;
        }

        .insight-origin-pill.tag-category:hover {
            background: rgba(111, 212, 161, 0.25);
        }

        .insight-origin-pill.tag-topic:hover {
            background: rgba(116, 199, 232, 0.25);
        }

        .insight-origin-pill:hover:not(.tag-project):not(.tag-data-source):not(.tag-category):not(.tag-topic) {
            background: rgba(0, 0, 0, 0.05);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-dot.not-started {
            background: #d1d1d1;
        }

        .status-dot.in-progress {
            background: #0b85ff;
        }

        .status-dot.done {
            background: #0f7b0f;
        }

        .actions-cell {
            width: 80px;
        }

        .checkbox-cell {
            width: 40px;
            text-align: center;
            padding: 0.5rem;
        }

        .checkbox-cell input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .notion-table tbody tr:hover .checkbox-cell {
            background: rgba(55, 53, 47, 0.03);
        }

        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            color: rgba(55, 53, 47, 0.4);
            font-size: 14px;
            border-radius: 3px;
            transition: all 0.1s;
        }

        .action-btn:hover {
            background: rgba(55, 53, 47, 0.06);
            color: #37352f;
        }

        .empty-state {
            padding: 60px 24px;
            text-align: center;
            color: rgba(55, 53, 47, 0.4);
        }

        .empty-state h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: rgba(55, 53, 47, 0.6);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex !important;
        }

        .modal-content {
            background: white;
            border-radius: 3px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #37352f;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #37352f;
            margin-bottom: 6px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(55, 53, 47, 0.16);
            border-radius: 3px;
            font-size: 14px;
            font-family: inherit;
            color: #37352f;
            background: white;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: rgba(55, 53, 47, 0.3);
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn-secondary {
            background: rgba(55, 53, 47, 0.08);
            color: #37352f;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-secondary:hover {
            background: rgba(55, 53, 47, 0.12);
        }

        .btn-save {
            background: #37352f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-save:hover {
            background: #2e2a24;
        }

        .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: rgba(55, 53, 47, 0.4);
            font-size: 20px;
            line-height: 1;
        }

        .close-btn:hover {
            color: #37352f;
        }

        .ai-insights-panel {
            position: fixed;
            right: -520px;
            top: 0;
            width: 500px;
            height: 100vh;
            background: oklch(1 0 0);
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            z-index: 10000;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border-top: 3px solid #B9F040;
        }

        .ai-insights-panel.open {
            right: 0;
        }

        .ai-insights-header {
            padding: 1.25rem 1.5rem 1rem 1.5rem;
            border-bottom: 1px solid oklch(0.922 0 0);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: oklch(1 0 0);
        }

        .ai-close-btn {
            background: none;
            border: none;
            font-size: 1.75rem;
            color: oklch(0.556 0 0);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            font-family: 'Lato', sans-serif;
        }

        .ai-close-btn:hover {
            background: oklch(0.97 0 0);
            color: oklch(0.145 0 0);
        }

        .ai-close-btn:focus-visible {
            outline: 2px solid #B9F040;
            outline-offset: 2px;
        }

        .ai-insights-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 10px;
            transition: opacity 0.2s ease;
        }

        .ai-insights-content.transitioning {
            opacity: 0;
        }

        #slideoutTitle.transitioning,
        #slideoutSubtitle.transitioning,
        #slideoutSettingsBtn.transitioning {
            opacity: 0;
        }
        
        #slideoutTitle,
        #slideoutSubtitle,
        #slideoutSettingsBtn {
            transition: opacity 0.2s ease;
        }

        .insight-attribute-row {
            display: flex;
            align-items: center;
            min-height: 32px;
            padding: 0.25rem 0;
        }

        .insight-attribute-chip {
            background: oklch(0.97 0 0);
            border-radius: 0.375rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            font-family: 'Lato', sans-serif;
            font-weight: 400;
            color: oklch(0.145 0 0);
            cursor: text;
            outline: none;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .insight-attribute-chip:hover {
            background: oklch(0.95 0 0);
        }

        .insight-attribute-chip:focus {
            background: oklch(1 0 0);
            border-color: #B9F040;
            outline: none;
        }

        .insight-attribute-chip[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: oklch(0.556 0 0);
        }

        #insightTitleEditable:focus {
            outline: 2px solid #B9F040;
            outline-offset: 2px;
            border-radius: 0.375rem;
        }

        .ai-error {
            padding: 24px;
            text-align: center;
        }

        .ai-error h3 {
            color: #dc2626;
            margin-bottom: 12px;
        }

        .ai-error button {
            margin-top: 16px;
            padding: 10px 20px;
            background: #b9f040;
            color: #1a1a1a;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .ai-insights-panel {
                width: 100%;
                right: -100%;
            }
            
            .ai-insights-tab {
                padding: 12px 10px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Login Overlay -->
    <div id="loginOverlay" class="login-overlay hidden">
        <div class="login-container">
            <div id="loginFormSection">
                <h2>Sign in</h2>
                <p class="login-subtext">
                    Enter your work email and we'll email you a secure magic link.
                    Only approved company domains can sign in.
                </p>
                <input type="email" id="loginEmail" placeholder="you@company.com" autocomplete="email">
                <button id="loginButton" type="button">Send Magic Link</button>
                <div id="loginError" class="login-error"></div>
                <div id="loginSuccess" class="login-success"></div>
            </div>

            <div id="accountSelectionSection" class="hidden">
                <div class="account-selection-header">
                    <p class="account-selection-greeting" id="accountSelectionGreeting"></p>
                    <h2>Which client?</h2>
                    <p class="account-selection-note">
                        Pick a client to open their dashboard. You can switch at any time from the client selector.
                    </p>
                </div>
                <div class="account-selection-content">
                    <div id="accountSelectionList" class="account-selection-grid" role="list"></div>
                    <div id="accountSelectionError" class="login-error"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container" id="mainContainer" style="display: none;">
        <!-- Navigation Menu -->
        <nav class="app-navigation">
            <div class="nav-menu" id="navMenu">
                <a href="#" class="nav-menu-item" id="navVisualizations" onclick="navigateToView('visualizations'); return false;">
                    <span>Visualizations</span>
                </a>
                <a href="#" class="nav-menu-item" id="navInsights" onclick="navigateToView('insights'); return false;">
                    <span>Insights</span>
                </a>
            </div>
        </nav>
        
        <!-- Visualizations Section -->
        <div id="visualizations-section" class="spa-section active">
        <!-- Data Source Selector -->
        <div class="data-source-selector">
            <div class="filter-tabs" role="tablist" aria-label="Data filters">
                <button type="button" class="filter-tab active" id="clientTab" role="tab" aria-selected="true" aria-controls="clientPanel" data-target="clientPanel">
                    <span class="filter-tab__label">Client</span>
                </button>
                <button type="button" class="filter-tab" id="projectTab" role="tab" aria-selected="false" aria-controls="projectPanel" data-target="projectPanel" disabled>
                    <span class="filter-tab__label">Project</span>
                </button>
                <button type="button" class="filter-tab" id="sourceTab" role="tab" aria-selected="false" aria-controls="sourcePanel" data-target="sourcePanel" disabled>
                    <span class="filter-tab__label">Source</span>
                </button>
                <button type="button" class="filter-tab" id="dimensionTab" role="tab" aria-selected="false" aria-controls="dimensionPanel" data-target="dimensionPanel" disabled>
                    <span class="filter-tab__label">Dimension</span>
                </button>
            </div>

            <div class="data-source-selector__content">
                <div class="filter-panels">
                    <div class="filter-panel active" id="clientPanel" role="tabpanel" aria-labelledby="clientTab">
                        <label for="clientSelect">Client:</label>
                        <select id="clientSelect">
                            <option value="">Loading...</option>
                        </select>
                    </div>

                    <div class="filter-panel" id="projectPanel" role="tabpanel" aria-labelledby="projectTab">
                        <label for="projectSelect">Project:</label>
                        <select id="projectSelect">
                            <option value="">Select client first...</option>
                        </select>
                    </div>

                    <div class="filter-panel" id="sourcePanel" role="tabpanel" aria-labelledby="sourceTab">
                        <label for="sourceSelect">Source:</label>
                        <select id="sourceSelect">
                            <option value="">Select client first...</option>
                        </select>
                    </div>

                    <!-- Dimension Filter (for survey data) -->
                    <div class="filter-panel" id="dimensionPanel" role="tabpanel" aria-labelledby="dimensionTab">
                        <label for="questionSelect" id="questionLabel" style="display:none;">Dimension:</label>
                        <select id="questionSelect" style="display:none;">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                </div>

                <div class="data-source-actions">
                    <!-- Add Data Button -->
                    <a id="addDataBtn" href="#" style="padding: 8px 24px; background: #B9F040; color: #000000; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; text-decoration: none; display: none; margin-right: 8px; transition: background 200ms; min-height: 44px; line-height: 28px;">
                        Add
                    </a>
                    <style>
                        #addDataBtn:hover {
                            background: #a0d636;
                        }
                        #addDataBtn:focus-visible {
                            outline: 2px solid #B9F040;
                            outline-offset: 2px;
                        }
                    </style>
                    <!-- Advanced Multi-Filter -->
                    <div class="filter-menu">
                        <button id="filterBtn" class="filter-button" type="button" aria-label="Open filters">
                            <img src="/static/images/filter_list.svg" alt="" aria-hidden="true">
                            <span id="filterBadge" class="filter-badge" aria-hidden="true"></span>
                        </button>
                        <div id="filterDropdown" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 350px; max-width: 450px; z-index: 1000; max-height: 500px; overflow-y: auto;">
                            <!-- Filter Type Selection View -->
                            <div id="filterTypeView" style="display: block;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <strong style="font-size: 14px;">Filter By</strong>
                                    <button id="clearAllFilters" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Clear All</button>
                                </div>
                                <div id="filterTypeList" style="padding: 8px;">
                                    <!-- Filter types will be dynamically populated here -->
                                </div>
                                <div id="activeFiltersList" style="padding: 8px 12px; border-top: 1px solid #e0e0e0; background: #f8f9fa; max-height: 150px; overflow-y: auto;"></div>
                            </div>
                            
                            <!-- Metadata Field Selection View (second level for metadata) -->
                            <div id="metadataFieldView" style="display: none;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <button id="backFromMetadataField" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 16px; font-weight: 500;"></button>
                                        <strong style="font-size: 14px;">Select Metadata Field</strong>
                                    </div>
                                </div>
                                <div id="metadataFieldList" style="padding: 8px; max-height: 350px; overflow-y: auto;"></div>
                            </div>
                            
                            <!-- Filter Selection View (for categories, topics, locations, or metadata values) -->
                            <div id="filterSelectionView" style="display: none;">
                                <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <button id="backToFilterType" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 16px; font-weight: 500;"></button>
                                        <strong id="filterSelectionTitle" style="font-size: 14px;">Select Items</strong>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button id="selectAllItems" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Select All</button>
                                        <button id="clearAllItems" style="padding: 4px 8px; background: transparent; border: none; color: #667eea; cursor: pointer; font-size: 12px; font-weight: 500;">Clear All</button>
                                    </div>
                                </div>
                                <div style="padding: 8px 12px; border-bottom: 1px solid #e0e0e0; background: #f0f0f0; display: flex; gap: 8px; align-items: center;">
                                    <span style="font-size: 12px; color: #666;">Mode:</span>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px;">
                                        <input type="radio" name="filterMode" value="include" checked style="cursor: pointer;">
                                        <span>Include</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px;">
                                        <input type="radio" name="filterMode" value="exclude" style="cursor: pointer;">
                                        <span>Exclude</span>
                                    </label>
                                </div>
                                <div style="padding: 8px 12px; border-bottom: 1px solid #e0e0e0; background: #fff;">
                                    <div style="position: relative;">
                                        <input
                                            type="text"
                                            id="filterSelectionSearch"
                                            placeholder="Search items..."
                                            style="width: 100%; padding: 6px 30px 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                        />
                                        <button
                                            id="filterSelectionSearchClear"
                                            onclick="clearFilterSelectionSearch()"
                                            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #999; font-size: 18px; line-height: 1; width: 20px; height: 20px; align-items: center; justify-content: center; border-radius: 3px;"
                                            title="Clear search"
                                            onmouseover="this.style.backgroundColor='#f0f0f0'; this.style.color='#666';"
                                            onmouseout="this.style.backgroundColor='transparent'; this.style.color='#999';"
                                        >&times;</button>
                                    </div>
                                </div>
                                <div id="filterSelectionList" style="padding: 8px; max-height: 300px; overflow-y: auto;"></div>
                                <div style="padding: 12px; border-top: 1px solid #e0e0e0; background: #f8f9fa;">
                                    <button id="applyFilter" style="width: 100%; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Apply Filter</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Inline Dimension Name Editor -->
                    <div id="dimensionNameEditor" style="display:none; align-items: center; gap: 8px;">
                        <label style="font-size: 13px; color: #666;">Name:</label>
                        <select id="dimensionNameSelect" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: white; cursor: pointer;">
                            <option value="">-- Select --</option>
                        </select>
                        <input 
                            type="text" 
                            id="dimensionNameCustom" 
                            placeholder="or enter custom name"
                            style="display:none; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; width: 200px;"
                        />
                        <button id="saveDimensionBtn" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 500;">
                            Save
                        </button>
                        <button id="manageOptionsBtn" style="padding: 6px 12px; background: #f0f0f0; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 13px;">
                            Manage Options
                        </button>
                        <span id="saveStatusInline" style="font-size: 12px; color: #666; font-style: italic;"></span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="treemap-section">
            <div class="treemap-container">
                <div class="treemap-header">
                    <div class="treemap-header-top">
                        <h2 class="treemap-title">Topic Distribution</h2>
                        <button class="chart__toggle" onclick="toggleTreemap(this)" aria-label="Toggle treemap visibility">
                            <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="treemap-search-container">
                    <div class="treemap-search-input-wrapper">
                        <input
                            type="text"
                            id="treemapSearch"
                            class="treemap-search-input"
                            placeholder="Search verbatims by keyword..."
                        />
                        <button
                            id="treemapSearchClear"
                            class="treemap-search-clear"
                            onclick="clearTreemapSearch()"
                            title="Clear search"
                            style="display: none;"
                        >&times;</button>
                    </div>
                </div>
                <div class="treemap-svg-container">
                    <div class="loading" id="loading">Loading data...</div>
                    <svg id="treemap"></svg>
                </div>
            </div>
        </div>

        <div class="visualizations-grid">
            <div class="chart-column">
                <div class="chart" role="figure" aria-label="Topics by Category">
                    <div class="chart__header">
                        <div class="chart__header-top">
                            <h2 class="chart__title">Topics by Category</h2>
                            <button class="chart__toggle" onclick="toggleChart(this)" aria-label="Toggle chart visibility">
                                <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                        <p class="chart__subtitle">Frequency of customer conversation topics</p>
                    </div>
                    <div class="chart__body">
                        <div class="chart__labels" id="barChartLabels"></div>
                        <div class="chart__bars" id="barChartBars"></div>
                    </div>
                    <div class="chart__footer" id="barChartFooter">Frequency (n=<span id="totalCount">0</span>)</div>
                </div>

                <!-- Insights Panel -->
                <div class="insights-panel-container">
                    <div class="insights-panel-header">
                        <div class="insights-panel-header-left">
                            <h2>Recent Insights</h2>
                            <span id="insightsFilterBadge" class="insights-filter-badge" style="display: none;"></span>
                        </div>
                        <div class="insights-panel-header-search">
                            <div class="search-box">
                                <input type="text" id="insightsSearchInput" placeholder="Search insights..." oninput="handleInsightsSearch()" onfocus="updateInsightsSearchClearButton()">
                                <button
                                    id="insightsSearchClear"
                                    onclick="clearInsightsSearch()"
                                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                                    title="Clear search"
                                >&times;</button>
                            </div>
                        </div>
                        <div class="insights-panel-header-right">
                            <button class="insights-panel-toggle" onclick="toggleInsightsPanel()" id="insightsPanelToggle">
                                <svg id="insightsPanelToggleIcon" class="insights-panel-toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="insights-panel-body" id="insightsPanelBody">
                        <div class="insights-table-section">
                            <div class="table-container">
                                <table class="notion-table">
                                    <thead>
                                        <tr>
                                            <th class="name-cell sorted draggable" data-column="name" draggable="true" onclick="sortInsightsBy('name')">
                                                <span class="drag-handle"></span>
                                                <span class="column-icon">Aa</span>
                                                <span>Name</span>
                                                <span class="sort-indicator"></span>
                                            </th>
                                            <th class="draggable" data-column="created_at" draggable="true" onclick="sortInsightsBy('created_at')">
                                                <span class="drag-handle"></span>
                                                <span class="column-icon"></span>
                                                <span>Created</span>
                                                <span class="sort-indicator"></span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody id="insightsTableBody">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart" role="figure" aria-label="All Topics">
                <div class="chart__header">
                    <div class="chart__header-top">
                        <h2 class="chart__title">All Topics</h2>
                        <button class="chart__toggle" onclick="toggleChart(this)" aria-label="Toggle chart visibility">
                            <svg class="chart__toggle-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 6 L8 10 L12 6" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                    <p class="chart__subtitle">Individual topic frequency across all categories</p>
                </div>
                <div class="chart__body">
                    <div class="chart__labels" id="topicsChartLabels"></div>
                    <div class="chart__bars" id="topicsChartBars"></div>
                </div>
                <div class="chart__footer" id="topicsChartFooter">Frequency (n=<span id="topicsCount">0</span>)</div>
            </div>
        </div>
    </div>

    <!-- Overlay Modal for Verbatims -->
    <!-- Old overlay modal - hidden, kept for backward compatibility -->
    <div id="overlay" class="overlay" style="display: none !important;">
        <div class="overlay-content">
            <div class="overlay-header">
                <div style="flex: 1;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                        <div>
                            <h2 class="overlay-title" id="overlayTitle">Customer Feedback</h2>
                            <p class="overlay-subtitle" id="overlaySubtitle"></p>
                        </div>
                        <div class="overlay-header-actions">
                            <button class="settings-button" onclick="toggleSettingsPanel()" title="Card Settings">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"></path>
                                </svg>
                            </button>
                            <button class="close-button" onclick="closeOverlay()">&times;</button>
                        </div>
                    </div>
                    <div style="margin-top: 12px; position: relative;">
                        <input
                            type="text"
                            id="verbatimSearch"
                            placeholder="Search verbatims..."
                            style="width: 100%; padding: 8px 36px 8px 12px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; font-size: 14px; background: rgba(255, 255, 255, 0.1); color: white; backdrop-filter: blur(10px);"
                        />
                        <button
                            id="verbatimSearchClear"
                            onclick="clearVerbatimSearch()"
                            style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: rgba(255, 255, 255, 0.8); font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                            title="Clear search"
                            onmouseover="this.style.backgroundColor='rgba(185, 240, 64, 0.2)'; this.style.color='#B9F040';"
                            onmouseout="this.style.backgroundColor='transparent'; this.style.color='rgba(255, 255, 255, 0.8)';"
                        >&times;</button>
                        <style>
                            #verbatimSearch::placeholder {
                                color: rgba(255, 255, 255, 0.6);
                            }
                            #verbatimSearch:focus {
                                outline: none;
                                border-color: #B9F040;
                                background: rgba(255, 255, 255, 0.15);
                            }
                            #verbatimSearchClear:hover {
                                color: #B9F040;
                            }
                        </style>
                    </div>
                </div>
                <div id="settingsPanel" class="settings-panel">
                    <h3>Display Metadata</h3>
                    <div class="settings-option">
                        <input type="checkbox" id="showSentiment" checked onchange="updateMetadataSettings()">
                        <label for="showSentiment">Sentiment</label>
                    </div>
                    <div class="settings-option">
                        <input type="checkbox" id="showLocation" checked onchange="updateMetadataSettings()">
                        <label for="showLocation">Location</label>
                    </div>
                    <div class="settings-option">
                        <input type="checkbox" id="showIndex" checked onchange="updateMetadataSettings()">
                        <label for="showIndex">Index</label>
                    </div>
                </div>
            </div>
            <div id="verbatims" class="verbatim-container" style="display: none;"></div>
        </div>
    </div>

    <!-- Overlay Modal for Dimension Editor -->
    <div id="dimensionEditorOverlay" class="overlay">
        <div class="overlay-content">
            <div class="overlay-header">
                <div>
                    <h2 class="overlay-title">Edit Dimension Names</h2>
                    <p class="overlay-subtitle">Assign human-readable names to survey dimensions</p>
                </div>
                <button class="close-button" onclick="closeDimensionEditor()">&times;</button>
            </div>
            <div id="dimensionEditorContent" class="dimension-editor-container"></div>
        </div>
    </div>

    <!-- Context Menu for Right-Click -->
    <div id="contextMenu" class="context-menu" style="display: none;">
        <div class="context-menu-item" data-action="create-insight" style="cursor: pointer; user-select: none;">
            Create Insight
        </div>
        <div class="context-menu-item" data-action="exclude-category" style="display: none; cursor: pointer; user-select: none;">
            Exclude Category
        </div>
    </div>

    <!-- Create Insight Modal -->
    <div id="createInsightModal" class="insight-modal-overlay" style="display: none;">
        <div class="insight-modal-content">
            <div class="insight-modal-header">
                <h2>Create Insight</h2>
                <button class="insight-modal-close" onclick="closeCreateInsightModal()">&times;</button>
            </div>
            <form id="createInsightForm" onsubmit="handleCreateInsightSubmit(event)">
                <div class="insight-form-group">
                    <label for="insightModalName">Insight Name *</label>
                    <input type="text" id="insightModalName" required>
                </div>
                <div class="insight-form-group">
                    <label for="insightModalDescription">Description</label>
                    <textarea id="insightModalDescription" placeholder="Detailed description"></textarea>
                </div>
                <div class="insight-form-group">
                    <label>Origin</label>
                    <div id="insightModalOriginPreview" class="insight-origin-preview"></div>
                </div>
                <div class="insight-modal-actions">
                    <button type="button" class="insight-modal-cancel" onclick="closeCreateInsightModal()">Cancel</button>
                    <button type="submit" class="insight-modal-submit">Create</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Configuration - dynamically set to container size
        let width = 1200; // Will be updated when container is available
        let height = 600; // Will be updated when container is available
        
        // Debounce function to limit resize calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function resetFilterSelectionSearch() {
            currentFilterSearchTerm = '';
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            updateFilterSelectionSearchClearButton();
        }
        
        function clearFilterSelectionSearch() {
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput) {
                searchInput.value = '';
                currentFilterSearchTerm = '';
                populateFilterSelectionList();
                updateFilterSelectionSearchClearButton();
            }
        }
        
        function updateFilterSelectionSearchClearButton() {
            const searchInput = document.getElementById('filterSelectionSearch');
            const clearButton = document.getElementById('filterSelectionSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.style.display = 'flex';
                } else {
                    clearButton.style.display = 'none';
                }
            }
        }
        
        // Vibrant color palette as per specification
        const categoryColors = [
            '#A97FFF', // Vibrant violet
            '#77D9D6', // Aqua-teal
            '#F8A04C', // Amber-orange
            '#58B3F0', // Bright blue
            '#6ED49B', // Fresh green
            '#F47280', // Coral pink
            '#9A7B6C', // Warm neutral
            '#FFB366', // Peach
            '#B794F6', // Lavender
            '#4ECDC4', // Turquoise
        ];
        
        const colorSchemes = {
            categories: d3.scaleOrdinal(categoryColors)
        };
        
        // Helper function to adjust color brightness
        function adjustBrightness(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                (G<255?G<1?0:G:255)*0x100 +
                (B<255?B<1?0:B:255))
                .toString(16).slice(1);
        }

        // Global state
        let rawData = [];
        let fullRawData = []; // Store unfiltered data
        let dimensionFilteredData = []; // Store dimension-filtered data (before category filtering)
        let hierarchyData = null;
        let currentView = 'root';
        let viewStack = [];
        let currentSourceFormat = null;
        let availableQuestions = [];
        let availableCategories = [];
        let availableTopics = [];
        let availableLocations = [];
        
        // Filter rules: array of {type: 'category'|'topic'|'location'|'metadata', mode: 'include'|'exclude', values: Set, metadataField?: string}
        let filterRules = [];
        // Store filters per dimension: key is dimension ref key (or 'all' for null), value is array of filter rules
        let dimensionFilters = {}; // Map of dimensionRef -> filterRules array
        let availableMetadataFields = {}; // Map of fieldName -> array of values
        let currentMetadataField = null; // Currently selected metadata field
        let currentClientId = null;
        let currentProjectName = null;
        let currentDataSourceId = null;
        let currentQuestionRefKey = null;
        let allClients = [];
        let clientProjects = [];
        let clientSources = [];
        let dimensionNamesMap = {}; // Map of ref_key -> custom_name

        let headerUserInfoEl = null;
        let headerUserEmailEl = null;
        let headerLogoutButton = null;
        const headerControlState = {
            initialized: false,
            user: null,
        };

        function getHeaderDisplayEmail(user) {
            if (!user || typeof user !== 'object') {
                return '';
            }
            return (
                user.email ||
                user.email_address ||
                user.user_email ||
                user.name ||
                ''
            );
        }

        function handleHeaderLogoutClick() {
            if (typeof Auth !== 'undefined' && typeof Auth.handleLogout === 'function') {
                Auth.handleLogout();
            } else {
                window.dispatchEvent(new Event('auth:logout'));
            }
        }

        function ensureHeaderControls() {
            if (headerControlState.initialized && headerUserInfoEl && headerLogoutButton) {
                return true;
            }

            headerUserInfoEl = document.getElementById('headerUserInfo');
            headerUserEmailEl = document.getElementById('headerUserEmail');
            headerLogoutButton = document.getElementById('headerLogoutButton');

            if (!headerUserInfoEl || !headerLogoutButton) {
                return false;
            }

            headerLogoutButton.addEventListener('click', handleHeaderLogoutClick);
            headerControlState.initialized = true;
            return true;
        }

        function applyHeaderUserState() {
            if (!ensureHeaderControls()) {
                return;
            }

            const user = headerControlState.user;
            if (user) {
                const email = getHeaderDisplayEmail(user);
                if (headerUserEmailEl) {
                    headerUserEmailEl.textContent = email;
                }
                headerUserInfoEl.classList.remove('hidden');
            } else {
                if (headerUserEmailEl) {
                    headerUserEmailEl.textContent = '';
                }
                headerUserInfoEl.classList.add('hidden');
            }
        }

        function showHeaderUserInfo(user) {
            headerControlState.user = user || null;
            applyHeaderUserState();
        }

        function hideHeaderUserInfo() {
            headerControlState.user = null;
            applyHeaderUserState();
        }

        window.addEventListener('marketablyHeader:ready', () => {
            applyHeaderUserState();
        });

        const storedHeaderUser = typeof Auth !== 'undefined' && typeof Auth.getStoredUserInfo === 'function'
            ? Auth.getStoredUserInfo()
            : null;

        if (storedHeaderUser) {
            showHeaderUserInfo(storedHeaderUser);
        } else {
            applyHeaderUserState();
        }
        
        // State persistence constants
        const STATE_STORAGE_KEY = 'treemap_app_state';
        
        // Flag to prevent auto-launch loops
        let hasAutoLaunched = false;
        let isInitializing = false;
        
        // Save current state to localStorage
        function saveState() {
            try {
                const state = {
                    clientId: currentClientId,
                    projectName: currentProjectName,
                    dataSourceId: currentDataSourceId,
                    questionRefKey: currentQuestionRefKey
                };
                localStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(state));
            } catch (error) {
                console.error('Error saving state:', error);
            }
        }
        
        // Load state from localStorage
        function loadState() {
            try {
                const stateJson = localStorage.getItem(STATE_STORAGE_KEY);
                if (stateJson) {
                    return JSON.parse(stateJson);
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
            return null;
        }
        
        // Predefined dimension options
        let dimensionOptions = [
            'Original Desire',
            'Triggers',
            'False Beliefs',
            'Competitors',
            'Appeal',
            'Exclusivity',
            'Objections',
            'Proof Elements',
            'Trusted Personalities',
            'Trusted Media',
            'Usability Friction',
            'Relevant Features',
            'Relevant Benefits',
            'Product Ideas',
            'Service Ideas'
        ];


        // Authentication helpers provided by auth.js
        let accessibleClients = [];
        let accessibleClientIds = new Set();
        let authenticatedUser = null;

        const FILTER_TAB_CONFIG = [
            { key: 'client', tabId: 'clientTab', panelId: 'clientPanel', selectId: 'clientSelect' },
            { key: 'project', tabId: 'projectTab', panelId: 'projectPanel', selectId: 'projectSelect' },
            { key: 'source', tabId: 'sourceTab', panelId: 'sourcePanel', selectId: 'sourceSelect' },
            { key: 'dimension', tabId: 'dimensionTab', panelId: 'dimensionPanel', selectId: 'questionSelect' }
        ];

        function getFilterTabConfig(key) {
            return FILTER_TAB_CONFIG.find((config) => config.key === key);
        }

        function isMobileFilterView() {
            return window.matchMedia('(max-width: 768px)').matches;
        }

        function hasSelectableOption(selectEl) {
            if (!selectEl) {
                return false;
            }
            return Array.from(selectEl.options || []).some((option) => option.value !== '');
        }

        function setTabEnabled(key, enabled) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            if (!tab) return;
            tab.disabled = !enabled;
            tab.classList.toggle('is-disabled', !enabled);
            tab.setAttribute('aria-disabled', enabled ? 'false' : 'true');
            tab.setAttribute('tabindex', enabled ? '0' : '-1');
            if (!enabled) {
                tab.classList.remove('complete');
                tab.classList.remove('active');
                tab.setAttribute('aria-selected', 'false');
            }
        }

        function setTabVisibility(key, visible) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            const panel = document.getElementById(config.panelId);
            if (tab) {
                tab.style.display = visible ? '' : 'none';
                if (!visible) {
                    tab.classList.remove('active');
                    tab.setAttribute('aria-selected', 'false');
                }
            }
            if (panel) {
                panel.dataset.hidden = visible ? 'false' : 'true';
                panel.setAttribute('aria-hidden', visible ? 'false' : 'true');
                if (!visible) {
                    panel.classList.remove('active');
                }
            }
        }

        function markTabComplete(key, complete) {
            const config = getFilterTabConfig(key);
            if (!config) return;
            const tab = document.getElementById(config.tabId);
            if (!tab) return;
            tab.classList.toggle('complete', complete);
        }

        function setActiveTab(tabId) {
            const tab = document.getElementById(tabId);
            if (!tab || tab.disabled || tab.style.display === 'none') {
                return;
            }
            FILTER_TAB_CONFIG.forEach(({ tabId: id, panelId }) => {
                const tabEl = document.getElementById(id);
                const panelEl = document.getElementById(panelId);
                const tabIsVisible = !(tabEl && tabEl.style.display === 'none');
                const isActive = id === tabId && tabIsVisible && !(tabEl && tabEl.disabled);
                if (tabEl) {
                    tabEl.classList.toggle('active', isActive);
                    tabEl.setAttribute('aria-selected', isActive ? 'true' : 'false');
                }
                if (panelEl) {
                    panelEl.classList.toggle('active', isActive);
                    panelEl.setAttribute('aria-hidden', isActive ? 'false' : 'true');
                }
            });
        }

        function ensureActiveFilterTab() {
            const availableTabs = FILTER_TAB_CONFIG
                .map(({ tabId }) => document.getElementById(tabId))
                .filter((tab) => tab && tab.style.display !== 'none' && !tab.disabled);

            if (availableTabs.length === 0) {
                return;
            }

            const currentlyActive = availableTabs.find((tab) => tab.classList.contains('active'));
            if (currentlyActive) {
                setActiveTab(currentlyActive.id);
                return;
            }

            const firstIncomplete = availableTabs.find((tab) => !tab.classList.contains('complete'));
            if (firstIncomplete) {
                setActiveTab(firstIncomplete.id);
                return;
            }

            setActiveTab(availableTabs[0].id);
        }

        function focusNextTab(currentKey) {
            if (!isMobileFilterView()) {
                return;
            }
            const currentIndex = FILTER_TAB_CONFIG.findIndex((config) => config.key === currentKey);
            if (currentIndex === -1) {
                return;
            }
            for (let i = currentIndex + 1; i < FILTER_TAB_CONFIG.length; i++) {
                const nextConfig = FILTER_TAB_CONFIG[i];
                const tabEl = document.getElementById(nextConfig.tabId);
                if (tabEl && !tabEl.disabled && tabEl.style.display !== 'none') {
                    setActiveTab(nextConfig.tabId);
                    break;
                }
            }
        }

        function applyPanelDisplayForViewport() {
            const currentActive = document.querySelector('.filter-tab.active');
            if (currentActive) {
                setActiveTab(currentActive.id);
            } else {
                ensureActiveFilterTab();
            }
        }

        function syncFilterTabState() {
            const clientSelect = document.getElementById('clientSelect');
            const projectSelect = document.getElementById('projectSelect');
            const sourceSelect = document.getElementById('sourceSelect');
            const questionSelect = document.getElementById('questionSelect');

            setTabEnabled('client', !!clientSelect);
            markTabComplete('client', !!clientSelect && !!clientSelect.value);

            const projectHasOptions = hasSelectableOption(projectSelect);
            setTabEnabled('project', projectHasOptions);
            markTabComplete('project', !!projectSelect && !!projectSelect.value);

            const sourceHasOptions = hasSelectableOption(sourceSelect);
            setTabEnabled('source', sourceHasOptions);
            markTabComplete('source', !!sourceSelect && !!sourceSelect.value);

            const dimensionVisible = !!questionSelect && questionSelect.style.display !== 'none';
            setTabVisibility('dimension', dimensionVisible);
            setTabEnabled('dimension', dimensionVisible);
            markTabComplete('dimension', !!questionSelect && !!questionSelect.value);

            ensureActiveFilterTab();
            applyPanelDisplayForViewport();
            // Use requestAnimationFrame to ensure layout is complete
            requestAnimationFrame(() => {
                setTimeout(() => autoSizeFilterSelects(), 0);
            });
        }

        // Auto-size filter selects to fit their content, with truncation if needed
        function autoSizeFilterSelects() {
            // Skip auto-sizing on mobile view where selects should be full width
            if (isMobileFilterView()) {
                return;
            }

            const selectIds = ['clientSelect', 'projectSelect', 'sourceSelect', 'questionSelect'];
            const selects = selectIds
                .map(id => document.getElementById(id))
                .filter(select => select && select.style.display !== 'none' && select.offsetParent !== null);
            
            if (selects.length === 0) return;

            // Get the parent container that holds both filter-panels and data-source-actions
            const contentContainer = document.querySelector('.data-source-selector__content');
            const filterPanels = document.querySelector('.filter-panels');
            const actionsContainer = document.querySelector('.data-source-actions');
            
            if (!contentContainer || !filterPanels) return;

            // Get the actual available width for filter-panels
            // Use getBoundingClientRect for more accurate measurements
            const contentRect = contentContainer.getBoundingClientRect();
            let availableWidth = contentRect.width;
            
            // Account for the actions container if it's visible
            const contentGap = 24; // Gap between filter-panels and actions
            if (actionsContainer && actionsContainer.offsetParent !== null) {
                const actionsRect = actionsContainer.getBoundingClientRect();
                availableWidth = availableWidth - actionsRect.width - contentGap;
            }

            if (availableWidth <= 100) return; // Minimum reasonable width

            // Temporarily reset widths to auto to get accurate measurements
            selects.forEach(select => {
                const originalWidth = select.style.width;
                select.style.width = 'auto';
                // Force a reflow
                void select.offsetWidth;
            });

            // Create a temporary span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.position = 'absolute';
            measureSpan.style.whiteSpace = 'nowrap';
            measureSpan.style.fontSize = window.getComputedStyle(selects[0]).fontSize;
            measureSpan.style.fontFamily = window.getComputedStyle(selects[0]).fontFamily;
            measureSpan.style.fontWeight = window.getComputedStyle(selects[0]).fontWeight;
            measureSpan.style.padding = '0';
            document.body.appendChild(measureSpan);

            // Calculate ideal widths for each select
            const idealWidths = selects.map(select => {
                const selectedOption = select.options[select.selectedIndex];
                const text = selectedOption ? selectedOption.text : '';
                measureSpan.textContent = text;
                // Add padding for dropdown arrow and some extra space
                const selectStyle = window.getComputedStyle(select);
                const padding = parseFloat(selectStyle.paddingLeft) + parseFloat(selectStyle.paddingRight) + 35; // Extra for dropdown arrow
                return Math.max(measureSpan.offsetWidth + padding, 80); // Minimum 80px
            });

            document.body.removeChild(measureSpan);

            const gap = 24; // Gap between panels
            const labelWidths = selects.map(select => {
                const label = document.querySelector(`label[for="${select.id}"]`);
                if (label && label.offsetParent !== null) {
                    const labelStyle = window.getComputedStyle(label);
                    const labelGap = parseFloat(labelStyle.marginRight) || 10;
                    return label.offsetWidth + labelGap;
                }
                return 0;
            });

            // Calculate total width needed
            const totalNeeded = idealWidths.reduce((sum, width, i) => sum + width + labelWidths[i], 0) + 
                                (selects.length - 1) * gap;

            // Add a small buffer (20px) to account for any measurement inaccuracies
            const buffer = 20;

            // If everything fits (with small buffer), use ideal widths
            if (totalNeeded <= availableWidth + buffer) {
                selects.forEach((select, i) => {
                    select.style.width = idealWidths[i] + 'px';
                    select.style.minWidth = '0';
                    select.style.maxWidth = 'none';
                });
            } else {
                // Need to truncate - distribute available space proportionally
                const availableForSelects = availableWidth - (selects.length - 1) * gap - 
                                         labelWidths.reduce((sum, w) => sum + w, 0);
                
                // Calculate proportional widths
                const totalIdeal = idealWidths.reduce((sum, w) => sum + w, 0);
                const scale = Math.max(0, Math.min(1, availableForSelects / totalIdeal));

                selects.forEach((select, i) => {
                    const scaledWidth = Math.max(80, Math.floor(idealWidths[i] * scale));
                    select.style.width = scaledWidth + 'px';
                    select.style.minWidth = '0';
                    select.style.maxWidth = 'none';
                });
            }
        }

        let filterTabsInitialized = false;

        function setupFilterTabs() {
            if (filterTabsInitialized) {
                syncFilterTabState();
                return;
            }

            FILTER_TAB_CONFIG.forEach((config) => {
                const tab = document.getElementById(config.tabId);
                const select = document.getElementById(config.selectId);
                if (tab) {
                    tab.addEventListener('click', () => setActiveTab(config.tabId));
                }
                if (select && !select.dataset.mobileNavBound) {
                    select.addEventListener('change', (event) => {
                        syncFilterTabState();
                        if (event.target.value) {
                            focusNextTab(config.key);
                        } else if (isMobileFilterView()) {
                            setActiveTab(config.tabId);
                        }
                    });
                    select.dataset.mobileNavBound = 'true';
                }
            });

            window.addEventListener('resize', applyPanelDisplayForViewport);
            
            // Add debounced resize listener for auto-sizing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    autoSizeFilterSelects();
                }, 100);
            });
            
            filterTabsInitialized = true;
            syncFilterTabState();
        }

        function updateAccessibleClients(clients = []) {
            accessibleClients = Array.isArray(clients) ? clients : [];
            accessibleClientIds = new Set(
                accessibleClients.map((client) => client.id)
            );
        }

        function enterAccountSelectionMode() {
            const overlay = document.getElementById('loginOverlay');
            const mainContainer = document.getElementById('mainContainer');
            const formSection = document.getElementById('loginFormSection');
            const selectionSection = document.getElementById('accountSelectionSection');
            const successMessage = document.getElementById('loginSuccess');
            const errorMessage = document.getElementById('loginError');
            const loginContainer = document.querySelector('.login-container');

            if (mainContainer) {
                mainContainer.style.display = 'none';
            }
            if (overlay) {
                overlay.classList.remove('hidden');
            }
            if (formSection) {
                formSection.classList.add('hidden');
            }
            if (selectionSection) {
                selectionSection.classList.remove('hidden');
            }
            if (successMessage) {
                successMessage.style.display = 'none';
            }
            if (errorMessage) {
                errorMessage.style.display = 'none';
            }
            if (loginContainer) {
                loginContainer.classList.add('account-selection-mode');
                loginContainer.scrollTop = 0;
            }
        }

        function renderAccountSelection(clients) {
            enterAccountSelectionMode();
            const listEl = document.getElementById('accountSelectionList');
            const errorEl = document.getElementById('accountSelectionError');
            const greetingEl = document.getElementById('accountSelectionGreeting');

            if (errorEl) {
                errorEl.style.display = 'none';
            }

            if (!listEl) {
                console.error('Account selection list element not found');
                return;
            }

            listEl.innerHTML = '';
            listEl.scrollTop = 0;

            if (greetingEl) {
                const nameSources = [
                    authenticatedUser?.first_name,
                    authenticatedUser?.name,
                    authenticatedUser?.email
                        ? authenticatedUser.email.split('@')[0]
                        : null,
                ].filter(Boolean);
                const firstName = nameSources.length
                    ? String(nameSources[0]).split(' ')[0]
                    : null;
                greetingEl.textContent = firstName
                    ? `Hi ${firstName},`
                    : 'Welcome back,';
                greetingEl.style.display = 'block';
            }

            const getClientLabel = (client) =>
                client?.name ||
                client?.client_name ||
                client?.display_name ||
                client?.clientUuid ||
                client?.client_uuid ||
                client?.id ||
                'Client';

            const sortedClients = [...clients].sort((a, b) => {
                const labelA = getClientLabel(a).toLowerCase();
                const labelB = getClientLabel(b).toLowerCase();
                return labelA.localeCompare(labelB);
            });

            sortedClients.forEach((client) => {
                const clientId =
                    client?.id ??
                    client?.client_uuid ??
                    client?.clientUuid ??
                    client?.uuid ??
                    null;

                const button = document.createElement('button');
                button.className = 'account-option';
                if (clientId) {
                    button.dataset.clientId = clientId;
                }
                button.textContent = getClientLabel(client);
                button.setAttribute('role', 'listitem');
                button.addEventListener('click', () => {
                    if (clientId) {
                        selectClientAndLaunch(clientId);
                    }
                });
                listEl.appendChild(button);
            });
        }

        function selectClientAndLaunch(clientId) {
            // Prevent multiple calls
            if (hasAutoLaunched && currentClientId === clientId) {
                return;
            }
            currentClientId = clientId;
            
            // Sync Insights tab client ID to keep both tabs in sync
            if (typeof insightsCurrentClientId !== 'undefined') {
                insightsCurrentClientId = clientId;
            }
            
            saveState();
            hasAutoLaunched = true;
            const loginContainer = document.querySelector('.login-container');
            if (loginContainer) {
                loginContainer.classList.remove('account-selection-mode');
            }
            if (typeof Auth !== 'undefined') {
                Auth.hideLogin();
            }
            const mainContainer = document.getElementById('mainContainer');
            if (mainContainer) {
                mainContainer.style.display = 'flex';
            }
            // Only call init if we haven't already initialized
            // Check if we're already in the main view - if so, just load the data
            const isAlreadyInitialized = mainContainer && mainContainer.style.display !== 'none' && 
                                         document.querySelector('.treemap-svg-container');
            if (!isAlreadyInitialized) {
                init();
            } else {
                // Already initialized, just load the client's data
                // But make sure UI handlers are set up
                setupFilterUI();
                setupAddButton();
                
                // Ensure client dropdown is populated (loadClients might not have been called)
                const select = document.getElementById('clientSelect');
                const urlParams = new URLSearchParams(window.location.search);
                const urlProject = urlParams.get('project');
                const urlSource = urlParams.get('source');
                const urlDimension = urlParams.get('dimension');
                
                // Check saved state for restoration
                const savedState = loadState();
                
                // Priority: URL params > current globals > saved state
                // This ensures values restored in handleAuthenticatedUser() are used
                const restoreState = {
                    projectName: urlProject || currentProjectName || (savedState && savedState.projectName) || null,
                    dataSourceId: urlSource || currentDataSourceId || (savedState && savedState.dataSourceId) || null,
                    questionRefKey: urlDimension || currentQuestionRefKey || (savedState && savedState.questionRefKey) || null
                };
                
                // Update globals if we have values from URL or saved state (but not if already set from handleAuthenticatedUser)
                if (restoreState.projectName && !currentProjectName) currentProjectName = restoreState.projectName;
                if (restoreState.dataSourceId && !currentDataSourceId) currentDataSourceId = restoreState.dataSourceId;
                if (restoreState.questionRefKey && !currentQuestionRefKey) currentQuestionRefKey = restoreState.questionRefKey;
                
                if (select && (select.innerHTML === '' || select.innerHTML.includes('Loading'))) {
                    console.log('Client dropdown not populated, loading clients...');
                    // Temporarily set hasAutoLaunched to prevent loadClients from triggering another launch
                    const wasAutoLaunched = hasAutoLaunched;
                    hasAutoLaunched = true;
                    loadClients().then(() => {
                        // Restore the flag
                        hasAutoLaunched = wasAutoLaunched;
                        // After clients are loaded, load the specific client's data
                        return loadClientProjects(clientId, restoreState);
                    }).then(() => {
                        // renderFavourites(); // Removed - favourites section no longer exists
                        updateNavLinks(); // Update nav links after client loads
                    }).catch((error) => {
                        console.error('Error loading clients or projects:', error);
                        hasAutoLaunched = wasAutoLaunched;
                    });
                } else {
                    // Dropdown already populated, just load the client's data
                    loadClientProjects(clientId, restoreState).then(() => {
                        // renderFavourites(); // Removed - favourites section no longer exists
                        updateNavLinks(); // Update nav links after client loads
                    });
                }
            }
        }

        function handleAuthenticatedUser(userInfo) {
            if (!userInfo) {
                return;
            }

            authenticatedUser = userInfo;
            showHeaderUserInfo(userInfo);
            updateAccessibleClients(userInfo.accessible_clients || []);

            if (accessibleClients.length === 0) {
                const errorEl = document.getElementById('accountSelectionError');
                if (errorEl) {
                    errorEl.textContent = 'No accounts are linked to your email yet. Please contact your administrator.';
                    errorEl.style.display = 'block';
                }
                if (typeof Auth !== 'undefined') {
                    Auth.showLogin();
                }
                return;
            }

            // Check for client_uuid in URL - if present and accessible, auto-launch
            const urlParams = new URLSearchParams(window.location.search);
            const urlClientUuid = urlParams.get('client_uuid');
            if (urlClientUuid) {
                // Check if the client_uuid is in the accessible clients list
                const matchingClient = accessibleClients.find(client => 
                    client.client_uuid === urlClientUuid || client.id === urlClientUuid
                );
                if (matchingClient) {
                    console.log('Found client_uuid in URL, auto-launching:', urlClientUuid);
                    selectClientAndLaunch(urlClientUuid);
                    return;
                } else {
                    console.log('Client_uuid in URL not found in accessible clients:', urlClientUuid);
                }
            }

            // Check saved state - if there's a saved client that's accessible, auto-launch it
            const savedState = loadState();
            if (savedState && savedState.clientId) {
                const matchingClient = accessibleClients.find(client => 
                    client.client_uuid === savedState.clientId || client.id === savedState.clientId
                );
                if (matchingClient) {
                    console.log('Found saved client in state, auto-launching:', savedState.clientId);
                    // Restore the full state (project, source, dimension) before launching
                    // so it's available throughout the loading chain
                    if (savedState.projectName) {
                        currentProjectName = savedState.projectName;
                        console.log('Restored saved project:', currentProjectName);
                    }
                    if (savedState.dataSourceId) {
                        currentDataSourceId = savedState.dataSourceId;
                        console.log('Restored saved data source:', currentDataSourceId);
                    }
                    if (savedState.questionRefKey) {
                        currentQuestionRefKey = savedState.questionRefKey;
                        console.log('Restored saved dimension:', currentQuestionRefKey);
                    }
                    selectClientAndLaunch(savedState.clientId);
                    return;
                } else {
                    console.log('Saved client not found in accessible clients:', savedState.clientId);
                }
            }

            if (accessibleClients.length === 1) {
                selectClientAndLaunch(accessibleClients[0].id);
                return;
            }

            renderAccountSelection(accessibleClients);
        }

        window.addEventListener('auth:authenticated', (event) => {
            const userInfo = event.detail?.user;
            handleAuthenticatedUser(userInfo);
        });

        window.addEventListener('auth:magicVerified', (event) => {
            const userInfo = event.detail?.user;
            if (userInfo) {
                handleAuthenticatedUser(userInfo);
            }
        });

        window.addEventListener('auth:logout', () => {
            accessibleClients = [];
            accessibleClientIds = new Set();
            authenticatedUser = null;
            hideHeaderUserInfo();
        });

        // API Configuration - loaded from server config
        const API_BASE_URL = window.APP_CONFIG?.API_BASE_URL || 'http://localhost:8000';
        
        // Load available clients
        async function loadClients() {
            console.log('loadClients() called');
            try {
                console.log(`Fetching clients from ${API_BASE_URL}/api/voc/clients`);
                const response = await fetch(`${API_BASE_URL}/api/voc/clients`, {
                    headers: getAuthHeaders()
                });
                console.log('Clients response status:', response.status);
                if (!response.ok) {
                    throw new Error('Failed to load clients');
                }
                console.log('Parsing clients JSON...');
                allClients = await response.json();
                console.log(`Loaded ${allClients.length} clients:`, allClients);

                if (accessibleClientIds.size > 0) {
                    allClients = allClients.filter(client => {
                        // Check both client.id and client.client_uuid since accessibleClientIds uses client.id
                        return (client.client_uuid && accessibleClientIds.has(client.client_uuid)) ||
                               (client.id && accessibleClientIds.has(client.id));
                    });
                    console.log(`Filtered to ${allClients.length} authorized clients`);
                }

                // Sort clients alphabetically by client_name
                allClients.sort((a, b) => {
                    const nameA = (a.client_name || '').toLowerCase();
                    const nameB = (b.client_name || '').toLowerCase();
                    return nameA.localeCompare(nameB);
                });

                const select = document.getElementById('clientSelect');
                console.log('Client select element:', select);
                if (!select) {
                    console.error('Client select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (allClients.length === 0) {
                    console.log('No clients available');
                    select.innerHTML = '<option value="">No clients available</option>';
                    select.disabled = true;
                    return;
                }
                select.disabled = false;
                
                // Check URL parameters for client_uuid and other state (e.g., when navigating back)
                const urlParams = new URLSearchParams(window.location.search);
                const urlClientUuid = urlParams.get('client_uuid');
                const urlProject = urlParams.get('project');
                const urlSource = urlParams.get('source');
                const urlDimension = urlParams.get('dimension');
                
                // Try to restore saved state
                const savedState = loadState();
                console.log('Saved state:', savedState);
                console.log('URL params:', { urlClientUuid, urlProject, urlSource, urlDimension });
                
                // Priority: URL parameter > saved state > current
                // Check if URL client_uuid matches any accessible client (by id or client_uuid)
                if (urlClientUuid) {
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === urlClientUuid || client.id === urlClientUuid
                    );
                    if (matchingClient) {
                        currentClientId = urlClientUuid;
                        console.log('Restored client from URL:', currentClientId);
                        // Restore other state from URL if present
                        if (urlProject) {
                            currentProjectName = urlProject;
                            console.log('Restored project from URL:', currentProjectName);
                        }
                        if (urlSource) {
                            currentDataSourceId = urlSource;
                            console.log('Restored data source from URL:', currentDataSourceId);
                        }
                        if (urlDimension) {
                            currentQuestionRefKey = urlDimension;
                            console.log('Restored dimension from URL:', currentQuestionRefKey);
                        }
                    }
                } else if (savedState && savedState.clientId) {
                    // Check if saved client exists in accessible clients
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === savedState.clientId || client.id === savedState.clientId
                    );
                    if (matchingClient) {
                        currentClientId = savedState.clientId;
                        console.log('Restored client from saved state:', currentClientId);
                    }
                }

                // Validate current client is in accessible list
                if (currentClientId) {
                    const matchingClient = allClients.find(client => 
                        client.client_uuid === currentClientId || client.id === currentClientId
                    );
                    if (!matchingClient) {
                        console.log('Stored client is not accessible, clearing');
                        currentClientId = null;
                    }
                }

                console.log('Populating client dropdown...');
                allClients.forEach((client, index) => {
                    const option = document.createElement('option');
                    option.value = client.client_uuid;
                    option.textContent = client.client_name || `Client ${client.client_uuid}`;
                    select.appendChild(option);
                    
                    // Restore saved client or select first one by default (only if not already set from URL)
                    if (!currentClientId) {
                        if (savedState && savedState.clientId === client.client_uuid) {
                            currentClientId = client.client_uuid;
                        } else if (!savedState && index === 0) {
                            currentClientId = client.client_uuid;
                        }
                    }
                });

                if (!currentClientId && accessibleClients.length > 0) {
                    const preferredClient = accessibleClients.find(client =>
                        accessibleClientIds.has(client.id)
                    );
                    if (preferredClient) {
                        currentClientId = preferredClient.id;
                    }
                }

                // Set the select value to match the current client
                if (currentClientId) {
                    select.value = currentClientId;
                    // If we restored from URL, trigger the client selection to load data (only once)
                    // Check if we're in login/selection mode (login container visible or main container hidden)
                    // Only auto-launch if we're NOT already in the process of launching (to prevent double loads)
                    const loginContainer = document.querySelector('.login-container');
                    const mainContainer = document.getElementById('mainContainer');
                    const isLoginVisible = loginContainer && (loginContainer.style.display !== 'none' || loginContainer.classList.contains('account-selection-mode'));
                    const isMainVisible = mainContainer && mainContainer.style.display !== 'none';
                    const isInitialized = document.querySelector('.treemap-svg-container') !== null;
                    
                    // Auto-launch if we have URL params and we're in login/selection mode
                    // But NOT if we're already initialized and main container is visible (prevents double load)
                    if (urlClientUuid && urlClientUuid === currentClientId && !hasAutoLaunched && (isLoginVisible || !isMainVisible) && !isInitialized && !isMainVisible) {
                        console.log('Auto-launching client from URL:', currentClientId);
                        // Use setTimeout to ensure DOM is ready and avoid calling during loadClients
                        setTimeout(() => {
                            // Double-check we haven't launched yet (race condition protection)
                            if (!hasAutoLaunched && currentClientId === urlClientUuid) {
                                selectClientAndLaunch(currentClientId);
                            }
                        }, 300);
                    }
                }
                
                // Add change listener (remove existing one first to avoid duplicates)
                const handleClientChange = async (e) => {
                    const newClientId = e.target.value;
                    if (!newClientId || newClientId === currentClientId) {
                        return; // No change or same client
                    }
                    currentClientId = newClientId;
                    
                    // Sync Insights tab client ID to keep both tabs in sync
                    if (typeof insightsCurrentClientId !== 'undefined') {
                        insightsCurrentClientId = newClientId;
                    }
                    
                    currentProjectName = null; // Reset project when client changes
                    currentDataSourceId = null; // Reset data source when client changes
                    currentQuestionRefKey = null; // Reset question when client changes
                    dimensionFilters = {}; // Clear dimension filters when client changes
                    saveState();
                    updateAddDataButton(); // Update Add button with new client
                    await loadClientProjects(currentClientId);
                    renderFavourites(); // Re-render favourites for new client
                };
                // Remove any existing listener
                select.removeEventListener('change', handleClientChange);
                select.addEventListener('change', handleClientChange);
                
                // Load projects for the selected client (only if not already loading from selectClientAndLaunch)
                // Create a combined state object with priority: URL params > current globals > saved state
                // This ensures values restored in handleAuthenticatedUser() are used
                const restoreState = {
                    projectName: urlProject || currentProjectName || (savedState && savedState.projectName) || null,
                    dataSourceId: urlSource || currentDataSourceId || (savedState && savedState.dataSourceId) || null,
                    questionRefKey: urlDimension || currentQuestionRefKey || (savedState && savedState.questionRefKey) || null
                };
                
                // Only auto-load projects if we're not already in the process of launching a client
                // (to prevent double loading when called from selectClientAndLaunch)
                // But allow loading if we're in the main view and not already initialized (page refresh scenario)
                const mainContainer = document.getElementById('mainContainer');
                const isMainVisible = mainContainer && mainContainer.style.display !== 'none';
                const isInitialized = document.querySelector('.treemap-svg-container') !== null;
                // Load if: not auto-launched yet, OR main is not visible, OR (main is visible but not initialized - refresh scenario)
                const shouldAutoLoad = !hasAutoLaunched || !isMainVisible || (isMainVisible && !isInitialized);
                
                if (currentClientId && shouldAutoLoad) {
                    console.log(`Loading projects for client: ${currentClientId} with state:`, restoreState);
                    await loadClientProjects(currentClientId, restoreState);
                } else if (currentClientId) {
                    console.log('Skipping auto-load of projects (already loading from selectClientAndLaunch)');
                } else {
                    console.log('No client selected, skipping project load');
                }
                syncFilterTabState();
                
                // Set up Add button handler
                setupAddButton();
            } catch (error) {
                console.error('Error loading clients:', error);
                console.error('Error stack:', error.stack);
                const select = document.getElementById('clientSelect');
                select.innerHTML = '<option value="">Error loading clients</option>';
                syncFilterTabState();
            }
        }
        
        // Load projects for a specific client
        async function loadClientProjects(clientId, savedState = null) {
            console.log(`loadClientProjects() called for client: ${clientId}`);
            try {
                // Restore saved project name if available
                if (savedState && savedState.projectName) {
                    currentProjectName = savedState.projectName;
                    console.log(`Restoring saved project: ${currentProjectName}`);
                }
                
                const url = `${API_BASE_URL}/api/voc/projects?client_uuid=${clientId}`;
                console.log(`Fetching projects from: ${url}`);
                const response = await fetch(url, {
                    headers: getAuthHeaders()
                });
                console.log('Projects response status:', response.status);
                if (!response.ok) {
                    throw new Error('Failed to load projects');
                }
                clientProjects = await response.json();
                console.log(`Loaded ${clientProjects.length} projects:`, clientProjects);
                
                const select = document.getElementById('projectSelect');
                console.log('Project select element:', select);
                if (!select) {
                    console.error('Project select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (clientProjects.length === 0) {
                    console.log('No projects available');
                    select.innerHTML = '<option value="">No projects available</option>';
                    currentProjectName = null;
                } else {
                    console.log('Populating project dropdown...');
                    clientProjects.forEach((project) => {
                        const option = document.createElement('option');
                        option.value = project.project_name;
                        option.textContent = project.project_name || 'Unknown Project';
                        select.appendChild(option);
                    });
                    
                    // Validate that the saved project name exists in the list
                    if (currentProjectName) {
                        const projectExists = clientProjects.some(p => p.project_name === currentProjectName);
                        if (!projectExists) {
                            console.warn(`Saved project "${currentProjectName}" not found in available projects, defaulting to first`);
                            currentProjectName = null;
                        }
                    }
                    
                    // Default to first project if no saved selection
                    if (!currentProjectName && clientProjects.length > 0) {
                        currentProjectName = clientProjects[0].project_name;
                        console.log(`Defaulting to first project: ${currentProjectName}`);
                    }
                    
                    console.log(`Current project name after validation: ${currentProjectName}`);
                    
                    // Set the select value to match the current project
                    if (currentProjectName) {
                        select.value = currentProjectName;
                        console.log(`Set select value to: ${currentProjectName}`);
                    }
                }
                
                // Add change listener (only once)
                select.removeEventListener('change', handleProjectChange);
                select.addEventListener('change', handleProjectChange);
                console.log('Added change listener to project select');
                
                // Load sources for the selected client (and project if selected)
                if (currentClientId) {
                    console.log(`Loading sources for client: ${currentClientId}, project: ${currentProjectName || 'None'}`);
                    await loadClientSources(currentClientId, savedState);
                } else {
                    console.log('No client selected, skipping source load');
                }
                syncFilterTabState();
            } catch (error) {
                console.error('Error loading projects:', error);
                const select = document.getElementById('projectSelect');
                if (select) {
                    select.innerHTML = '<option value="">Error loading projects</option>';
                }
                syncFilterTabState();
            }
        }
        
        // Handle project selection change
        async function handleProjectChange(e) {
            currentProjectName = e.target.value || null; // Empty string becomes null
            currentDataSourceId = null; // Reset data source when project changes
            currentQuestionRefKey = null; // Reset question when project changes
            dimensionFilters = {}; // Clear dimension filters when project changes
            saveState();
            updateNavLinks(); // Update nav links after project changes
            await loadClientSources(currentClientId);
            renderFavourites(); // Re-render favourites for new project
        }
        
        // Load sources for a specific client
        async function loadClientSources(clientId, savedState = null) {
            console.log(`loadClientSources() called for client: ${clientId}, project: ${currentProjectName || 'None'}`);
            try {
                let url = `${API_BASE_URL}/api/voc/sources?client_uuid=${clientId}`;
                if (currentProjectName) {
                    url += `&project_name=${encodeURIComponent(currentProjectName)}`;
                }
                console.log(`Fetching sources from: ${url}`);
                const response = await fetch(url, {
                    headers: getAuthHeaders()
                });
                console.log('Sources response status:', response.status);
                if (!response.ok) {
                    throw new Error('Failed to load sources');
                }
                clientSources = await response.json();
                console.log(`Loaded ${clientSources.length} sources:`, clientSources);
                
                const select = document.getElementById('sourceSelect');
                console.log('Source select element:', select);
                if (!select) {
                    console.error('Source select element not found!');
                    return;
                }
                select.innerHTML = '';
                
                if (clientSources.length === 0) {
                    console.log('No sources available');
                    select.innerHTML = '<option value="">No sources available</option>';
                    currentDataSourceId = null;
                } else {
                    console.log('Populating source dropdown...');
                    clientSources.forEach((source) => {
                        const option = document.createElement('option');
                        option.value = source.data_source;
                        option.textContent = source.data_source || 'Unknown Source';
                        select.appendChild(option);
                    });
                    
                    // Restore saved data source from savedState if it exists
                    if (savedState && savedState.dataSourceId) {
                        // Validate that the saved data source exists in the list
                        const sourceExists = clientSources.some(s => s.data_source === savedState.dataSourceId);
                        if (sourceExists) {
                            currentDataSourceId = savedState.dataSourceId;
                            console.log(`Restored saved data source: ${currentDataSourceId}`);
                        } else {
                            console.warn(`Saved data source "${savedState.dataSourceId}" not found in available sources, defaulting to first`);
                            currentDataSourceId = null;
                        }
                    }
                    
                    // Default to first source if no saved selection
                    if (!currentDataSourceId && clientSources.length > 0) {
                        currentDataSourceId = clientSources[0].data_source;
                        console.log(`Defaulting to first source: ${currentDataSourceId}`);
                    }
                    
                    console.log(`Current data source ID after validation: ${currentDataSourceId}`);
                    
                    // Set the select value to match the current data source
                    if (currentDataSourceId) {
                        select.value = currentDataSourceId;
                        console.log(`Set select value to: ${currentDataSourceId}`);
                    }
                }
                
                // Add change listener (only once)
                select.removeEventListener('change', handleSourceChange);
                select.addEventListener('change', handleSourceChange);
                console.log('Added change listener to source select');
                syncFilterTabState();
                
                // Load data for the selected source
                console.log(`About to load data: client=${clientId}, source=${currentDataSourceId || 'None'}`);
                await loadDataSource(clientId, currentDataSourceId, savedState);
                console.log('loadDataSource completed');
            } catch (error) {
                console.error('Error loading sources:', error);
                const select = document.getElementById('sourceSelect');
                select.innerHTML = '<option value="">Error loading sources</option>';
                syncFilterTabState();
            }
        }
        
        // Handle source selection change
        async function handleSourceChange(e) {
            currentDataSourceId = e.target.value || null; // Empty string becomes null
            currentQuestionRefKey = null; // Reset question when source changes
            dimensionFilters = {}; // Clear dimension filters when data source changes
            saveState();
            updateNavLinks(); // Update nav links after source changes
            await loadDataSource(currentClientId, currentDataSourceId);
        }
        
        // Update treemap title with question text if available
        function updateTreemapTitle() {
            const treemapTitleEl = document.querySelector('.treemap-title');
            if (!treemapTitleEl || !fullRawData || fullRawData.length === 0) {
                return;
            }
            
            let questionText = null;
            
            // Only show question_text when a specific dimension is selected
            // This avoids confusion when "All Dimensions" is selected (multiple questions possible)
            if (currentQuestionRefKey) {
                const dimensionRow = fullRawData.find(row => 
                    row.dimension_ref === currentQuestionRefKey && 
                    row.question_text && 
                    row.question_text.trim() !== ''
                );
                if (dimensionRow) {
                    questionText = dimensionRow.question_text;
                }
            }
            
            // Update the title
            if (questionText) {
                treemapTitleEl.textContent = questionText;
            } else {
                treemapTitleEl.textContent = 'Topic Distribution';
            }
        }
        
        // Update breadcrumb display
        function updateBreadcrumb(questionRefKey) {
            const client = allClients.find(c => c.client_uuid === currentClientId);
            const source = currentDataSourceId ? clientSources.find(s => s.data_source === currentDataSourceId) : null;
            
            if (client) {
                let breadcrumb = `${client.client_name || 'Unknown Client'}`;
                
                // Add project to breadcrumb if selected
                if (currentProjectName) {
                    breadcrumb += ` > ${currentProjectName}`;
                }
                
                // Add source to breadcrumb if selected
                if (source) {
                    breadcrumb += ` > ${source.data_source || 'Unknown Source'}`;
                }
                
                // Add question to breadcrumb if specified
                if (questionRefKey) {
                    const questionLabel = questionRefKey.replace('ref_', 'Q');
                    breadcrumb += ` > ${questionLabel}`;
                }
                
                // Update header subtitle if it exists
                const headerP = document.querySelector('.header p');
                if (headerP && !headerP.classList.contains('breadcrumb-display')) {
                    headerP.innerHTML = `Topic visualization and analysis<br><span class="breadcrumb-display">${breadcrumb}</span>`;
                }
            }
        }
        
        // Toggle skeleton loading states
        function setLoading(isLoading) {
            const treemapContainer = document.querySelector('.treemap-svg-container');
            const charts = document.querySelectorAll('.chart');
            if (treemapContainer) {
                treemapContainer.classList.toggle('is-loading', isLoading);
            }
            charts.forEach(c => c.classList.toggle('is-loading', isLoading));
        }

        // Group process_voc rows by respondent_id and merge topics
        function groupProcessVocRows(processVocRows, dimensionRef = null) {
            console.log(`Grouping ${processVocRows.length} rows${dimensionRef ? ` for dimension ${dimensionRef}` : ' (all dimensions)'}`);
            
            // Filter by dimension if specified
            let filteredRows = dimensionRef 
                ? processVocRows.filter(row => row.dimension_ref === dimensionRef)
                : processVocRows;
            
            console.log(`Filtered to ${filteredRows.length} rows`);
            
            // When "All Dimensions" is selected, we need to preserve dimension context with topics
            // to avoid mixing verbatims from different dimensions
            if (!dimensionRef) {
                // Group by respondent_id AND dimension_ref to keep topics separate
                const grouped = {};
                let totalTopics = 0;
                let rowsWithoutTopics = 0;
                
                filteredRows.forEach(row => {
                    const key = `${row.respondent_id}::${row.dimension_ref}`;
                    if (!grouped[key]) {
                        // Build metadata object from survey_metadata.metadata if available,
                        // otherwise fall back to individual columns for backwards compatibility
                        const surveyMetadata = row.survey_metadata?.metadata || {};
                        
                        // Merge survey metadata with other fields that aren't part of survey_metadata
                        // (These are always needed regardless of survey_metadata)
                        // Note: dimension_name is removed from metadata as requested
                        const metadata = {
                            ref_key: row.dimension_ref,
                            source_type: row.data_source || '',
                            created_at: row.created,
                            sentiment: row.overall_sentiment || 'neutral',
                            // Merge in all fields from survey_metadata.metadata
                            ...surveyMetadata
                        };
                        
                        grouped[key] = {
                            row_id: row.respondent_id,
                            text: row.value || '',
                            topics: [],
                            sentiment: row.overall_sentiment || 'neutral',
                            metadata: metadata,
                            dimension_ref: row.dimension_ref // Preserve dimension for topic matching
                        };
                    }
                    
                    // Add topics with dimension context
                    if (row.topics && Array.isArray(row.topics)) {
                        // Attach dimension_ref to each topic so we can match verbatims correctly
                        const topicsWithDimension = row.topics.map(topic => ({
                            ...topic,
                            _dimension_ref: row.dimension_ref // Internal field for matching
                        }));
                        grouped[key].topics.push(...topicsWithDimension);
                        totalTopics += row.topics.length;
                    } else {
                        rowsWithoutTopics++;
                    }
                    
                    // Use first non-empty value as text
                    if (!grouped[key].text && row.value) {
                        grouped[key].text = row.value;
                    }
                });
                
                const result = Object.values(grouped);
                console.log(`Grouped into ${result.length} unique respondent-dimension combinations with ${totalTopics} total topics`);
                if (rowsWithoutTopics > 0) {
                    console.log(`Note: ${rowsWithoutTopics} row(s) without topics (expected behavior - some dimensions may not have topics)`);
                }
                if (result.length > 0) {
                    console.log(`Sample grouped row:`, JSON.stringify(result[0], null, 2).substring(0, 300));
                }
                
                return result;
            } else {
                // Single dimension: group by respondent_id only (original behavior)
                const grouped = {};
                let totalTopics = 0;
                let rowsWithoutTopics = 0;
                
                filteredRows.forEach(row => {
                    const respondentId = row.respondent_id;
                    if (!grouped[respondentId]) {
                        // Build metadata object from survey_metadata.metadata if available,
                        // otherwise fall back to individual columns for backwards compatibility
                        const surveyMetadata = row.survey_metadata?.metadata || {};
                        
                        // Merge survey metadata with other fields that aren't part of survey_metadata
                        // (These are always needed regardless of survey_metadata)
                        // Note: dimension_name is removed from metadata as requested
                        const metadata = {
                            ref_key: dimensionRef || row.dimension_ref,
                            source_type: row.data_source || '',
                            created_at: row.created,
                            sentiment: row.overall_sentiment || 'neutral',
                            // Merge in all fields from survey_metadata.metadata
                            ...surveyMetadata
                        };
                        
                        grouped[respondentId] = {
                            row_id: respondentId,
                            text: row.value || '',
                            topics: [],
                            sentiment: row.overall_sentiment || 'neutral',
                            metadata: metadata
                        };
                    }
                    
                    // Merge topics from this dimension
                    if (row.topics && Array.isArray(row.topics)) {
                        grouped[respondentId].topics.push(...row.topics);
                        totalTopics += row.topics.length;
                    } else {
                        // Track rows without topics (expected for some dimensions)
                        rowsWithoutTopics++;
                    }
                    
                    // Use first non-empty value as text
                    if (!grouped[respondentId].text && row.value) {
                        grouped[respondentId].text = row.value;
                    }
                });
                
                const result = Object.values(grouped);
                console.log(`Grouped into ${result.length} unique respondents with ${totalTopics} total topics`);
                if (rowsWithoutTopics > 0) {
                    console.log(`Note: ${rowsWithoutTopics} row(s) without topics${dimensionRef ? ` for dimension ${dimensionRef}` : ''} (expected behavior - some dimensions may not have topics)`);
                }
                if (result.length > 0) {
                    console.log(`Sample grouped row:`, JSON.stringify(result[0], null, 2).substring(0, 300));
                }
                
                return result;
            }
        }

        // Load a specific data source
        async function loadDataSource(clientUuid, dataSource, savedState = null) {
            console.log(`loadDataSource() called: client=${clientUuid}, project=${currentProjectName || 'None'}, source=${dataSource || 'None'}`);
            try {
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loading').innerHTML = 'Loading data...';
                setLoading(true);
                
                // Build query parameters
                const params = new URLSearchParams();
                if (clientUuid) params.append('client_uuid', clientUuid);
                if (currentProjectName) params.append('project_name', currentProjectName);
                if (dataSource) params.append('data_source', dataSource);
                
                const url = `${API_BASE_URL}/api/voc/data?${params.toString()}`;
                console.log(`Fetching data from: ${url}`);
                const response = await fetch(url, {
                    headers: getAuthHeaders()
                });
                console.log('Data response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: Failed to load data`);
                }
                
                console.log('Parsing data JSON...');
                const processVocRows = await response.json();
                console.log(`Received ${processVocRows.length} process_voc rows`);
                
                // Validate response structure
                if (!processVocRows || !Array.isArray(processVocRows)) {
                    throw new Error('Invalid response structure: expected array of process_voc rows');
                }
                
                console.log(`Loaded ${processVocRows.length} process_voc rows`);
                
                // Store raw process_voc rows
                fullRawData = processVocRows;
                
                // Update treemap title with question text if available
                updateTreemapTitle();
                
                // Update breadcrumb
                updateBreadcrumb();
                
                // Detect if this is survey data with multiple questions
                // This will set up the question filter and call filterByQuestion which groups and renders
                await detectAndSetupQuestionFilter(savedState);
                
                // If detectAndSetupQuestionFilter didn't set up questions (no dimensions found),
                // or if it returned early, we need to group and render the data ourselves
                // filterByQuestion should have been called if questions were found, but as a fallback:
                if (!rawData || rawData.length === 0) {
                    console.log('No data grouped yet, grouping now...');
                    const groupedData = groupProcessVocRows(fullRawData, null);
                    rawData = groupedData;
                    dimensionFilteredData = groupedData; // Set to grouped data (has text field)
                    
                    // Extract and setup category filter
                    extractAvailableFilterOptions(rawData);
                    filterRules = []; // Reset filters when loading new data
                    updateFilterUI();
                    
                    // Process and render
                    processData();
                    renderTreemap(hierarchyData);
                    renderBarChart();
                    renderTopicsChart();
                }
                // Otherwise, filterByQuestion already handled grouping and rendering
                
                document.getElementById('loading').style.display = 'none';
                setLoading(false);
            } catch (error) {
                console.error('Error in loadDataSource:', error);
                document.getElementById('loading').innerHTML = 
                    '<div class="error">Error loading data: ' + error.message + '</div>';
                setLoading(false);
            }
        }
        
        // Load dimension names from API
        async function loadDimensionNames() {
            if (!currentDataSourceId) return;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/data-sources/${currentDataSourceId}/dimension-names`, {
                    headers: getAuthHeaders()
                });
                if (response.ok) {
                    const dimensionNames = await response.json();
                    dimensionNamesMap = {};
                    dimensionNames.forEach(dn => {
                        dimensionNamesMap[dn.ref_key] = dn.custom_name;
                    });
                }
            } catch (error) {
                console.error('Error loading dimension names:', error);
            }
        }
        
        // Get display name for a dimension (custom name if available, otherwise formatted ref_key)
        function getDimensionDisplayName(refKey) {
            return dimensionNamesMap[refKey] || refKey.replace('ref_', 'Q');
        }
        
        // Detect survey format and setup question filter
        async function detectAndSetupQuestionFilter(savedState = null) {
            const questionSelect = document.getElementById('questionSelect');
            const dimensionNameEditor = document.getElementById('dimensionNameEditor');
            
            // Validate we have client and data source
            if (!currentClientId || !currentDataSourceId) {
                console.warn('No client or data source selected');
                questionSelect.style.display = 'none';
                document.getElementById('questionLabel').style.display = 'none';
                dimensionNameEditor.style.display = 'none';
                // Hide AI Insights tab when no data source
                if (window.AIInsightsPanel) {
                    window.AIInsightsPanel.setCurrentDimension('');
                }
                syncFilterTabState();
                return;
            }
            
            try {
                // Load questions from API
                const params = new URLSearchParams();
                params.append('client_uuid', currentClientId);
                params.append('data_source', currentDataSourceId);
                if (currentProjectName) {
                    params.append('project_name', currentProjectName);
                }
                
                const response = await fetch(`${API_BASE_URL}/api/voc/questions?${params.toString()}`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load questions');
                }
                
                const questions = await response.json();
                
                // Build dimension names map from API response first
                dimensionNamesMap = {};
                questions.forEach(q => {
                    if (q.dimension_name) {
                        dimensionNamesMap[q.dimension_ref] = q.dimension_name;
                    }
                });
                
                // Filter to only dimensions that have topics (response_count > 0)
                availableQuestions = questions
                    .filter(q => q.response_count > 0)
                    .map(q => q.dimension_ref);
                
                // Sort dimensions alphabetically by display name
                availableQuestions.sort((a, b) => {
                    const nameA = (getDimensionDisplayName(a) || '').toLowerCase();
                    const nameB = (getDimensionDisplayName(b) || '').toLowerCase();
                    return nameA.localeCompare(nameB);
                });
                
                console.log(`Found ${availableQuestions.length} dimensions with data`);
                
                if (availableQuestions.length === 0) {
                    // Hide question selector if no questions
                    questionSelect.style.display = 'none';
                    document.getElementById('questionLabel').style.display = 'none';
                    dimensionNameEditor.style.display = 'none';
                    // Hide AI Insights tab when no dimensions available
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension('');
                    }
                    syncFilterTabState();
                    return;
                }
                
                // Populate question selector
                questionSelect.innerHTML = '';
                availableQuestions.forEach(refKey => {
                    const option = document.createElement('option');
                    option.value = refKey;
                    option.textContent = getDimensionDisplayName(refKey);
                    questionSelect.appendChild(option);
                });
                
                // Add "All Dimensions" option at the bottom
                const allDimensionsOption = document.createElement('option');
                allDimensionsOption.value = '';
                allDimensionsOption.textContent = 'All Dimensions';
                questionSelect.appendChild(allDimensionsOption);
                
                // Show question selector
                questionSelect.style.display = 'inline';
                document.getElementById('questionLabel').style.display = 'inline';
                syncFilterTabState();
                
                // Add change listener
                questionSelect.onchange = function() {
                    const selectedRefKey = this.value;
                    const previousRefKey = currentQuestionRefKey; // Save old value before updating
                    currentQuestionRefKey = selectedRefKey;
                    saveState();
                    filterByQuestion(selectedRefKey, previousRefKey);
                    
                    // Update navigation links to include the new dimension
                    updateNavLinks();
                    
                    // Update AI Insights panel with current dimension (will show/hide tab)
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(selectedRefKey);
                    }
                    
                    // Show/hide dimension name editor based on selection
                    if (selectedRefKey && selectedRefKey !== '') {
                        dimensionNameEditor.style.display = 'none'; // Hidden for now
                    } else {
                        dimensionNameEditor.style.display = 'none';
                    }
                };
                
                // Setup inline dimension editor
                setupInlineDimensionEditor();
                
                // Restore saved question or default to first dimension
                let questionToSelect = null;
                if (savedState && savedState.questionRefKey !== undefined) {
                    // Allow empty string for "All Dimensions" or specific dimension
                    if (savedState.questionRefKey === '' || availableQuestions.includes(savedState.questionRefKey)) {
                        questionToSelect = savedState.questionRefKey;
                    }
                }
                // Default to first dimension if nothing was restored (but not if "All Dimensions" was explicitly saved)
                if (questionToSelect === null && availableQuestions.length > 0) {
                    questionToSelect = availableQuestions[0];
                }
                
                // Apply the selection (questionToSelect can be empty string for "All Dimensions" or a dimension ref)
                if (questionToSelect !== null) {
                    const previousRefKey = currentQuestionRefKey; // Save old value before updating
                    currentQuestionRefKey = questionToSelect;
                    questionSelect.value = questionToSelect;
                    filterByQuestion(questionToSelect, previousRefKey);
                    dimensionNameEditor.style.display = 'none';
                    // Update AI Insights panel with restored dimension
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(questionToSelect);
                    }
                }
                syncFilterTabState();
            } catch (error) {
                console.error('Error loading questions:', error);
                // Hide question selector on error
                questionSelect.style.display = 'none';
                document.getElementById('questionLabel').style.display = 'none';
                dimensionNameEditor.style.display = 'none';
                availableQuestions = [];
                // Hide AI Insights tab on error
                if (window.AIInsightsPanel) {
                    window.AIInsightsPanel.setCurrentDimension('');
                }
                syncFilterTabState();
            }
        }
        
        // Filter data by selected question
        // Helper functions to serialize/deserialize filter rules (Sets need special handling)
        function serializeFilterRules(rules) {
            return rules.map(rule => ({
                type: rule.type,
                mode: rule.mode,
                values: Array.from(rule.values), // Convert Set to Array
                metadataField: rule.metadataField
            }));
        }
        
        function deserializeFilterRules(serializedRules) {
            if (!serializedRules) return [];
            return serializedRules.map(rule => ({
                type: rule.type,
                mode: rule.mode,
                values: new Set(rule.values), // Convert Array back to Set
                metadataField: rule.metadataField
            }));
        }
        
        function saveFiltersForDimension(dimensionRef) {
            // Save current filters for the given dimension
            const key = dimensionRef || 'all';
            dimensionFilters[key] = serializeFilterRules(filterRules);
            console.log(`Saved filters for dimension ${key}:`, dimensionFilters[key]);
        }
        
        function loadFiltersForDimension(dimensionRef) {
            // Load saved filters for the given dimension, or return empty array
            const key = dimensionRef || 'all';
            const savedFilters = dimensionFilters[key];
            if (savedFilters) {
                filterRules = deserializeFilterRules(savedFilters);
                console.log(`Loaded filters for dimension ${key}:`, filterRules);
            } else {
                filterRules = [];
                console.log(`No saved filters for dimension ${key}, using empty filters`);
            }
        }
        
        function filterByQuestion(refKey, previousRefKey = null) {
            // Save current filters for the previous dimension before switching
            // Use previousRefKey if provided (from onchange handler), otherwise use currentQuestionRefKey
            const oldRefKey = previousRefKey !== null ? previousRefKey : currentQuestionRefKey;
            if (oldRefKey !== null) {
                saveFiltersForDimension(oldRefKey);
            } else if (oldRefKey === null && refKey !== null && refKey !== '') {
                // Switching from "all dimensions" to a specific dimension
                saveFiltersForDimension(null);
            }
            
            // Group process_voc rows with optional dimension filter
            const groupedData = groupProcessVocRows(fullRawData, refKey || null);
            
            // Set rawData to the grouped and filtered data
            rawData = groupedData;
            dimensionFilteredData = groupedData; // Keep grouped data for re-filtering (has text field)
            
            console.log(`Filtered to ${rawData.length} grouped rows for question: ${refKey || 'all'}`);
            
            // Extract available filter options from the filtered data (dimension-specific)
            extractAvailableFilterOptions(rawData);
            
            // Load saved filters for the new dimension (or empty if none)
            loadFiltersForDimension(refKey || null);
            
            updateFilterUI();
            
            // Update breadcrumb to show question selection
            updateBreadcrumb(refKey);
            
            // Update treemap title with question text if available
            updateTreemapTitle();
            
            // Re-render visualizations (this will apply the restored filters)
            applyFiltersAndRender();
        }
        
        // Initialize
        async function init() {
            // Prevent multiple simultaneous initializations
            if (isInitializing) {
                console.log('init() already in progress, skipping...');
                return;
            }
            isInitializing = true;
            console.log('init() called');
            try {
                console.log('Loading dimension options...');
                // Load dimension options from localStorage
                loadDimensionOptions();
                
                console.log('Setting up container dimensions...');
                // Set dimensions based on container
                // Only set dimensions if container is visible, otherwise wait for view switch
                const container = document.querySelector('.treemap-svg-container');
                const vizSection = document.getElementById('visualizations-section');
                const isVizSectionVisible = vizSection && (vizSection.classList.contains('active') || vizSection.style.display !== 'none');
                
                if (container && isVizSectionVisible) {
                    width = container.clientWidth;
                    height = container.clientHeight;
                    console.log('Container dimensions set:', { width, height });
                } else {
                    // Container is hidden, use defaults but they'll be recalculated when section becomes visible
                    console.log('Container is hidden, using default dimensions (will recalculate when visible)');
                    width = 800;
                    height = 600;
                }
                
                console.log('Loading clients...');
                // Load clients from API (which will cascade to sources and data)
                await loadClients();
                
                // Setup advanced filter UI
                setupFilterUI();
                
                // Initialize favourites section
                renderFavourites();
            } catch (error) {
                document.getElementById('loading').innerHTML = 
                    '<div class="error">Error initializing: ' + error.message + '</div>';
            } finally {
                isInitializing = false;
            }
        }

        // Advanced Multi-Filter Functions
        function extractAvailableFilterOptions(data) {
            const categories = new Set();
            const topics = new Set();
            const metadataFields = {}; // Map of fieldName -> Set of values
            
            data.forEach(row => {
                if (row && row.topics) {
                    row.topics.forEach(topic => {
                        if (topic && topic.category) {
                            categories.add(topic.category);
                        }
                        if (topic && topic.label) {
                            topics.add(topic.label);
                        }
                    });
                }
                if (row && row.metadata) {
                    // Extract all metadata fields as-is from raw metadata (no computation, no mapping)
                    Object.keys(row.metadata).forEach(key => {
                        if (!metadataFields[key]) {
                            metadataFields[key] = new Set();
                        }
                        const value = row.metadata[key];
                        if (value !== null && value !== undefined) {
                            // Convert to string for consistency (including empty strings)
                            const strValue = String(value);
                            // Always add trimmed value (including empty string if original was empty)
                            const trimmedValue = strValue.trim();
                            metadataFields[key].add(trimmedValue);
                        }
                    });
                }
                // Also check row-level sentiment (in case it's not in metadata)
                if (row && row.sentiment) {
                    if (!metadataFields['sentiment']) {
                        metadataFields['sentiment'] = new Set();
                    }
                    metadataFields['sentiment'].add(row.sentiment);
                }
            });
            
            availableCategories = Array.from(categories).sort();
            availableTopics = Array.from(topics).sort();
            availableLocations = []; // No longer computed, kept for backwards compatibility
            
            // Convert metadata field Sets to sorted arrays
            // Exclude sentiment and dimension_name from metadata fields (sentiment is top-level, dimension_name removed)
            availableMetadataFields = {};
            let sentimentValues = [];
            Object.keys(metadataFields).forEach(key => {
                // Skip dimension_name (removed from UI)
                if (key === 'dimension_name') return;
                
                // Store sentiment separately for top-level filter
                if (key === 'sentiment') {
                    sentimentValues = Array.from(metadataFields[key]).sort();
                } else {
                    // All other metadata fields go into availableMetadataFields
                    availableMetadataFields[key] = Array.from(metadataFields[key]).sort();
                }
            });
            
            // Populate filter type list dynamically after extracting options
            populateFilterTypeList(sentimentValues);
        }
        
        function populateFilterTypeList(sentimentValues = []) {
            const filterTypeList = document.getElementById('filterTypeList');
            if (!filterTypeList) return;
            
            filterTypeList.innerHTML = '';
            
            // Always show Category and Topic
            const staticFilters = [
                {
                    type: 'category',
                    label: 'Category',
                    description: 'Filter by conversation categories'
                },
                {
                    type: 'topic',
                    label: 'Topic',
                    description: 'Filter by specific topics'
                }
            ];
            
            // Add Sentiment as top-level filter if available
            if (sentimentValues && sentimentValues.length > 0) {
                staticFilters.push({
                    type: 'sentiment',
                    label: 'Sentiment',
                    description: 'Filter by sentiment (positive, negative, neutral)'
                });
                // Store sentiment values in availableMetadataFields for getAvailableItemsForType
                availableMetadataFields['sentiment'] = sentimentValues;
            }
            
            // Add Metadata as a top-level option that opens the metadata field selection view
            const metadataFieldCount = Object.keys(availableMetadataFields)
                .filter(key => key !== 'sentiment' && key !== 'dimension_name')
                .length;
            
            if (metadataFieldCount > 0) {
                staticFilters.push({
                    type: 'metadata',
                    label: 'Metadata',
                    description: `Filter by ${metadataFieldCount} metadata field${metadataFieldCount !== 1 ? 's' : ''}`
                });
            }
            
            // Create filter type options (only top-level: Category, Topic, Sentiment, Metadata)
            staticFilters.forEach(filter => {
                const option = document.createElement('div');
                option.className = 'filter-type-option';
                option.dataset.type = filter.type;
                option.style.cssText = 'padding: 12px; margin: 4px 0; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; transition: background 0.2s;';
                option.onmouseover = () => option.style.background = '#f5f5f5';
                option.onmouseout = () => option.style.background = 'transparent';
                option.onclick = () => {
                    currentFilterType = filter.type;
                    currentFilterSelections.clear();
                    if (filter.type === 'metadata') {
                        // Metadata opens the metadata field selection view (second level)
                        currentMetadataField = null;
                        showMetadataFieldView();
                    } else {
                        // Category, Topic, or Sentiment - go directly to value selection
                        currentMetadataField = null;
                        showFilterSelectionView();
                    }
                };
                
                option.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 14px; color: #333;">${filter.label}</strong>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${filter.description}</div>
                        </div>
                        <span style="font-size: 18px;"></span>
                    </div>
                `;
                
                filterTypeList.appendChild(option);
            });
        }

        function applyFiltersAndRender() {
            let filteredData = dimensionFilteredData;
            
            // Debug: Check if dimensionFilteredData is empty
            if (!dimensionFilteredData || dimensionFilteredData.length === 0) {
                console.warn('dimensionFilteredData is empty! Cannot apply filters.');
                return;
            }
            
            console.log(`Applying filters to ${dimensionFilteredData.length} rows`);
            
            // Apply all filter rules - all rules must pass (AND logic)
            if (filterRules.length > 0) {
                filterRules.forEach((r, idx) => {
                    console.log(`Filter rule ${idx + 1}:`, {
                        type: r.type,
                        mode: r.mode,
                        metadataField: r.metadataField,
                        values: Array.from(r.values),
                        valuesCount: r.values.size,
                        fullRule: r
                    });
                });
                
                // Log sample of first row to see what metadata looks like
                if (filteredData.length > 0) {
                    console.log('Sample row metadata:', JSON.stringify(filteredData[0].metadata, null, 2));
                }
                
                // Reset debug flags for all rules
                filterRules.forEach(rule => {
                    rule._debugLogged = false;
                });
                let firstRowLogged = false;
                
                filteredData = filteredData.filter(row => {
                    if (!row) return false;
                    
                    // Check each rule - all must pass
                    const ruleResults = filterRules.map(rule => {
                        if (rule.values.size === 0) return { rule, passed: true, reason: 'empty values' }; // Skip empty rules
                        
                        let matches = false;
                        let matchDetails = '';
                        
                        if (rule.type === 'category') {
                            // Check if row has any topics matching the category filter
                            if (row.topics && row.topics.length > 0) {
                                matches = row.topics.some(topic => 
                                    topic && topic.category && rule.values.has(topic.category)
                                );
                            }
                        } else if (rule.type === 'topic') {
                            // Check if row has any topics matching the topic filter
                            if (row.topics && row.topics.length > 0) {
                                matches = row.topics.some(topic => 
                                    topic && topic.label && rule.values.has(topic.label)
                                );
                            }
                        } else if (rule.type === 'sentiment') {
                            // Check sentiment from metadata or row-level sentiment
                            const sentiment = row.metadata?.sentiment || row.sentiment || 'neutral';
                            matches = rule.values.has(sentiment);
                        } else if (rule.type === 'location') {
                            // Location filtering is now handled via metadata field filters
                            // This is kept for backwards compatibility but should use metadata type instead
                            matches = false; // Legacy location type - use metadata filters instead
                        } else if (rule.type === 'metadata' && rule.metadataField) {
                            // Get metadata field value directly from metadata
                            const fieldValue = row.metadata?.[rule.metadataField];
                            
                            if (fieldValue !== null && fieldValue !== undefined && fieldValue !== '') {
                                // Convert to string and trim for comparison
                                const strValue = String(fieldValue).trim();
                                matches = rule.values.has(strValue);
                                
                                // Debug logging for first mismatch
                                if (!matches && rule.mode === 'include' && !rule._debugLogged) {
                                    // Log first mismatch to help debug
                                    console.log(` Metadata filter mismatch: field="${rule.metadataField}"`);
                                    console.log(`   Filter values (${rule.values.size}):`, Array.from(rule.values));
                                    console.log(`   Row value: "${strValue}" (type: ${typeof fieldValue})`);
                                    console.log(`   Full row metadata:`, JSON.stringify(row.metadata, null, 2));
                                    
                                    // Check if any filter value is close to the row value
                                    const filterValuesArray = Array.from(rule.values);
                                    const similarValues = filterValuesArray.filter(fv => {
                                        const fvStr = String(fv).trim();
                                        return fvStr.toLowerCase() === strValue.toLowerCase() || 
                                               fvStr === strValue ||
                                               fvStr.includes(strValue) ||
                                               strValue.includes(fvStr);
                                    });
                                    if (similarValues.length > 0) {
                                        console.log(`    Similar values found:`, similarValues);
                                    }
                                    rule._debugLogged = true;
                                }
                            } else {
                                // If field is null/undefined, check if empty string is in the filter values
                                matches = rule.values.has('');
                            }
                        }
                        
                        // Apply include/exclude logic
                        const passed = rule.mode === 'include' ? matches : !matches;
                        
                        if (!passed && !rule._debugLogged) {
                            console.log(` Filter rule failed:`, {
                                type: rule.type,
                                mode: rule.mode,
                                metadataField: rule.metadataField,
                                matches: matches,
                                details: matchDetails
                            });
                            rule._debugLogged = true;
                        }
                        
                        return { rule, passed, matches, matchDetails };
                    });
                    
                    // Log all rule results for first row
                    if (!firstRowLogged) {
                        console.log('Rule results for first row:', ruleResults);
                        firstRowLogged = true;
                    }
                    
                    // Check if all rules passed
                    const allPassed = ruleResults.every(r => r.passed);
                    return allPassed;
                }).map(row => {
                    // Ensure we preserve all row properties including text
                    if (!row) return null;
                    
                    // Filter topics within rows based on category and topic rules
                    if (row.topics && row.topics.length > 0) {
                        const filteredTopics = row.topics.filter(topic => {
                            // Check if this topic passes all category and topic filters
                            return filterRules.every(rule => {
                                if (rule.values.size === 0) return true;
                                
                                if (rule.type === 'category') {
                                    const matches = topic && topic.category && rule.values.has(topic.category);
                                    return rule.mode === 'include' ? matches : !matches;
                                } else if (rule.type === 'topic') {
                                    const matches = topic && topic.label && rule.values.has(topic.label);
                                    return rule.mode === 'include' ? matches : !matches;
                                }
                                return true; // Location filters don't affect individual topics
                            });
                        });
                        
                        if (filteredTopics.length === 0) return null;
                        
                        // Preserve all original row properties
                        return {
                            ...row,
                            text: row.text || '', // Explicitly preserve text
                            topics: filteredTopics
                        };
                    }
                    // If row has no topics, preserve it as-is (for location-only filters)
                    return {
                        ...row,
                        text: row.text || '' // Explicitly preserve text
                    };
                }).filter(row => row !== null);
            }
            
            rawData = filteredData;
            
            console.log(`After filtering: ${filteredData.length} rows`);
            
            if (filteredData.length === 0) {
                console.warn('No data remaining after applying filters!');
                // Still try to render to show empty state
            }
            
            // Re-process and render
            processData();
            renderTreemap(hierarchyData);
            renderBarChart();
            renderTopicsChart();
            
            // Update available options from unfiltered data so excluded items remain visible
            // Use dimensionFilteredData (unfiltered by category/topic/metadata) instead of rawData (filtered)
            extractAvailableFilterOptions(dimensionFilteredData);
            updateFilterUI();
        }
        
        let currentFilterType = null;
        let currentFilterSelections = new Set();
        let currentFilterSearchTerm = '';
        
        // Set up Add button handler (extracted to function so it can be called independently)
        function setupAddButton() {
            const addDataBtn = document.getElementById('addDataBtn');
            if (addDataBtn) {
                // Remove existing listeners to avoid duplicates
                const newBtn = addDataBtn.cloneNode(true);
                addDataBtn.parentNode.replaceChild(newBtn, addDataBtn);
                
                newBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (currentClientId) {
                        // Save full visualization state before navigating
                        saveState();
                        // Also save to a separate key for navigation return
                        try {
                            const navState = {
                                client_uuid: currentClientId,
                                clientId: currentClientId,
                                projectName: currentProjectName,
                                dataSourceId: currentDataSourceId,
                                questionRefKey: currentQuestionRefKey,
                                returnUrl: '/choose-data-source.html',
                                timestamp: Date.now()
                            };
                            localStorage.setItem('vizualizd_nav_state', JSON.stringify(navState));
                        } catch (error) {
                            console.error('Error saving navigation state:', error);
                        }
                        window.location.href = `/choose-data-source.html?client_uuid=${currentClientId}`;
                    } else {
                        alert('Please select a client first');
                    }
                });
                
                // Update button visibility
                updateAddDataButton();
            }
        }
        
        // Update Add button visibility and href
        function updateAddDataButton() {
            const addDataBtn = document.getElementById('addDataBtn');
            if (addDataBtn) {
                if (currentClientId) {
                    addDataBtn.href = `/choose-data-source.html?client_uuid=${currentClientId}`;
                    // addDataBtn.style.display = 'inline-block'; // Hidden for now
                }
                // Always hide the button for now
                addDataBtn.style.display = 'none';
            }
        }
        
        // Flag to track if filter UI is already set up
        let filterUISetup = false;
        
        function setupFilterUI() {
            // Prevent duplicate setup
            if (filterUISetup) {
                return;
            }
            filterUISetup = true;
            
            const filterBtn = document.getElementById('filterBtn');
            const filterDropdown = document.getElementById('filterDropdown');
            const filterTypeView = document.getElementById('filterTypeView');
            const filterSelectionView = document.getElementById('filterSelectionView');
            const backToFilterType = document.getElementById('backToFilterType');
            const clearAllFilters = document.getElementById('clearAllFilters');
            const applyFilter = document.getElementById('applyFilter');
            const selectAllItems = document.getElementById('selectAllItems');
            const clearAllItems = document.getElementById('clearAllItems');
            const filterSelectionSearch = document.getElementById('filterSelectionSearch');
            
            if (!filterBtn || !filterDropdown) {
                console.warn('Filter UI elements not found');
                filterUISetup = false; // Reset flag if elements not found
                return;
            }
            
            if (filterSelectionSearch) {
                filterSelectionSearch.addEventListener('input', (event) => {
                    currentFilterSearchTerm = event.target.value || '';
                    populateFilterSelectionList();
                    updateFilterSelectionSearchClearButton();
                });
            }
            
            // Toggle dropdown
            filterBtn.onclick = (e) => {
                e.stopPropagation();
                const isVisible = filterDropdown.style.display !== 'none';
                filterDropdown.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    updateFilterUI();
                }
            };
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!filterBtn.contains(e.target) && !filterDropdown.contains(e.target)) {
                    filterDropdown.style.display = 'none';
                }
            });
            
            // Filter type selection is now handled dynamically in populateFilterTypeList()
            // This code is kept for backwards compatibility but will be overridden by dynamic handlers
            
            // Back from metadata field view
            const backFromMetadataField = document.getElementById('backFromMetadataField');
            backFromMetadataField.onclick = () => {
                showFilterTypeView();
            };
            
            // Back button (handles both metadata field view and filter type view)
            backToFilterType.onclick = () => {
                if (currentFilterType === 'metadata' && currentMetadataField) {
                    // If we're in metadata value selection, go back to field selection
                    showMetadataFieldView();
                } else {
                    // Otherwise go back to filter type selection
                    showFilterTypeView();
                }
            };
            
            // Clear all filters
            clearAllFilters.onclick = () => {
                filterRules = [];
                // Save cleared filters for current dimension
                saveFiltersForDimension(currentQuestionRefKey);
                applyFiltersAndRender();
                updateFilterUI();
            };
            
            // Apply filter button
            applyFilter.onclick = () => {
                const mode = document.querySelector('input[name="filterMode"]:checked').value;
                
                // For include mode, require at least one selection
                // For exclude mode, 0 selections means "exclude nothing" (remove exclusion filter)
                if (mode === 'include' && currentFilterSelections.size === 0) {
                    alert('Please select at least one item to filter by.');
                    return;
                }
                
                // Validate metadata field is set for metadata filters
                if (currentFilterType === 'metadata' && !currentMetadataField) {
                    alert('Please select a metadata field first.');
                    return;
                }
                
                // If in exclude mode with 0 selections, remove the filter rule entirely
                if (mode === 'exclude' && currentFilterSelections.size === 0) {
                    if (currentFilterType === 'metadata' && currentMetadataField) {
                        // Remove metadata filter rule
                        const existingRuleIndex = filterRules.findIndex(r => 
                            r.type === 'metadata' && r.metadataField === currentMetadataField
                        );
                        if (existingRuleIndex >= 0) {
                            filterRules.splice(existingRuleIndex, 1);
                        }
                    } else {
                        // Remove filter rule for this type
                        const existingRuleIndex = filterRules.findIndex(r => r.type === currentFilterType);
                        if (existingRuleIndex >= 0) {
                            filterRules.splice(existingRuleIndex, 1);
                        }
                    }
                } else {
                    // Add or update filter rule for this type
                    if (currentFilterType === 'metadata' && currentMetadataField) {
                        // For metadata filters, check by metadataField
                        const existingRuleIndex = filterRules.findIndex(r => 
                            r.type === 'metadata' && r.metadataField === currentMetadataField
                        );
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            filterRules[existingRuleIndex].mode = mode;
                            filterRules[existingRuleIndex].values = new Set(currentFilterSelections);
                        } else {
                            // Add new rule
                            filterRules.push({
                                type: 'metadata',
                                mode: mode,
                                values: new Set(currentFilterSelections),
                                metadataField: currentMetadataField
                            });
                        }
                    } else {
                        // For other filter types (category, topic, sentiment)
                        const existingRuleIndex = filterRules.findIndex(r => r.type === currentFilterType);
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            filterRules[existingRuleIndex].mode = mode;
                            filterRules[existingRuleIndex].values = new Set(currentFilterSelections);
                        } else {
                            // Add new rule
                            filterRules.push({
                                type: currentFilterType,
                                mode: mode,
                                values: new Set(currentFilterSelections)
                            });
                        }
                    }
                }
                
                // Save filters for current dimension after applying
                saveFiltersForDimension(currentQuestionRefKey);
                
                // Stay in the filter selection view instead of going back to top level
                // Refresh the view to show updated selections
                showFilterSelectionView();
                applyFiltersAndRender();
            };
            
            // Select all items
            selectAllItems.onclick = () => {
                const items = getVisibleFilterItems();
                if (items.length === 0) return;
                items.forEach(item => currentFilterSelections.add(item));
                populateFilterSelectionList();
            };
            
            // Clear all items
            clearAllItems.onclick = () => {
                currentFilterSelections.clear();
                populateFilterSelectionList();
            };
        }
        
        function showFilterTypeView() {
            document.getElementById('filterTypeView').style.display = 'block';
            document.getElementById('filterSelectionView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'none';
            currentFilterType = null;
            currentFilterSelections.clear();
            currentMetadataField = null;
            resetFilterSelectionSearch();
            updateFilterUI(); // Refresh the active filters list
        }
        
        function showMetadataFieldView() {
            document.getElementById('filterTypeView').style.display = 'none';
            document.getElementById('filterSelectionView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'block';
            resetFilterSelectionSearch();
            currentFilterSelections.clear();
            populateMetadataFieldList();
        }
        
        function showFilterSelectionView() {
            console.log('=== showFilterSelectionView() called ===');
            console.log('currentFilterType:', currentFilterType);
            console.log('currentMetadataField:', currentMetadataField);
            
            document.getElementById('filterTypeView').style.display = 'none';
            document.getElementById('metadataFieldView').style.display = 'none';
            document.getElementById('filterSelectionView').style.display = 'block';
            
            const title = document.getElementById('filterSelectionTitle');
            const searchInput = document.getElementById('filterSelectionSearch');
            if (searchInput && searchInput.value !== currentFilterSearchTerm) {
                searchInput.value = currentFilterSearchTerm;
            }

            if (currentFilterType === 'metadata' && currentMetadataField) {
                // Format field name nicely (e.g., "user_type" -> "User Type")
                const fieldLabel = currentMetadataField
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                title.textContent = `Select ${fieldLabel} Values`;
            } else {
                const typeLabels = {
                    'category': 'Categories',
                    'topic': 'Topics',
                    'sentiment': 'Sentiment',
                    'location': 'Locations' // Kept for backwards compatibility
                };
                title.textContent = `Select ${typeLabels[currentFilterType] || 'Items'}`;
            }
            
            // Validate that metadataField is set for metadata filters
            if (currentFilterType === 'metadata' && !currentMetadataField) {
                console.error('currentMetadataField is not set for metadata filter!');
                // Try to recover by going back to field selection
                showMetadataFieldView();
                return;
            }
            
            // Load existing selections if there's a rule for this type/field
            let existingRule;
            if (currentFilterType === 'metadata' && currentMetadataField) {
                existingRule = filterRules.find(r => 
                    r.type === 'metadata' && r.metadataField === currentMetadataField
                );
            } else {
                existingRule = filterRules.find(r => r.type === currentFilterType);
            }
            
            if (existingRule) {
                console.log('Found existing rule:', {
                    type: existingRule.type,
                    mode: existingRule.mode,
                    values: Array.from(existingRule.values)
                });
                currentFilterSelections = new Set(existingRule.values);
                console.log('Set currentFilterSelections to:', Array.from(currentFilterSelections));
                // Set the mode radio button
                const modeInput = document.querySelector(`input[name="filterMode"][value="${existingRule.mode}"]`);
                if (modeInput) {
                    modeInput.checked = true;
                    console.log('Set mode radio to:', existingRule.mode);
                } else {
                    console.warn('Mode radio input not found for value:', existingRule.mode);
                }
            } else {
                console.log('No existing rule found for type:', currentFilterType);
                currentFilterSelections.clear();
                document.querySelector('input[name="filterMode"][value="include"]').checked = true;
                // When mode is "include" and no existing rule, select all items by default
                const mode = document.querySelector('input[name="filterMode"]:checked')?.value || 'include';
                if (mode === 'include') {
                    const items = getAvailableItemsForType(currentFilterType);
                    currentFilterSelections = new Set(items);
                    console.log('Set currentFilterSelections to all items:', Array.from(currentFilterSelections));
                }
            }
            
            // Add event listeners for mode changes
            const modeInputs = document.querySelectorAll('input[name="filterMode"]');
            modeInputs.forEach(input => {
                // Remove existing listeners to avoid duplicates
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
                
                newInput.addEventListener('change', () => {
                    if (newInput.value === 'include') {
                        // When switching to include mode, select all items by default
                        const items = getAvailableItemsForType(currentFilterType);
                        currentFilterSelections = new Set(items);
                        populateFilterSelectionList();
                    } else {
                        // When switching to exclude mode, clear selections
                        currentFilterSelections.clear();
                        populateFilterSelectionList();
                    }
                });
            });
            
            console.log('About to populate filter selection list with currentFilterSelections:', Array.from(currentFilterSelections));
            populateFilterSelectionList();
            updateFilterSelectionSearchClearButton();
            console.log('=== showFilterSelectionView() completed ===');
        }
        
        function getAvailableItemsForType(type) {
            console.log('getAvailableItemsForType called with type:', type);
            let items;
            if (type === 'category') {
                items = availableCategories;
                console.log('availableCategories:', items);
            } else if (type === 'topic') {
                items = availableTopics;
                console.log('availableTopics:', items);
            } else if (type === 'sentiment') {
                items = availableMetadataFields['sentiment'] || [];
                console.log('availableSentiment:', items);
            } else if (type === 'location') {
                items = availableLocations; // Kept for backwards compatibility
                console.log('availableLocations:', items);
            } else if (type === 'metadata' && currentMetadataField) {
                items = availableMetadataFields[currentMetadataField] || [];
                console.log('availableMetadata for', currentMetadataField, ':', items);
            } else {
                items = [];
                console.log('No items found for type:', type);
            }
            console.log('Returning items:', items);
            return items;
        }
        
        function populateMetadataFieldList() {
            const fieldList = document.getElementById('metadataFieldList');
            fieldList.innerHTML = '';
            
            // Get all metadata fields, excluding sentiment (top-level) and dimension_name (removed)
            const fields = Object.keys(availableMetadataFields)
                .filter(key => key !== 'sentiment' && key !== 'dimension_name')
                .sort();
            
            if (fields.length === 0) {
                fieldList.innerHTML = '<div style="padding: 12px; color: #999; text-align: center;">No metadata fields found</div>';
                return;
            }
            
            fields.forEach(fieldName => {
                const values = availableMetadataFields[fieldName];
                const valueCount = values.length;
                
                // Format field name nicely (e.g., "user_type" -> "User Type")
                const fieldLabel = fieldName
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                
                const fieldItem = document.createElement('div');
                fieldItem.style.cssText = 'padding: 12px; margin: 4px 0; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; transition: background 0.2s;';
                fieldItem.onmouseover = () => fieldItem.style.background = '#f5f5f5';
                fieldItem.onmouseout = () => fieldItem.style.background = 'transparent';
                fieldItem.onclick = () => {
                    currentMetadataField = fieldName;
                    resetFilterSelectionSearch();
                    showFilterSelectionView();
                };
                
                fieldItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 14px; color: #333;">${fieldLabel}</strong>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${valueCount} ${valueCount === 1 ? 'value' : 'values'} available</div>
                        </div>
                        <span style="font-size: 18px;"></span>
                    </div>
                `;
                
                fieldList.appendChild(fieldItem);
            });
        }
        
        function getVisibleFilterItems() {
            const items = getAvailableItemsForType(currentFilterType) || [];
            if (!items || items.length === 0) return [];
            
            const searchTerm = currentFilterSearchTerm ? currentFilterSearchTerm.trim().toLowerCase() : '';
            if (!searchTerm) return items;
            
            return items.filter(item => {
                if (item === null || item === undefined) return false;
                return String(item).toLowerCase().includes(searchTerm);
            });
        }
        
        function populateFilterSelectionList() {
            console.log('=== populateFilterSelectionList() called ===');
            console.log('currentFilterType:', currentFilterType);
            console.log('currentFilterSelections:', Array.from(currentFilterSelections || []));
            
            const filterList = document.getElementById('filterSelectionList');
            if (!filterList) {
                console.error('filterSelectionList element not found!');
                return;
            }
            filterList.innerHTML = '';
            
            const items = getVisibleFilterItems();
            console.log('Visible items:', items);
            console.log('Number of visible items:', items.length);
            
            if (items.length === 0) {
                const message = currentFilterSearchTerm && currentFilterSearchTerm.trim().length > 0
                    ? 'No items match your search'
                    : 'No items found';
                filterList.innerHTML = `<div style="padding: 12px; color: #999; text-align: center;">${message}</div>`;
                console.log('No items to display');
                return;
            }
            
            let checkedCount = 0;
            items.forEach(item => {
                const isChecked = currentFilterSelections.has(item);
                if (isChecked) checkedCount++;
                
                console.log(`Item: "${item}", isChecked: ${isChecked}`);
                
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; padding: 8px 12px; cursor: pointer; border-radius: 4px; transition: background 0.2s;';
                label.onmouseover = () => label.style.background = '#f5f5f5';
                label.onmouseout = () => label.style.background = 'transparent';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        currentFilterSelections.add(item);
                    } else {
                        currentFilterSelections.delete(item);
                    }
                };
                
                const text = document.createElement('span');
                text.textContent = item;
                text.style.cssText = 'font-size: 13px; flex: 1;';
                
                label.appendChild(checkbox);
                label.appendChild(text);
                filterList.appendChild(label);
            });
            console.log(`Total items: ${items.length}, Checked items: ${checkedCount}`);
            console.log('=== populateFilterSelectionList() completed ===');
        }
        
        function updateFilterUI() {
            console.log('=== updateFilterUI() called ===');
            console.log('Current filterRules:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                type: r.type,
                mode: r.mode,
                values: Array.from(r.values)
            })))));
            console.log('filterRules.length:', filterRules.length);
            
            // Update active filters list
            const activeFiltersList = document.getElementById('activeFiltersList');
            activeFiltersList.innerHTML = '';
            
            if (filterRules.length === 0) {
                activeFiltersList.innerHTML = '<div style="padding: 8px; color: #999; text-align: center; font-size: 12px;">No active filters</div>';
            } else {
                filterRules.forEach((rule, index) => {
                    const filterItem = document.createElement('div');
                    filterItem.style.cssText = 'padding: 8px 12px; margin: 4px 0; background: white; border: 1px solid #e0e0e0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;';
                    
                    let typeLabel;
                    if (rule.type === 'metadata' && rule.metadataField) {
                        // Format metadata field name nicely
                        const fieldLabel = rule.metadataField
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        typeLabel = `Metadata: ${fieldLabel}`;
                    } else {
                        const typeLabels = {
                            'category': 'Category',
                            'topic': 'Topic',
                            'sentiment': 'Sentiment',
                            'location': 'Location' // Kept for backwards compatibility
                        };
                        typeLabel = typeLabels[rule.type] || rule.type;
                    }
                    
                    const modeLabel = rule.mode === 'include' ? 'Include' : 'Exclude';
                    const count = rule.values.size;
                    const itemsPreview = Array.from(rule.values).slice(0, 2).join(', ');
                    const moreText = count > 2 ? ` +${count - 2} more` : '';
                    
                    filterItem.innerHTML = `
                        <div style="flex: 1;">
                            <div style="font-size: 12px; font-weight: 600; color: #333;">${typeLabel} (${modeLabel})</div>
                            <div style="font-size: 11px; color: #666; margin-top: 2px;">${itemsPreview}${moreText}</div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button class="edit-filter-btn" data-index="${index}" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Edit</button>
                            <button class="remove-filter-btn" data-index="${index}" style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                        </div>
                    `;
                    
                    const editBtn = filterItem.querySelector('.edit-filter-btn');
                    editBtn.onclick = () => {
                        currentFilterType = rule.type;
                        resetFilterSelectionSearch();
                        if (rule.type === 'metadata' && rule.metadataField) {
                            currentMetadataField = rule.metadataField;
                            showFilterSelectionView();
                        } else if (rule.type === 'sentiment' || rule.type === 'category' || rule.type === 'topic') {
                            // Top-level filters (sentiment, category, topic) - go directly to value selection
                            currentMetadataField = null;
                            showFilterSelectionView();
                        } else {
                            showFilterSelectionView();
                        }
                    };
                    
                    const removeBtn = filterItem.querySelector('.remove-filter-btn');
                    removeBtn.onclick = () => {
                        filterRules.splice(index, 1);
                        // Save updated filters for current dimension
                        saveFiltersForDimension(currentQuestionRefKey);
                        applyFiltersAndRender();
                    };
                    
                    activeFiltersList.appendChild(filterItem);
                });
            }
            
            // Update badge - show total count of items across all filter rules
            const badge = document.getElementById('filterBadge');
            console.log('Badge element:', badge);
            if (filterRules.length === 0) {
                if (badge) {
                    badge.style.display = 'none';
                    console.log('Badge hidden (no filters)');
                }
            } else {
                if (badge) {
                    // Calculate total number of items across all filter rules
                    const totalItems = filterRules.reduce((sum, rule) => sum + rule.values.size, 0);
                    badge.style.display = 'flex';
                    badge.textContent = totalItems;
                    console.log('Badge updated to:', totalItems, 'Badge textContent:', badge.textContent, 'filterRules.length:', filterRules.length);
                    // Force a reflow to ensure the DOM updates
                    void badge.offsetWidth;
                } else {
                    console.error('Badge element not found!');
                }
            }
            console.log('=== updateFilterUI() completed ===');
        }

        // Process raw data into hierarchy
        // Now works with normalized data format
        function processData() {
            const categoryMap = new Map();
            
            console.log(`Processing ${rawData.length} rows...`);
            let rowsWithTopics = 0;
            let topicsFound = 0;

            rawData.forEach(row => {
                // Skip null/undefined rows or rows with no topics
                if (!row || !row.topics || row.topics.length === 0) {
                    if (rawData.length > 0 && rawData.length <= 10) {
                        // Log for small datasets to help debug
                        console.log(`Skipping row ${row?.row_id || 'unknown'}: hasTopics=${!!row?.topics}, topicsLength=${row?.topics?.length || 0}`);
                    }
                    return;
                }
                
                // Normalized format: {row_id, text, topics[], sentiment, metadata{}}
                const topics = row.topics;
                const rowDimensionRef = row.dimension_ref || row.metadata?.ref_key;
                
                rowsWithTopics++;
                
                topics.forEach(topic => {
                    if (!topic || !topic.category) return;
                    topicsFound++;

                    // When "All Dimensions" is selected, only add verbatim to topic if dimensions match
                    // This prevents verbatims from one dimension being added to topics from another dimension
                    if (rowDimensionRef && topic._dimension_ref && topic._dimension_ref !== rowDimensionRef) {
                        return; // Skip this topic - it's from a different dimension
                    }

                    // Get or create category
                    if (!categoryMap.has(topic.category)) {
                        categoryMap.set(topic.category, {
                            name: topic.category,
                            children: new Map()
                        });
                    }

                    const category = categoryMap.get(topic.category);

                    // Get or create topic
                    if (!category.children.has(topic.label)) {
                        category.children.set(topic.label, {
                            name: topic.label,
                            code: topic.code,
                            verbatims: []
                        });
                    }

                    // Add verbatim - include all metadata fields dynamically
                    const topicData = category.children.get(topic.label);
                    topicData.verbatims.push({
                        text: row.text || '',
                        sentiment: row.sentiment || 'neutral',
                        index: row.row_id,
                        // Preserve commonly used fields for backward compatibility
                        country: row.metadata?.country || '',
                        city: row.metadata?.city || '',
                        date: row.metadata?.created_at || '',
                        source_type: row.metadata?.source_type || 'unknown',
                        // Include all other metadata fields
                        ...(row.metadata || {})
                    });
                });
            });

            // Convert to D3 hierarchy format
            hierarchyData = {
                name: 'Root',
                children: Array.from(categoryMap.values()).map(cat => ({
                    name: cat.name,
                    children: Array.from(cat.children.values()).map(topic => ({
                        name: topic.name,
                        code: topic.code,
                        value: topic.verbatims.length,
                        verbatims: topic.verbatims
                    }))
                }))
            };
            
            console.log(`Found ${rowsWithTopics} rows with topics, ${topicsFound} total topics`);
            console.log(`Categories: ${categoryMap.size}, Hierarchy children: ${hierarchyData.children.length}`);
            
            // Log a sample row for debugging
            if (rawData.length > 0) {
                console.log('Sample row:', JSON.stringify(rawData[0], null, 2).substring(0, 500));
            }
        }

        // Helper function to collect all verbatims from all topics in a category
        function collectCategoryVerbatims(categoryData) {
            if (!categoryData) return [];
            const allVerbatims = [];
            if (categoryData.children && Array.isArray(categoryData.children)) {
                categoryData.children.forEach(topic => {
                    if (topic && topic.verbatims && Array.isArray(topic.verbatims)) {
                        allVerbatims.push(...topic.verbatims);
                    }
                });
            }
            return allVerbatims;
        }

        // Helper function to collect all verbatims from the entire dimension
        function collectAllDimensionVerbatims() {
            if (!hierarchyData || !hierarchyData.children) return [];
            const allVerbatims = [];
            hierarchyData.children.forEach(category => {
                if (category && category.children && Array.isArray(category.children)) {
                    category.children.forEach(topic => {
                        if (topic && topic.verbatims && Array.isArray(topic.verbatims)) {
                            allVerbatims.push(...topic.verbatims);
                        }
                    });
                }
            });
            return allVerbatims;
        }

        // Helper function to find a category in hierarchyData by name
        function findCategoryInHierarchy(categoryName) {
            if (!hierarchyData || !hierarchyData.children) return null;
            return hierarchyData.children.find(cat => cat.name === categoryName) || null;
        }

        // Helper function to find a topic in a category by name
        function findTopicInCategory(categoryData, topicName) {
            if (!categoryData || !categoryData.children) return null;
            return categoryData.children.find(topic => topic.name === topicName) || null;
        }

        // Render treemap
        function renderTreemap(data) {
            // Recalculate container dimensions to ensure accurate sizing
            const container = document.querySelector('.treemap-svg-container');
            if (container) {
                // Force a layout recalculation by reading offsetWidth/offsetHeight
                width = container.clientWidth || container.offsetWidth;
                height = container.clientHeight || container.offsetHeight;
            }
            
            // Ensure minimum dimensions
            if (!width || width < 100) width = 800;
            if (!height || height < 100) height = 600;
            
            const svg = d3.select('#treemap');
            svg.selectAll('*').remove();
            // Set explicit dimensions - these will be updated on resize
            svg.attr('width', width).attr('height', height);
            
            // Set up resize handler directly when treemap is rendered (if not already set up)
            if (!window._treemapResizeHandlerAttached) {
                const treemapResizeHandler = debounce(() => {
                    if (hierarchyData) {
                        const container = document.querySelector('.treemap-svg-container');
                        if (container) {
                            const newWidth = container.clientWidth;
                            const newHeight = container.clientHeight;
                            if (newWidth && newHeight && (Math.abs(newWidth - width) > 2 || Math.abs(newHeight - height) > 2)) {
                                width = newWidth;
                                height = newHeight;
                                renderTreemap(hierarchyData);
                            }
                        }
                    }
                }, 250);
                window.addEventListener('resize', treemapResizeHandler);
                window._treemapResizeHandlerAttached = true;
            }

            document.getElementById('verbatims').style.display = 'none';

            const root = d3.hierarchy(data)
                .sum(d => d.value || 0)
                .sort((a, b) => b.value - a.value);

            const totalValue = root.value || 0;
            
            // Handle empty data case
            if (!root.children || root.children.length === 0 || totalValue === 0) {
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .style('font-size', '16px')
                    .style('fill', '#999')
                    .text('No data available for this dimension');
                return;
            }

            // Responsive padding based on viewport
            const isMobile = width < 768;
            const outerPadding = isMobile ? 5 : 10;
            const topPadding = root.children && root.depth === 0 ? (isMobile ? 28 : 30) : (isMobile ? 2 : 3);
            const innerPadding = isMobile ? 2 : 3;

            d3.treemap()
                .size([width, height])
                .paddingOuter(outerPadding)
                .paddingTop(topPadding)
                .paddingInner(innerPadding)
                .round(true)
                (root);

            // Draw category groups (parent rectangles) first
            if (root.children && root.depth === 0) {
                const categoryGroups = svg.selectAll('.category-group')
                    .data(root.children)
                    .join('g')
                    .attr('class', 'category-group')
                    .style('cursor', 'pointer')
                    .on('click', (event, d) => {
                        try {
                            // Collect all verbatims from all topics in this category
                            if (d && d.data) {
                                const allVerbatims = collectCategoryVerbatims(d.data);
                                if (allVerbatims.length > 0) {
                                    showVerbatims(allVerbatims, d.data.name || 'Category', d.data.name || 'Category');
                                }
                            }
                        } catch (error) {
                            console.error('Error handling category click:', error);
                        }
                    })
                    .on('contextmenu', (event, d) => {
                        event.preventDefault();
                        event.stopPropagation();
                        if (d && d.data) {
                            const contextData = {
                                type: 'category',
                                category: d.data.name,
                                project_name: currentProjectName,
                                data_source: currentDataSourceId,
                                dimension_ref: currentQuestionRefKey,
                                dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                            };
                            showContextMenu(event, contextData);
                        }
                    });

                // Category background rectangles with rounded corners
                categoryGroups.append('rect')
                    .attr('x', d => d.x0)
                    .attr('y', d => d.y0)
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', 'none')
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 1)
                    .attr('rx', 5)
                    .attr('ry', 5)
                    .attr('opacity', 0.6);

                // Category label bar
                categoryGroups.append('rect')
                    .attr('x', d => d.x0)
                    .attr('y', d => d.y0)
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', 26)
                    .attr('fill', d => colorSchemes.categories(d.data.name))
                    .attr('rx', 5)
                    .attr('ry', 5)
                    .attr('opacity', 0.95);

                // Category labels with percentage
                categoryGroups.append('text')
                    .attr('class', 'category-label')
                    .attr('x', d => d.x0 + (width < 768 ? 8 : 10))
                    .attr('y', d => d.y0 + 17)
                    .text(d => {
                        const percent = totalValue > 0 ? ((d.value / totalValue) * 100).toFixed(1) : '0.0';
                        const maxWidth = d.x1 - d.x0 - 20;
                        const isMobile = width < 768;
                        let text = `${d.data.name} (${percent}%)`;
                        
                        // Responsive text truncation for category labels
                        if (isMobile && maxWidth < 120) {
                            text = d.data.name.substring(0, 8) + '...';
                        } else if (maxWidth < 150) {
                            text = d.data.name.substring(0, 12) + '...';
                        } else if (maxWidth < 200) {
                            text = `${d.data.name.substring(0, 15)}... (${percent}%)`;
                        }
                        return text;
                    });
            }

            // Draw leaf nodes (topics)
            const nodes = svg.selectAll('.leaf-node')
                .data(root.leaves())
                .join('g')
                .attr('class', 'leaf-node');

            // Add rectangles with rounded corners
            nodes.append('rect')
                .attr('class', 'node')
                .attr('x', d => d.x0)
                .attr('y', d => d.y0)
                .attr('width', d => d.x1 - d.x0)
                .attr('height', d => d.y1 - d.y0)
                .attr('rx', 5)
                .attr('ry', 5)
                .attr('fill', d => {
                    // Handle case where parent might be null
                    if (!d.parent || !d.parent.data) {
                        return '#cccccc'; // Default gray color for orphaned nodes
                    }
                    const baseColor = colorSchemes.categories(d.parent.data.name);
                    // Vary brightness for child nodes based on their index
                    const siblings = d.parent.children;
                    const index = siblings.indexOf(d);
                    const brightnessAdjust = -10 + (index % 3) * 10; // -10, 0, +10
                    return adjustBrightness(baseColor, brightnessAdjust);
                })
                .on('click', (event, d) => handleNodeClick(d))
                .on('contextmenu', (event, d) => {
                    event.preventDefault();
                    event.stopPropagation();
                    if (d && d.data) {
                        const categoryName = d.parent?.data?.name || 'Unknown Category';
                        const contextData = {
                            type: 'topic',
                            category: categoryName,
                            topic_label: d.data.name,
                            project_name: currentProjectName,
                            data_source: currentDataSourceId,
                            dimension_ref: currentQuestionRefKey,
                            dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                        };
                        showContextMenu(event, contextData);
                    }
                });

            // Add centered text labels
            nodes.each(function(d) {
                const nodeWidth = d.x1 - d.x0;
                const nodeHeight = d.y1 - d.y0;
                const centerX = (d.x0 + d.x1) / 2;
                const centerY = (d.y0 + d.y1) / 2;
                
                // Responsive minimum sizes based on viewport
                const isMobile = width < 768;
                const minWidth = isMobile ? 40 : 50;
                const minHeight = isMobile ? 25 : 30;
                
                // Only show text if node is large enough
                if (nodeWidth < minWidth || nodeHeight < minHeight) return;
                
                const percent = totalValue > 0 ? ((d.value / totalValue) * 100).toFixed(1) : '0.0';
                const node = d3.select(this);
                
                // Responsive text truncation based on viewport
                let displayName = d.data.name;
                const mobileBreakpoint = isMobile ? 60 : 100;
                const tabletBreakpoint = isMobile ? 100 : 150;
                
                if (nodeWidth < mobileBreakpoint) {
                    displayName = displayName.substring(0, 8) + '...';
                } else if (nodeWidth < tabletBreakpoint) {
                    displayName = displayName.substring(0, 15) + (displayName.length > 15 ? '...' : '');
                } else if (nodeWidth < 200) {
                    displayName = displayName.substring(0, 25) + (displayName.length > 25 ? '...' : '');
                }
                
                // Responsive font sizing
                const baseFontSize = isMobile ? 10 : 12;
                const maxFontSize = isMobile ? 12 : 14;
                const fontSize = Math.min(maxFontSize, Math.max(baseFontSize, nodeWidth / (isMobile ? 10 : 15)));
                
                // Topic name (centered)
                node.append('text')
                    .attr('class', 'node-text')
                    .attr('x', centerX)
                    .attr('y', nodeHeight > (isMobile ? 40 : 50) ? centerY - 8 : centerY)
                    .style('font-size', `${fontSize}px`)
                    .text(displayName);
                
                // Percentage (below name if space allows)
                if (nodeHeight > (isMobile ? 40 : 50)) {
                    node.append('text')
                        .attr('class', 'node-label')
                        .attr('x', centerX)
                        .attr('y', centerY + 10)
                        .style('font-size', `${fontSize - 2}px`)
                        .text(`(${percent}%)`);
                }
            });
        }

        // Handle node click for drill-down
        function handleNodeClick(node) {
            // Check if this is a topic with verbatims (leaf node)
            if (node.data.verbatims && node.data.verbatims.length > 0) {
                // Show verbatims for this topic
                const categoryName = node.parent ? node.parent.data.name : 'Unknown Category';
                viewStack.push({ type: 'topic', data: node.data, parent: categoryName });
                showVerbatims(node.data.verbatims, node.data.name, categoryName);
            } else if (node.children || (node.data.children && node.data.children.length > 0)) {
                // This is a category - collect all verbatims from all topics
                const allVerbatims = collectCategoryVerbatims(node.data);
                if (allVerbatims.length > 0) {
                    // Show all verbatims for this category
                    viewStack.push({ type: 'category', data: node.data });
                    showVerbatims(allVerbatims, node.data.name, node.data.name);
                } else {
                    // No verbatims, drill down (fallback behavior)
                    viewStack.push({ type: 'category', data: node.data });
                    renderTreemap(node.data);
                }
            }
        }

        // Escape HTML to prevent XSS and layout issues
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Highlight search terms in text (case-insensitive, supports multiple words)
        function highlightSearchTerms(text, searchTerm) {
            if (!text || !searchTerm) {
                return escapeHtml(text || '');
            }
            
            // Escape the text first for safety
            const escapedText = escapeHtml(text);
            const trimmedSearch = searchTerm.trim();
            if (!trimmedSearch) {
                return escapedText;
            }
            
            // Split search term into words (handle multiple words)
            const searchWords = trimmedSearch.split(/\s+/).filter(word => word.length > 0);
            
            // Build regex pattern that matches any of the search words (case-insensitive)
            const pattern = searchWords.map(word => {
                // Escape special regex characters in the search word
                const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                return escapedWord;
            }).join('|');
            
            const regex = new RegExp(`(${pattern})`, 'gi');
            
            // Replace matches with highlighted versions
            return escapedText.replace(regex, '<mark class="search-highlight">$1</mark>');
        }

        // Render verbatims cards with current metadata settings
        function renderVerbatims(verbatims, topicName, categoryName) {
            const container = document.getElementById('verbatims');
            const settings = loadMetadataSettings();
            
            // Filter verbatims based on search term
            const searchTerm = verbatimSearchTerm.toLowerCase().trim();
            const filteredVerbatims = searchTerm === '' 
                ? verbatims 
                : verbatims.filter(v => {
                    const text = (v.text || '').toLowerCase();
                    const city = (v.city || '').toLowerCase();
                    const country = (v.country || '').toLowerCase();
                    const sentiment = (v.sentiment || '').toLowerCase();
                    const index = String(v.index || '').toLowerCase();
                    
                    return text.includes(searchTerm) || 
                           city.includes(searchTerm) || 
                           country.includes(searchTerm) || 
                           sentiment.includes(searchTerm) ||
                           index.includes(searchTerm);
                });
            
            // Update subtitle with filtered count
            const subtitle = document.getElementById('overlaySubtitle');
            if (subtitle && currentCategoryName) {
                if (searchTerm === '') {
                    subtitle.textContent = `${currentCategoryName}  ${verbatims.length} verbatim${verbatims.length !== 1 ? 's' : ''}`;
                } else {
                    subtitle.textContent = `${currentCategoryName}  ${filteredVerbatims.length} of ${verbatims.length} verbatim${verbatims.length !== 1 ? 's' : ''}`;
                }
            }
            
            // Clear and populate verbatims
            container.innerHTML = '';

            if (filteredVerbatims.length === 0 && searchTerm !== '') {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999; font-size: 14px;">No verbatims match your search</div>';
                return;
            }

            filteredVerbatims.forEach((v, index) => {
                const card = document.createElement('div');
                card.className = 'verbatim-card';
                
                const sentimentClass = v.sentiment ? `sentiment-${v.sentiment}` : 'sentiment-neutral';
                // Highlight search terms if there's a search
                const highlightedText = searchTerm ? highlightSearchTerms(v.text || 'No text available', verbatimSearchTerm) : escapeHtml(v.text || 'No text available');
                const escapedCity = v.city ? escapeHtml(v.city) : '';
                const escapedCountry = v.country ? escapeHtml(v.country) : '';
                
                // Build metadata HTML based on settings
                const metaItems = [];
                
                if (settings.showSentiment) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Sentiment:</span>
                            <span class="sentiment ${sentimentClass}">${v.sentiment || 'neutral'}</span>
                        </div>
                    `);
                }
                
                if (settings.showLocation && v.country) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Location:</span>
                            <span>${escapedCity ? escapedCity + ', ' : ''}${escapedCountry}</span>
                        </div>
                    `);
                }
                
                if (settings.showIndex) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Index:</span>
                            <span>#${v.index}</span>
                        </div>
                    `);
                }
                
                // Only show metadata section if there are items to display
                const metaHTML = metaItems.length > 0 ? `
                    <div class="verbatim-meta">
                        ${metaItems.join('')}
                    </div>
                ` : '';
                
                // Store verbatim data in a data attribute for the onclick handler
                // Use base64 encoding with Unicode-safe encoding
                const verbatimJson = JSON.stringify(v);
                const verbatimData = btoa(unescape(encodeURIComponent(verbatimJson)));
                
                card.innerHTML = `
                    <div class="verbatim-card-header">
                        <div class="verbatim-text" style="flex: 1; margin-bottom: 0; padding-right: 8px;">${highlightedText}</div>
                        <button class="create-insight-button" data-verbatim="${verbatimData}" onclick="createInsightFromVerbatim(this)" title="Create insight from this verbatim" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; color: oklch(0.556 0 0); transition: all 0.2s ease;" onmouseover="this.style.color='#B9F040'" onmouseout="this.style.color='oklch(0.556 0 0)'">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 5v14M5 12h14"/>
                            </svg>
                        </button>
                    </div>
                    ${metaHTML ? `<div style="margin-top: 16px;">${metaHTML}</div>` : ''}
                `;
                
                container.appendChild(card);
            });
        }

        // Show verbatims in slideout panel
        function showVerbatims(verbatims, topicName, categoryName) {
            // Use the slideout panel instead of the overlay
            if (window.SlideoutPanel) {
                window.SlideoutPanel.openVerbatims(verbatims, topicName, categoryName);
            }
        }
        
        // Helper functions for slideout settings
        
        function toggleSlideoutSettings() {
            const panel = document.getElementById('slideoutSettingsPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function updateSlideoutSettings() {
            // Re-render verbatims with new settings
            if (window.SlideoutPanel && window.SlideoutPanel.currentMode === 'verbatims') {
                window.SlideoutPanel.renderVerbatims(
                    window.SlideoutPanel.currentVerbatimsData,
                    window.SlideoutPanel.currentTopicName,
                    window.SlideoutPanel.currentCategoryName
                );
            }
        }

        // Store current verbatims data for re-rendering
        let currentVerbatimsData = null;
        let currentTopicName = null;
        let currentCategoryName = null;
        let verbatimSearchTerm = '';
        let favouritesSearchTerm = '';
        
        function clearVerbatimSearch() {
            const searchInput = document.getElementById('verbatimSearch');
            if (searchInput) {
                searchInput.value = '';
                verbatimSearchTerm = '';
                if (currentVerbatimsData) {
                    renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
                }
                updateVerbatimSearchClearButton();
            }
        }
        
        function updateVerbatimSearchClearButton() {
            const searchInput = document.getElementById('verbatimSearch');
            const clearButton = document.getElementById('verbatimSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.style.display = 'flex';
                } else {
                    clearButton.style.display = 'none';
                }
            }
        }

        function clearFavouritesSearch() {
            const searchInput = document.getElementById('favouritesSearch');
            if (searchInput) {
                searchInput.value = '';
                favouritesSearchTerm = '';
                renderFavourites();
                updateFavouritesSearchClearButton();
            }
        }

        function updateFavouritesSearchClearButton() {
            const searchInput = document.getElementById('favouritesSearch');
            const clearButton = document.getElementById('favouritesSearchClear');
            if (searchInput && clearButton) {
                if (searchInput.value.trim() !== '') {
                    clearButton.classList.add('active');
                } else {
                    clearButton.classList.remove('active');
                }
            }
        }

        // Treemap search functionality
        function handleTreemapSearch() {
            const searchInput = document.getElementById('treemapSearch');
            const clearBtn = document.getElementById('treemapSearchClear');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim();
            
            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = searchTerm ? 'flex' : 'none';
            }
            
            // Update search-active class based on search term and slideout state
            if (searchContainer) {
                const slideoutOpen = document.body.classList.contains('slideout-open');
                if (searchTerm && slideoutOpen) {
                    searchContainer.classList.add('search-active');
                } else {
                    searchContainer.classList.remove('search-active');
                }
            }
            
            // If search is empty, don't do anything (user can continue viewing treemap)
            if (!searchTerm) {
                return;
            }
            
            // Collect all verbatims from the dimension
            const allVerbatims = collectAllDimensionVerbatims();
            
            if (allVerbatims.length === 0) {
                return;
            }
            
            // Filter verbatims based on search (multi-word: all words must match)
            const searchWords = searchTerm.toLowerCase().split(/\s+/).filter(word => word.length > 0);
            const filteredVerbatims = allVerbatims.filter(v => {
                const verbatimText = (v.text || '').toLowerCase();
                // Check if all search words appear in the verbatim text
                return searchWords.every(word => verbatimText.includes(word));
            });
            
            // Display filtered verbatims
            if (filteredVerbatims.length > 0) {
                showVerbatims(filteredVerbatims, `Search: "${searchTerm}"`, 'All Categories');
            } else {
                // Show empty state in verbatims panel
                showVerbatims([], `Search: "${searchTerm}"`, 'All Categories');
            }
            
            // Set the search term in the slideout panel AFTER openVerbatims completes
            // (openVerbatims clears it, so we need to set it after and re-render)
            if (window.SlideoutPanel) {
                window.SlideoutPanel.verbatimSearchTerm = searchTerm;
                // Re-render verbatims with the search term for highlighting
                if (window.SlideoutPanel.currentMode === 'verbatims' && window.SlideoutPanel.currentVerbatimsData) {
                    window.SlideoutPanel.renderVerbatims(
                        window.SlideoutPanel.currentVerbatimsData,
                        window.SlideoutPanel.currentTopicName,
                        window.SlideoutPanel.currentCategoryName
                    );
                }
            }
        }
        
        function clearTreemapSearch() {
            const searchInput = document.getElementById('treemapSearch');
            const clearBtn = document.getElementById('treemapSearchClear');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (searchInput) {
                searchInput.value = '';
                if (clearBtn) {
                    clearBtn.style.display = 'none';
                }
                // Focus the search input after clearing
                searchInput.focus();
            }
            
            // Remove search-active class
            if (searchContainer) {
                searchContainer.classList.remove('search-active');
            }
            
            // Clear the slideout search term if it was set from treemap search
            if (window.SlideoutPanel) {
                // Only clear if the slideout is showing search results
                const currentTitle = document.getElementById('slideoutTitle');
                if (currentTitle && currentTitle.textContent.includes('Search:')) {
                    window.SlideoutPanel.verbatimSearchTerm = '';
                }
            }
            
            // Close verbatims panel if it was opened by search
            if (window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                // Only close if the current view is from search
                const currentTitle = document.getElementById('slideoutTitle');
                if (currentTitle && currentTitle.textContent.includes('Search:')) {
                    window.SlideoutPanel.close();
                }
            }
        }

        // Update search bar z-index based on slideout state and search term
        function updateTreemapSearchZIndex() {
            const searchInput = document.getElementById('treemapSearch');
            const searchContainer = document.querySelector('.treemap-search-container');
            
            if (!searchContainer || !searchInput) return;
            
            const searchTerm = searchInput.value.trim();
            const slideoutOpen = document.body.classList.contains('slideout-open');
            
            if (searchTerm && slideoutOpen) {
                searchContainer.classList.add('search-active');
            } else {
                searchContainer.classList.remove('search-active');
            }
        }

        // Toggle chart visibility
        function toggleChart(button) {
            const chart = button.closest('.chart');
            if (chart) {
                chart.classList.toggle('collapsed');
            }
        }

        // Toggle treemap visibility
        function toggleTreemap(button) {
            const container = button.closest('.treemap-container');
            if (container) {
                container.classList.toggle('collapsed');
            }
        }

        // Load metadata settings from localStorage
        function loadMetadataSettings() {
            const defaultSettings = {
                showSentiment: true,
                showLocation: true,
                showIndex: true
            };
            
            const saved = localStorage.getItem('verbatimMetadataSettings');
            if (saved) {
                try {
                    return { ...defaultSettings, ...JSON.parse(saved) };
                } catch (e) {
                    return defaultSettings;
                }
            }
            return defaultSettings;
        }

        // Save metadata settings to localStorage
        function saveMetadataSettings(settings) {
            localStorage.setItem('verbatimMetadataSettings', JSON.stringify(settings));
        }

        // Favorites management functions
        function getFavouriteKey(verbatim) {
            // Create a unique key based on index (row_id) and first 50 chars of text
            const textPrefix = (verbatim.text || '').substring(0, 50).replace(/\s+/g, ' ').trim();
            return `${verbatim.index || 'unknown'}_${textPrefix}`;
        }

        function getFavouritesStorageKey() {
            // Scope favorites by client and project (persist across sources within same client/project)
            const clientId = currentClientId || 'no-client';
            const projectName = currentProjectName || 'all-projects';
            return `verbatimFavourites_${clientId}_${projectName}`;
        }

        function getFavourites() {
            try {
                const storageKey = getFavouritesStorageKey();
                const saved = localStorage.getItem(storageKey);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        }

        function saveFavourites(favourites) {
            const storageKey = getFavouritesStorageKey();
            localStorage.setItem(storageKey, JSON.stringify(favourites));
        }

        function isFavourite(verbatim) {
            const favourites = getFavourites();
            const key = getFavouriteKey(verbatim);
            return favourites.some(fav => fav.key === key);
        }

        function handleFavouriteClick(button) {
            const verbatimData = button.getAttribute('data-verbatim');
            if (!verbatimData) return;
            
            try {
                // Decode base64 encoded JSON with Unicode-safe decoding
                const verbatimJson = decodeURIComponent(escape(atob(verbatimData)));
                const verbatim = JSON.parse(verbatimJson);
                toggleFavourite(verbatim);
            } catch (e) {
                console.error('Error parsing verbatim data:', e);
            }
        }

        function createInsightFromVerbatim(button) {
            const verbatimData = button.getAttribute('data-verbatim');
            if (!verbatimData) {
                console.error('No verbatim data found');
                return;
            }

            if (!currentClientId) {
                alert('No client selected');
                return;
            }

            try {
                // Decode base64 encoded JSON with Unicode-safe decoding
                const verbatimJson = decodeURIComponent(escape(atob(verbatimData)));
                const verbatim = JSON.parse(verbatimJson);

                // Extract category and topic from verbatim
                const category = verbatim.category || null;
                const topic = verbatim.topic || null;

                // Determine type: use 'topic' if both category and topic exist, 'category' if only category
                const type = (category && topic) ? 'topic' : (category ? 'category' : 'category');

                // Build context data similar to right-click context menu
                const contextData = {
                    type: type,
                    category: category,
                    topic_label: topic,
                    project_name: currentProjectName || null,
                    data_source: currentDataSourceId || null,
                    dimension_ref: currentQuestionRefKey || null,
                    dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                };

                // Store the verbatim to pre-pin in the insight creation panel
                if (window.SlideoutPanel) {
                    window.SlideoutPanel.prePinnedVerbatim = verbatim;
                    window.SlideoutPanel.openCreateInsight(contextData);
                } else {
                    console.error('SlideoutPanel not available');
                    alert('Error: Unable to open insight creation panel');
                }
            } catch (e) {
                console.error('Error parsing verbatim data:', e);
                alert('Error: Failed to create insight from verbatim');
            }
        }

        function toggleFavourite(verbatim) {
            const favourites = getFavourites();
            const key = getFavouriteKey(verbatim);
            const index = favourites.findIndex(fav => fav.key === key);
            
            if (index >= 0) {
                // Remove from favourites
                favourites.splice(index, 1);
            } else {
                // Add to favourites - include category and topic from current context
                // If verbatim already has category/topic (from favorites section), preserve them
                // Otherwise use current context
                const category = verbatim.category || currentCategoryName || null;
                const topic = verbatim.topic || currentTopicName || null;
                
                favourites.push({
                    key: key,
                    verbatim: {
                        text: verbatim.text,
                        sentiment: verbatim.sentiment,
                        index: verbatim.index,
                        country: verbatim.country,
                        city: verbatim.city,
                        date: verbatim.date,
                        source_type: verbatim.source_type,
                        category: category,
                        topic: topic
                    }
                });
            }
            
            saveFavourites(favourites);
            renderFavourites();
            
            // Re-render verbatims if they're currently displayed to update favorite buttons
            // Check both old overlay and new slideout panel
            if (currentVerbatimsData) {
                renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
            }
            
            // Also re-render slideout panel if it's showing verbatims
            if (window.SlideoutPanel && window.SlideoutPanel.currentMode === 'verbatims' && window.SlideoutPanel.currentVerbatimsData) {
                window.SlideoutPanel.renderVerbatims(
                    window.SlideoutPanel.currentVerbatimsData,
                    window.SlideoutPanel.currentTopicName,
                    window.SlideoutPanel.currentCategoryName
                );
            }
        }

        // Handle breadcrumb category click - show all verbatims from category
        function handleBreadcrumbCategoryClick(categoryName) {
            const categoryData = findCategoryInHierarchy(categoryName);
            if (categoryData) {
                const allVerbatims = collectCategoryVerbatims(categoryData);
                if (allVerbatims.length > 0) {
                    showVerbatims(allVerbatims, categoryName, categoryName);
                }
            }
        }

        // Handle breadcrumb topic click - show all verbatims from topic
        function handleBreadcrumbTopicClick(categoryName, topicName) {
            const categoryData = findCategoryInHierarchy(categoryName);
            if (categoryData) {
                const topicData = findTopicInCategory(categoryData, topicName);
                if (topicData && topicData.verbatims && topicData.verbatims.length > 0) {
                    showVerbatims(topicData.verbatims, topicName, categoryName);
                }
            }
        }

        // Render favourites section
        function renderFavourites() {
            const container = document.getElementById('favouritesContainer');
            if (!container) return;
            
            const favourites = getFavourites();
            
            // Filter favourites based on search term
            const searchTerm = favouritesSearchTerm.toLowerCase().trim();
            const filteredFavourites = searchTerm === '' 
                ? favourites 
                : favourites.filter(fav => {
                    const v = fav.verbatim;
                    const text = (v.text || '').toLowerCase();
                    const city = (v.city || '').toLowerCase();
                    const country = (v.country || '').toLowerCase();
                    const sentiment = (v.sentiment || '').toLowerCase();
                    const index = String(v.index || '').toLowerCase();
                    const category = (v.category || '').toLowerCase();
                    const topic = (v.topic || '').toLowerCase();
                    
                    return text.includes(searchTerm) || 
                           city.includes(searchTerm) || 
                           country.includes(searchTerm) || 
                           sentiment.includes(searchTerm) ||
                           index.includes(searchTerm) ||
                           category.includes(searchTerm) ||
                           topic.includes(searchTerm);
                });
            
            if (favourites.length === 0) {
                const skeletonCards = Array.from({ length: 6 }).map(() => `
                    <div class="skeleton-card">
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </div>
                `).join('');

                container.innerHTML = `
                    <div class="favourites-empty">
                        <div class="favourites-empty-grid">
                            ${skeletonCards}
                        </div>
                    </div>
                `;
                return;
            }
            
            // Show message if search returns no results
            if (filteredFavourites.length === 0 && searchTerm !== '') {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999; font-size: 14px;">No favourites match your search</div>';
                return;
            }
            
            // Render favourite verbatims
            container.innerHTML = '';
            const settings = loadMetadataSettings();
            
            filteredFavourites.forEach(fav => {
                const v = fav.verbatim;
                const card = document.createElement('div');
                card.className = 'verbatim-card';
                
                const sentimentClass = v.sentiment ? `sentiment-${v.sentiment}` : 'sentiment-neutral';
                // Highlight search terms if there's a search
                const highlightedText = searchTerm ? highlightSearchTerms(v.text || 'No text available', favouritesSearchTerm) : escapeHtml(v.text || 'No text available');
                const escapedCity = v.city ? escapeHtml(v.city) : '';
                const escapedCountry = v.country ? escapeHtml(v.country) : '';
                
                // Build breadcrumb HTML if category and topic are available
                let breadcrumbHTML = '';
                if (v.category && v.topic) {
                    const escapedCategory = escapeHtml(v.category);
                    const escapedTopic = escapeHtml(v.topic);
                    breadcrumbHTML = `
                        <div class="verbatim-breadcrumb" style="margin-top: 16px; margin-bottom: 12px; font-size: 13px; color: #666;">
                            <span class="breadcrumb-link breadcrumb-category" 
                                  style="color: #0066cc; cursor: pointer; text-decoration: underline;" 
                                  data-category="${escapedCategory}">
                                ${escapedCategory}
                            </span>
                            <span style="margin: 0 6px; color: #999;">&gt;</span>
                            <span class="breadcrumb-link breadcrumb-topic" 
                                  style="color: #0066cc; cursor: pointer; text-decoration: underline;" 
                                  data-category="${escapedCategory}"
                                  data-topic="${escapedTopic}">
                                ${escapedTopic}
                            </span>
                        </div>
                    `;
                }
                
                // Build metadata HTML based on settings
                const metaItems = [];
                
                if (settings.showSentiment) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Sentiment:</span>
                            <span class="sentiment ${sentimentClass}">${v.sentiment || 'neutral'}</span>
                        </div>
                    `);
                }
                
                if (settings.showLocation && v.country) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Location:</span>
                            <span>${escapedCity ? escapedCity + ', ' : ''}${escapedCountry}</span>
                        </div>
                    `);
                }
                
                if (settings.showIndex) {
                    metaItems.push(`
                        <div class="verbatim-meta-item">
                            <span class="verbatim-meta-label">Index:</span>
                            <span>#${v.index}</span>
                        </div>
                    `);
                }
                
                const metaHTML = metaItems.length > 0 ? `
                    <div class="verbatim-meta">
                        ${metaItems.join('')}
                    </div>
                ` : '';
                
                // Use base64 encoding with Unicode-safe encoding
                const verbatimJson = JSON.stringify(v);
                const verbatimData = btoa(unescape(encodeURIComponent(verbatimJson)));
                
                card.innerHTML = `
                    <div class="verbatim-card-header">
                        <div class="verbatim-text" style="flex: 1; margin-bottom: 0; padding-right: 8px;">${highlightedText}</div>
                        <button class="create-insight-button" data-verbatim="${verbatimData}" onclick="createInsightFromVerbatim(this)" title="Create insight from this verbatim" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; color: oklch(0.556 0 0); transition: all 0.2s ease;" onmouseover="this.style.color='#B9F040'" onmouseout="this.style.color='oklch(0.556 0 0)'">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 5v14M5 12h14"/>
                            </svg>
                        </button>
                    </div>
                    ${breadcrumbHTML}
                    ${metaHTML ? `<div style="margin-top: 16px;">${metaHTML}</div>` : ''}
                `;
                
                // Add click handlers for breadcrumbs
                if (v.category && v.topic) {
                    const categoryLink = card.querySelector('.breadcrumb-category');
                    const topicLink = card.querySelector('.breadcrumb-topic');
                    
                    if (categoryLink) {
                        categoryLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const categoryName = categoryLink.getAttribute('data-category');
                            handleBreadcrumbCategoryClick(categoryName);
                        });
                    }
                    
                    if (topicLink) {
                        topicLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const categoryName = topicLink.getAttribute('data-category');
                            const topicName = topicLink.getAttribute('data-topic');
                            handleBreadcrumbTopicClick(categoryName, topicName);
                        });
                    }
                }
                
                container.appendChild(card);
            });
        }

        // Initialize settings checkboxes on page load
        function initializeMetadataSettings() {
            const settings = loadMetadataSettings();
            document.getElementById('showSentiment').checked = settings.showSentiment;
            document.getElementById('showLocation').checked = settings.showLocation;
            document.getElementById('showIndex').checked = settings.showIndex;
        }

        // Toggle settings panel
        function toggleSettingsPanel() {
            const panel = document.getElementById('settingsPanel');
            const button = document.querySelector('.settings-button');
            const isActive = panel.classList.contains('active');
            
            if (isActive) {
                panel.classList.remove('active');
                button.classList.remove('active');
            } else {
                panel.classList.add('active');
                button.classList.add('active');
            }
        }

        // Update metadata settings and refresh cards
        function updateMetadataSettings() {
            const settings = {
                showSentiment: document.getElementById('showSentiment').checked,
                showLocation: document.getElementById('showLocation').checked,
                showIndex: document.getElementById('showIndex').checked
            };
            
            saveMetadataSettings(settings);
            
            // Re-render verbatims if they're currently displayed
            if (currentVerbatimsData) {
                renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
            }
        }

        // Close settings panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('settingsPanel');
            const button = document.querySelector('.settings-button');
            
            if (panel && button && !panel.contains(e.target) && !button.contains(e.target)) {
                panel.classList.remove('active');
                button.classList.remove('active');
            }
        });

        // Close overlay
        function closeOverlay() {
            const overlay = document.getElementById('overlay');
            const container = document.getElementById('verbatims');
            const panel = document.getElementById('settingsPanel');
            const button = document.querySelector('.settings-button');
            
            // Reset search term when closing overlay
            verbatimSearchTerm = '';
            const searchInput = document.getElementById('verbatimSearch');
            if (searchInput) {
                searchInput.value = '';
            }
            updateVerbatimSearchClearButton();
            
            overlay.classList.remove('active');
            container.style.display = 'none';
            if (panel) panel.classList.remove('active');
            if (button) button.classList.remove('active');
            viewStack = [];
            currentVerbatimsData = null;
        }

        // Close overlay when clicking on backdrop
        document.addEventListener('DOMContentLoaded', () => {
            setupFilterTabs();
            // Auto-size selects after a short delay to ensure everything is rendered
            setTimeout(() => {
                autoSizeFilterSelects();
            }, 100);
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize metadata settings
            initializeMetadataSettings();
            
            // Initialize favourites section
            renderFavourites();
            
            // Setup verbatim search input event listener
            const verbatimSearchInput = document.getElementById('verbatimSearch');
            if (verbatimSearchInput) {
                verbatimSearchInput.addEventListener('input', (e) => {
                    verbatimSearchTerm = e.target.value;
                    if (currentVerbatimsData) {
                        renderVerbatims(currentVerbatimsData, currentTopicName, currentCategoryName);
                    }
                    updateVerbatimSearchClearButton();
                });
            }
            
            // Setup favourites search input event listener
            const favouritesSearchInput = document.getElementById('favouritesSearch');
            if (favouritesSearchInput) {
                favouritesSearchInput.addEventListener('input', (e) => {
                    favouritesSearchTerm = e.target.value;
                    renderFavourites();
                    updateFavouritesSearchClearButton();
                });
            }
            
            // Setup treemap search input event listener
            const treemapSearchInput = document.getElementById('treemapSearch');
            if (treemapSearchInput) {
                // Use debounce to avoid too many searches while typing
                let treemapSearchTimeout;
                treemapSearchInput.addEventListener('input', (e) => {
                    clearTimeout(treemapSearchTimeout);
                    treemapSearchTimeout = setTimeout(() => {
                        handleTreemapSearch();
                    }, 300); // Wait 300ms after user stops typing
                });
                
                // Also handle Enter key for immediate search
                treemapSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        clearTimeout(treemapSearchTimeout);
                        handleTreemapSearch();
                    }
                });
            }
            
            // Fix mobile viewport height issues
            function setViewportHeight() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
            
            setViewportHeight();
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', setViewportHeight);
            
            const overlay = document.getElementById('overlay');
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeOverlay();
                }
            });
            
            // Close overlay with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay.classList.contains('active')) {
                    closeOverlay();
                }
            });
        });


        // Bar Chart functionality
        function generateCategoryColorPalette() {
            return {
                'GENERAL INFORMATION': '#A98CFD',
                'BOOKING/PRICE': '#74C7E8',
                'TOUR/ITINERARY': '#6FD4A1',
                'ACCOMMODATION': '#F4A85B',
                'FLIGHTS': '#F07D8C',
                'AVAILABILITY': '#B794F6',
                'TRAVELLER DETAILS': '#77D9D6',
                'HELP': '#FFB366',
                'NPD': '#9A7B6C'
            };
        }

        function adjustColorLightness(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
        }

         function processBarChartData() {
             const categoryMap = new Map();
             let totalTopicInstances = 0;

             rawData.forEach(row => {
                 // Normalized format: {row_id, text, topics[], sentiment, metadata{}}
                 const topics = row.topics || [];
                 topics.forEach(topic => {
                     if (!topic.category) return;

                     totalTopicInstances++;

                     if (!categoryMap.has(topic.category)) {
                         categoryMap.set(topic.category, {
                             name: topic.category,
                             count: 0,
                             topics: new Map()
                         });
                     }

                     const category = categoryMap.get(topic.category);
                     category.count++;

                     if (!category.topics.has(topic.label)) {
                         category.topics.set(topic.label, {
                             name: topic.label,
                             count: 0,
                             verbatims: []
                         });
                     }

                     const topicData = category.topics.get(topic.label);
                     topicData.count++;
                     
                     // Add verbatim data - include all metadata fields dynamically
                     topicData.verbatims.push({
                         text: row.text || '',
                         sentiment: row.sentiment || 'neutral',
                         index: row.row_id,
                         // Preserve commonly used fields for backward compatibility
                         country: row.metadata?.country || '',
                         city: row.metadata?.city || '',
                         date: row.metadata?.created_at || '',
                         // Include all other metadata fields
                         ...(row.metadata || {})
                     });
                 });
             });

             // Convert to array and sort
             const categories = Array.from(categoryMap.values()).map(cat => ({
                 name: cat.name,
                 count: cat.count,
                 percent: (cat.count / totalTopicInstances) * 100,
                 topics: Array.from(cat.topics.values()).map(topic => ({
                     name: topic.name,
                     count: topic.count,
                     percent: (topic.count / totalTopicInstances) * 100,
                     verbatims: topic.verbatims
                 })).sort((a, b) => b.count - a.count)
             })).sort((a, b) => b.count - a.count);

             return { categories, totalTopicInstances };
         }

        function renderBarChart() {
            const { categories, totalTopicInstances } = processBarChartData();
            const colorPalette = generateCategoryColorPalette();
            
            // Update total count
            document.getElementById('totalCount').textContent = totalTopicInstances;

            // Get max percent for scaling
            const maxPercent = Math.max(...categories.map(c => c.percent));
            const scale = maxPercent > 0 ? 100 / maxPercent : 1;

            // Render labels and bars
            const labelsContainer = document.getElementById('barChartLabels');
            const barsContainer = document.getElementById('barChartBars');
            
            labelsContainer.innerHTML = '';
            barsContainer.innerHTML = '';

            // Create gridlines
            const gridlinesContainer = document.createElement('div');
            gridlinesContainer.className = 'gridlines';
            const ticks = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
            ticks.forEach(tick => {
                const line = document.createElement('div');
                line.className = 'gridline';
                line.style.left = `${tick}%`;
                gridlinesContainer.appendChild(line);
            });
            barsContainer.appendChild(gridlinesContainer);

            // Create content container for bars
            const barsContent = document.createElement('div');
            barsContent.style.position = 'relative';
            barsContent.style.zIndex = '1';
            barsContainer.appendChild(barsContent);

            // Create axis labels
            const axisContainer = document.createElement('div');
            axisContainer.className = 'axis--bottom';
            ticks.forEach(tick => {
                const label = document.createElement('span');
                label.className = 'axis__label';
                label.style.left = `${tick}%`;
                label.textContent = `${tick}%`;
                axisContainer.appendChild(label);
            });
            barsContainer.appendChild(axisContainer);

            // Render each category
            categories.forEach((category, catIndex) => {
                const categoryId = `cat-${catIndex}`;
                const baseColor = colorPalette[category.name] || categoryColors[catIndex % categoryColors.length];

                // Helper function to collect all verbatims from category (shared by header and bar)
                const collectAllCategoryVerbatims = () => {
                    const allVerbatims = [];
                    category.topics.forEach(topic => {
                        if (topic.verbatims && Array.isArray(topic.verbatims)) {
                            allVerbatims.push(...topic.verbatims);
                        }
                    });
                    return allVerbatims;
                };

                // Labels column: toggle + label
                const labelGroup = document.createElement('div');
                labelGroup.className = 'group';

                const headerRow = document.createElement('div');
                headerRow.className = 'group__header';
                headerRow.style.cursor = 'pointer';

                const toggle = document.createElement('button');
                toggle.className = 'toggle';
                toggle.setAttribute('aria-expanded', 'false');
                toggle.setAttribute('aria-controls', categoryId);
                toggle.textContent = '+';
                toggle.onclick = (e) => {
                    e.stopPropagation(); // Prevent triggering headerRow click
                    toggleCategory(categoryId, toggle);
                };

                // Add click handler to show all verbatims for this category
                headerRow.onclick = (e) => {
                    // Don't trigger if clicking the toggle button
                    if (e.target === toggle || toggle.contains(e.target)) {
                        return;
                    }
                    const allVerbatims = collectAllCategoryVerbatims();
                    if (allVerbatims.length > 0) {
                        showVerbatims(allVerbatims, category.name, category.name);
                    }
                };
                // Add right-click handler for context menu
                headerRow.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const contextData = {
                        type: 'category',
                        category: category.name,
                        project_name: currentProjectName,
                        data_source: currentDataSourceId,
                        dimension_ref: currentQuestionRefKey,
                        dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                    };
                    showContextMenu(e, contextData);
                };
                headerRow.setAttribute('role', 'button');
                headerRow.setAttribute('tabindex', '0');
                headerRow.setAttribute('aria-label', `View all conversations in ${category.name}`);
                headerRow.onkeydown = (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        const allVerbatims = collectAllCategoryVerbatims();
                        if (allVerbatims.length > 0) {
                            showVerbatims(allVerbatims, category.name, category.name);
                        }
                    }
                };

                const labelWrapper = document.createElement('div');
                labelWrapper.className = 'group__label-wrapper';

                const label = document.createElement('div');
                label.className = 'group__label';
                label.textContent = category.name;

                labelWrapper.appendChild(label);
                headerRow.appendChild(toggle);
                headerRow.appendChild(labelWrapper);
                labelGroup.appendChild(headerRow);

                 // Topics panel (collapsed by default)
                 const panel = document.createElement('div');
                 panel.className = 'group__panel';
                 panel.id = categoryId;
                 panel.setAttribute('hidden', '');
                 panel.setAttribute('role', 'region');
                 panel.setAttribute('aria-labelledby', categoryId + '-label');
                 panel.setAttribute('data-category-id', categoryId);

                 category.topics.forEach((topic, topicIndex) => {
                     const topicRow = document.createElement('div');
                     topicRow.className = 'topic';
                     
                     // Add click handler for drilldown to verbatims
                     topicRow.onclick = () => {
                         showVerbatims(topic.verbatims, topic.name, category.name);
                     };
                     // Add right-click handler for context menu
                     topicRow.oncontextmenu = (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         const contextData = {
                             type: 'topic',
                             category: category.name,
                             topic_label: topic.name,
                             project_name: currentProjectName,
                             data_source: currentDataSourceId,
                             dimension_ref: currentQuestionRefKey,
                             dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                         };
                         showContextMenu(e, contextData);
                     };
                     topicRow.setAttribute('role', 'button');
                     topicRow.setAttribute('tabindex', '0');
                     topicRow.setAttribute('aria-label', `View ${topic.count} conversations about ${topic.name}`);

                     const topicLabelWrapper = document.createElement('div');
                     topicLabelWrapper.className = 'topic__label-wrapper';
                     topicLabelWrapper.style.width = '240px';

                     const bullet = document.createElement('div');
                     bullet.className = 'bullet';
                     const topicColor = adjustColorLightness(baseColor, (topicIndex % 3 - 1) * 15);
                     bullet.style.background = topicColor;
                     bullet.style.opacity = '0.4';

                     const topicLabel = document.createElement('div');
                     topicLabel.className = 'topic__label';
                     topicLabel.textContent = topic.name;

                     topicLabelWrapper.appendChild(bullet);
                     topicLabelWrapper.appendChild(topicLabel);
                     topicRow.appendChild(topicLabelWrapper);
                     panel.appendChild(topicRow);
                     
                     // Add keyboard support
                     topicRow.onkeydown = (e) => {
                         if (e.key === 'Enter' || e.key === ' ') {
                             e.preventDefault();
                             showVerbatims(topic.verbatims, topic.name, category.name);
                         }
                     };
                 });

                labelGroup.appendChild(panel);
                labelsContainer.appendChild(labelGroup);

                // Bars column: category bar
                const barGroup = document.createElement('div');
                barGroup.className = 'group';

                const barHeaderRow = document.createElement('div');
                barHeaderRow.className = 'group__bar-container';
                barHeaderRow.style.cursor = 'pointer';

                // Add click handler to show all verbatims for this category
                barHeaderRow.onclick = () => {
                    const allVerbatims = collectAllCategoryVerbatims();
                    if (allVerbatims.length > 0) {
                        showVerbatims(allVerbatims, category.name, category.name);
                    }
                };
                // Add right-click handler for context menu
                barHeaderRow.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const contextData = {
                        type: 'category',
                        category: category.name,
                        project_name: currentProjectName,
                        data_source: currentDataSourceId,
                        dimension_ref: currentQuestionRefKey,
                        dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                    };
                    showContextMenu(e, contextData);
                };
                barHeaderRow.setAttribute('role', 'button');
                barHeaderRow.setAttribute('tabindex', '0');
                barHeaderRow.setAttribute('aria-label', `View all conversations in ${category.name}`);
                barHeaderRow.onkeydown = (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        const allVerbatims = collectAllCategoryVerbatims();
                        if (allVerbatims.length > 0) {
                            showVerbatims(allVerbatims, category.name, category.name);
                        }
                    }
                };

                const track = document.createElement('div');
                track.className = 'bar__track';

                const fill = document.createElement('div');
                fill.className = 'bar__fill';
                fill.style.background = baseColor;
                fill.style.width = '0%';
                
                const barWidthPercent = (category.percent / maxPercent) * 100;
                
                const value = document.createElement('div');
                value.textContent = `${category.percent.toFixed(1)}%`;
                
                // Estimate if label fits inside (rough estimate: 40px for percentage label)
                const estimatedLabelWidth = 40; // pixels
                const containerWidth = barsContainer.clientWidth || 600; // fallback width
                const barWidthPixels = (barWidthPercent / 100) * containerWidth;
                
                if (barWidthPixels > estimatedLabelWidth + 16) {
                    // Enough space inside
                    value.className = 'bar__value bar__value--inside';
                    fill.appendChild(value);
                } else {
                    // Not enough space, place outside
                    value.className = 'bar__value bar__value--outside';
                    value.style.left = `${barWidthPercent}%`;
                    barHeaderRow.appendChild(value);
                }

                setTimeout(() => {
                    fill.style.width = `${barWidthPercent}%`;
                }, 50);

                barHeaderRow.appendChild(track);
                barHeaderRow.appendChild(fill);
                barGroup.appendChild(barHeaderRow);

                 // Topic bars panel
                 const barsPanel = document.createElement('div');
                 barsPanel.className = 'group__panel';
                 barsPanel.id = categoryId + '-bars';
                 barsPanel.setAttribute('hidden', '');
                 barsPanel.setAttribute('data-category-id', categoryId);

                 category.topics.forEach((topic, topicIndex) => {
                     const topicBarRow = document.createElement('div');
                     topicBarRow.className = 'topic__bar-container';
                     topicBarRow.style.cursor = 'pointer';
                     topicBarRow.style.marginBottom = '6px';
                     
                     // Add click handler for drilldown to verbatims
                     topicBarRow.onclick = () => {
                         showVerbatims(topic.verbatims, topic.name, category.name);
                     };
                     // Add right-click handler for context menu
                     topicBarRow.oncontextmenu = (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         const contextData = {
                             type: 'topic',
                             category: category.name,
                             topic_label: topic.name,
                             project_name: currentProjectName,
                             data_source: currentDataSourceId,
                             dimension_ref: currentQuestionRefKey,
                             dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                         };
                         showContextMenu(e, contextData);
                     };

                     const topicTrack = document.createElement('div');
                     topicTrack.className = 'bar__track';

                     const topicFill = document.createElement('div');
                     topicFill.className = 'bar__fill';
                     const topicColor = adjustColorLightness(baseColor, (topicIndex % 3 - 1) * 15);
                     topicFill.style.background = topicColor;
                     topicFill.style.width = '0%';
                     
                     const topicBarWidthPercent = (topic.percent / maxPercent) * 100;
                     
                     const topicValue = document.createElement('div');
                     topicValue.textContent = `${topic.percent.toFixed(1)}%`;
                     
                     // Estimate if label fits inside
                     const estimatedLabelWidth = 40; // pixels
                     const containerWidth = barsContainer.clientWidth || 600;
                     const topicBarWidthPixels = (topicBarWidthPercent / 100) * containerWidth;
                     
                     if (topicBarWidthPixels > estimatedLabelWidth + 16) {
                         // Enough space inside
                         topicValue.className = 'bar__value bar__value--inside';
                         topicFill.appendChild(topicValue);
                     } else {
                         // Not enough space, place outside
                         topicValue.className = 'bar__value bar__value--outside';
                         topicValue.style.left = `${topicBarWidthPercent}%`;
                         topicBarRow.appendChild(topicValue);
                     }

                     setTimeout(() => {
                         topicFill.style.width = `${topicBarWidthPercent}%`;
                     }, 50 + topicIndex * 30);

                     topicBarRow.appendChild(topicTrack);
                     topicBarRow.appendChild(topicFill);
                     barsPanel.appendChild(topicBarRow);
                 });

                barGroup.appendChild(barsPanel);
                barsContent.appendChild(barGroup);
            });
        }

         function toggleCategory(categoryId, toggleButton) {
             const panel = document.getElementById(categoryId);
             const barsPanel = document.getElementById(categoryId + '-bars');

             if (panel && panel.hasAttribute('hidden')) {
                 panel.removeAttribute('hidden');
                 if (barsPanel) barsPanel.removeAttribute('hidden');
                 toggleButton.textContent = '';
                 toggleButton.setAttribute('aria-expanded', 'true');
             } else if (panel) {
                 panel.setAttribute('hidden', '');
                 if (barsPanel) barsPanel.setAttribute('hidden', '');
                 toggleButton.textContent = '+';
                 toggleButton.setAttribute('aria-expanded', 'false');
             }
         }

         // Topics Chart (uncategorized)
         function processTopicsData() {
             const topicsMap = new Map();
             let totalTopicInstances = 0;

             rawData.forEach(row => {
                 // Normalized format: {row_id, text, topics[], sentiment, metadata{}}
                 const topics = row.topics || [];
                 topics.forEach(topic => {
                     if (!topic.label) return;

                     totalTopicInstances++;

                     if (!topicsMap.has(topic.label)) {
                         topicsMap.set(topic.label, {
                             name: topic.label,
                             category: topic.category || 'Unknown',
                             count: 0,
                             verbatims: []
                         });
                     }

                     const topicData = topicsMap.get(topic.label);
                     topicData.count++;
                     
                     // Add verbatim data - include all metadata fields dynamically
                     topicData.verbatims.push({
                         text: row.text || '',
                         sentiment: row.sentiment || 'neutral',
                         index: row.row_id,
                         // Preserve commonly used fields for backward compatibility
                         country: row.metadata?.country || '',
                         city: row.metadata?.city || '',
                         date: row.metadata?.created_at || '',
                         // Include all other metadata fields
                         ...(row.metadata || {})
                     });
                 });
             });

             // Convert to array and sort by count
             const topics = Array.from(topicsMap.values()).map(topic => ({
                 name: topic.name,
                 category: topic.category,
                 count: topic.count,
                 percent: (topic.count / totalTopicInstances) * 100,
                 verbatims: topic.verbatims
             })).sort((a, b) => b.count - a.count);

             return { topics, totalTopicInstances };
         }

        function renderTopicsChart() {
            const { topics, totalTopicInstances } = processTopicsData();
            const colorPalette = generateCategoryColorPalette();
            
            // Update total count
            document.getElementById('topicsCount').textContent = totalTopicInstances;

            // Get max percent for scaling
            const maxPercent = Math.max(...topics.map(t => t.percent));

            // Render labels and bars
            const labelsContainer = document.getElementById('topicsChartLabels');
            const barsContainer = document.getElementById('topicsChartBars');
            
            labelsContainer.innerHTML = '';
            barsContainer.innerHTML = '';

            // Create gridlines
            const gridlinesContainer = document.createElement('div');
            gridlinesContainer.className = 'gridlines';
            const ticks = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
            ticks.forEach(tick => {
                const line = document.createElement('div');
                line.className = 'gridline';
                line.style.left = `${tick}%`;
                gridlinesContainer.appendChild(line);
            });
            barsContainer.appendChild(gridlinesContainer);

            // Create content container for bars
            const barsContent = document.createElement('div');
            barsContent.style.position = 'relative';
            barsContent.style.zIndex = '1';
            barsContainer.appendChild(barsContent);

            // Create axis labels
            const axisContainer = document.createElement('div');
            axisContainer.className = 'axis--bottom';
            ticks.forEach(tick => {
                const label = document.createElement('span');
                label.className = 'axis__label';
                label.style.left = `${tick}%`;
                label.textContent = `${tick}%`;
                axisContainer.appendChild(label);
            });
            barsContainer.appendChild(axisContainer);

             // Render each topic as a simple row
             topics.forEach((topic, index) => {
                 const baseColor = colorPalette[topic.category] || categoryColors[index % categoryColors.length];
                 
                // Labels column
                const labelRow = document.createElement('div');
                labelRow.className = 'topic';
                labelRow.style.marginBottom = '6px';
                 
                 // Add click handler for drilldown to verbatims
                 labelRow.onclick = () => {
                     showVerbatims(topic.verbatims, topic.name, topic.category);
                 };
                 // Add right-click handler for context menu
                 labelRow.oncontextmenu = (e) => {
                     e.preventDefault();
                     e.stopPropagation();
                     const contextData = {
                         type: 'topic',
                         category: topic.category,
                         topic_label: topic.name,
                         project_name: currentProjectName,
                         data_source: currentDataSourceId,
                         dimension_ref: currentQuestionRefKey,
                         dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                     };
                     showContextMenu(e, contextData);
                 };
                 labelRow.setAttribute('role', 'button');
                 labelRow.setAttribute('tabindex', '0');
                 labelRow.setAttribute('aria-label', `View ${topic.count} conversations about ${topic.name}`);

                 const labelWrapper = document.createElement('div');
                 labelWrapper.className = 'topic__label-wrapper';
                 labelWrapper.style.width = '240px';
                 labelWrapper.style.paddingLeft = '0';

                 const bullet = document.createElement('div');
                 bullet.className = 'bullet';
                 bullet.style.background = baseColor;
                 bullet.style.opacity = '0.6';

                 const label = document.createElement('div');
                 label.className = 'topic__label';
                 label.textContent = topic.name;

                 labelWrapper.appendChild(bullet);
                 labelWrapper.appendChild(label);
                 labelRow.appendChild(labelWrapper);
                 labelsContainer.appendChild(labelRow);
                 
                 // Add keyboard support
                 labelRow.onkeydown = (e) => {
                     if (e.key === 'Enter' || e.key === ' ') {
                         e.preventDefault();
                         showVerbatims(topic.verbatims, topic.name, topic.category);
                     }
                 };

                // Bars column
                const barRow = document.createElement('div');
                barRow.className = 'topic__bar-container';
                barRow.style.marginBottom = '6px';
                barRow.style.cursor = 'pointer';
                
                // Add click handler for drilldown to verbatims
                barRow.onclick = () => {
                    showVerbatims(topic.verbatims, topic.name, topic.category);
                };
                // Add right-click handler for context menu
                barRow.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const contextData = {
                        type: 'topic',
                        category: topic.category,
                        topic_label: topic.name,
                        project_name: currentProjectName,
                        data_source: currentDataSourceId,
                        dimension_ref: currentQuestionRefKey,
                        dimension_name: currentQuestionRefKey ? getDimensionDisplayName(currentQuestionRefKey) : null,
                    };
                    showContextMenu(e, contextData);
                };

                const track = document.createElement('div');
                track.className = 'bar__track';

                const fill = document.createElement('div');
                fill.className = 'bar__fill';
                fill.style.background = baseColor;
                fill.style.width = '0%';
                
                const barWidthPercent = (topic.percent / maxPercent) * 100;
                
                const value = document.createElement('div');
                value.textContent = `${topic.percent.toFixed(1)}%`;
                
                // Estimate if label fits inside
                const estimatedLabelWidth = 40;
                const containerWidth = barsContainer.clientWidth || 600;
                const barWidthPixels = (barWidthPercent / 100) * containerWidth;
                
                if (barWidthPixels > estimatedLabelWidth + 16) {
                    value.className = 'bar__value bar__value--inside';
                    fill.appendChild(value);
                } else {
                    value.className = 'bar__value bar__value--outside';
                    value.style.left = `${barWidthPercent}%`;
                    barRow.appendChild(value);
                }

                setTimeout(() => {
                    fill.style.width = `${barWidthPercent}%`;
                }, 50 + index * 20);

                barRow.appendChild(track);
                barRow.appendChild(fill);
                barsContent.appendChild(barRow);
            });
        }

        // Inline Dimension Editor Functions
        
        let currentEditingRefKey = null;
        
        function setupInlineDimensionEditor() {
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            const saveBtn = document.getElementById('saveDimensionBtn');
            const manageBtn = document.getElementById('manageOptionsBtn');
            
            // Handle dimension name select change
            nameSelect.onchange = function() {
                if (this.value === 'CUSTOM') {
                    customInput.style.display = 'block';
                    customInput.focus();
                } else {
                    customInput.style.display = 'none';
                    customInput.value = '';
                }
            };
            
            // Save button
            saveBtn.onclick = saveInlineDimensionName;
            
            // Manage options button
            manageBtn.onclick = manageOptions;
        }
        
        function updateInlineDimensionEditor(refKey) {
            currentEditingRefKey = refKey;
            
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            
            // Get current name for this dimension
            const currentName = dimensionNamesMap[refKey] || '';
            
            // Populate the dropdown
            let optionsHtml = '<option value="">-- Select --</option>';
            dimensionOptions.forEach(opt => {
                const selected = opt === currentName ? 'selected' : '';
                optionsHtml += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            
            // Check if current name is custom
            const isCustom = currentName && !dimensionOptions.includes(currentName);
            optionsHtml += `<option value="CUSTOM" ${isCustom ? 'selected' : ''}>Custom...</option>`;
            
            nameSelect.innerHTML = optionsHtml;
            
            // Show custom input if needed
            if (isCustom) {
                customInput.style.display = 'block';
                customInput.value = currentName;
            } else {
                customInput.style.display = 'none';
                customInput.value = '';
            }
        }
        
        async function saveInlineDimensionName() {
            if (!currentEditingRefKey) return;
            
            const nameSelect = document.getElementById('dimensionNameSelect');
            const customInput = document.getElementById('dimensionNameCustom');
            const statusEl = document.getElementById('saveStatusInline');
            const saveBtn = document.getElementById('saveDimensionBtn');
            
            let customName = '';
            
            if (nameSelect.value === 'CUSTOM') {
                customName = customInput.value.trim();
            } else if (nameSelect.value) {
                customName = nameSelect.value;
            }
            
            if (!customName) {
                statusEl.textContent = 'Please select or enter a name';
                statusEl.style.color = '#C62828';
                setTimeout(() => statusEl.textContent = '', 2000);
                return;
            }
            
            statusEl.textContent = 'Saving...';
            statusEl.style.color = '#666';
            saveBtn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/data-sources/${currentDataSourceId}/dimension-names`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        ref_key: currentEditingRefKey,
                        custom_name: customName
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save dimension name');
                }
                
                // Update local map
                dimensionNamesMap[currentEditingRefKey] = customName;
                
                // Update the dimension dropdown to show the new name
                const questionSelect = document.getElementById('questionSelect');
                const selectedOption = questionSelect.querySelector(`option[value="${currentEditingRefKey}"]`);
                if (selectedOption) {
                    selectedOption.textContent = customName;
                }
                
                statusEl.textContent = 'Saved!';
                statusEl.style.color = '#2E7D32';
                
                setTimeout(() => statusEl.textContent = '', 2000);
                
            } catch (error) {
                console.error('Error saving dimension name:', error);
                statusEl.textContent = 'Error saving';
                statusEl.style.color = '#C62828';
            } finally {
                saveBtn.disabled = false;
            }
        }
        
        // Old overlay editor functions (keeping for backwards compatibility)
        
        function handleDimensionSelectChange(selectElement, refKey) {
            const item = selectElement.closest('.dimension-editor-item');
            const customInput = item.querySelector('.dimension-custom-input');
            
            if (selectElement.value === 'CUSTOM') {
                customInput.classList.add('active');
                customInput.focus();
            } else {
                customInput.classList.remove('active');
                customInput.value = '';
            }
        }
        
        async function openDimensionEditor() {
            const overlay = document.getElementById('dimensionEditorOverlay');
            const container = document.getElementById('dimensionEditorContent');
            
            // Build editor UI
            container.innerHTML = `
                <div class="dimension-editor-header">
                    <div>
                        <h3 style="margin: 0; font-size: 16px; color: #333;">Customize Dimension Names</h3>
                        <p style="margin: 4px 0 0 0; font-size: 13px; color: #888;">
                            Select from predefined dimensions or create custom ones
                        </p>
                    </div>
                    <div class="dimension-editor-actions">
                        <button class="manage-options-btn" onclick="manageOptions()">Manage Options</button>
                        <span class="dimension-status" id="saveStatus"></span>
                        <button class="save-all-btn" onclick="saveAllDimensions()">Save All</button>
                    </div>
                </div>
                <div id="dimensionsList"></div>
            `;
            
            const list = document.getElementById('dimensionsList');
            
            // Create editor items for each dimension
            availableQuestions.forEach(refKey => {
                const item = document.createElement('div');
                item.className = 'dimension-editor-item';
                item.setAttribute('data-ref-key', refKey);
                
                const currentName = dimensionNamesMap[refKey] || '';
                
                // Determine if current name is in the predefined list or custom
                const isCustom = currentName && !dimensionOptions.includes(currentName);
                const selectedValue = isCustom ? 'CUSTOM' : currentName;
                
                // Build options HTML
                let optionsHtml = '<option value="">-- Select Dimension --</option>';
                dimensionOptions.forEach(opt => {
                    const selected = opt === currentName ? 'selected' : '';
                    optionsHtml += `<option value="${opt}" ${selected}>${opt}</option>`;
                });
                optionsHtml += '<option value="CUSTOM" ' + (isCustom ? 'selected' : '') + '>Custom...</option>';
                
                item.innerHTML = `
                    <div class="dimension-ref">${refKey.replace('ref_', 'Q')}</div>
                    <div class="dimension-controls">
                        <select 
                            class="dimension-select" 
                            data-ref-key="${refKey}"
                            onchange="handleDimensionSelectChange(this, '${refKey}')"
                        >
                            ${optionsHtml}
                        </select>
                        <input 
                            type="text" 
                            class="dimension-custom-input ${isCustom ? 'active' : ''}" 
                            placeholder="Enter custom dimension name"
                            value="${isCustom ? currentName : ''}"
                            data-ref-key="${refKey}"
                        />
                    </div>
                `;
                
                list.appendChild(item);
            });
            
            // Show overlay
            overlay.classList.add('active');
        }
        
        function closeDimensionEditor() {
            const overlay = document.getElementById('dimensionEditorOverlay');
            overlay.classList.remove('active');
        }
        
        async function saveAllDimensions() {
            const statusEl = document.getElementById('saveStatus');
            const saveBtn = document.querySelector('.save-all-btn');
            
            statusEl.textContent = 'Saving...';
            statusEl.className = 'dimension-status';
            saveBtn.disabled = true;
            
            try {
                // Collect all dimension names
                const items = document.querySelectorAll('.dimension-editor-item');
                const dimensionNames = [];
                
                items.forEach(item => {
                    const refKey = item.getAttribute('data-ref-key');
                    const select = item.querySelector('.dimension-select');
                    const customInput = item.querySelector('.dimension-custom-input');
                    
                    let customName = '';
                    
                    if (select.value === 'CUSTOM') {
                        customName = customInput.value.trim();
                    } else if (select.value) {
                        customName = select.value;
                    }
                    
                    if (customName) {
                        dimensionNames.push({
                            ref_key: refKey,
                            custom_name: customName
                        });
                    }
                });
                
                // Send batch update to API
                const response = await fetch(`${API_BASE_URL}/api/data-sources/${currentDataSourceId}/dimension-names/batch`, {
                    method: 'POST',
                    headers: {
                        ...getAuthHeaders(),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        dimension_names: dimensionNames
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save dimension names');
                }
                
                // Update local map
                await loadDimensionNames();
                
                // Update the dropdown
                await detectAndSetupQuestionFilter();
                
                statusEl.textContent = 'Saved successfully!';
                statusEl.className = 'dimension-status saved';
                
                setTimeout(() => {
                    closeDimensionEditor();
                }, 1500);
                
            } catch (error) {
                console.error('Error saving dimension names:', error);
                statusEl.textContent = 'Error saving. Please try again.';
                statusEl.className = 'dimension-status unsaved';
            } finally {
                saveBtn.disabled = false;
            }
        }
        
        function manageOptions() {
            const newOptions = prompt(
                'Manage Dimension Options\n\n' +
                'Current options:\n' + dimensionOptions.join('\n') + '\n\n' +
                'Enter new options (one per line, or leave blank to cancel):'
            );
            
            if (newOptions !== null && newOptions.trim()) {
                const lines = newOptions.trim().split('\n').map(line => line.trim()).filter(line => line);
                
                // Add new unique options
                lines.forEach(line => {
                    if (!dimensionOptions.includes(line)) {
                        dimensionOptions.push(line);
                    }
                });
                
                // Sort alphabetically
                dimensionOptions.sort();
                
                // Save to localStorage for persistence
                localStorage.setItem('dimensionOptions', JSON.stringify(dimensionOptions));
                
                alert('Options updated! Close and reopen the editor to see changes.');
            }
        }
        
        // Load dimension options from localStorage on startup
        function loadDimensionOptions() {
            const saved = localStorage.getItem('dimensionOptions');
            if (saved) {
                try {
                    dimensionOptions = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading dimension options:', e);
                }
            }
        }
        
        // Close dimension editor on backdrop click
        document.addEventListener('DOMContentLoaded', () => {
            const dimensionOverlay = document.getElementById('dimensionEditorOverlay');
            dimensionOverlay.addEventListener('click', (e) => {
                if (e.target === dimensionOverlay) {
                    closeDimensionEditor();
                }
            });
            
            // Close with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && dimensionOverlay.classList.contains('active')) {
                    closeDimensionEditor();
                }
            });
        });

        // SPA Routing Functions
        function navigateToView(viewName) {
            const vizSection = document.getElementById('visualizations-section');
            const insightsSection = document.getElementById('insights-section');
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            const mainContainer = document.getElementById('mainContainer');
            
            // Store scroll position when leaving visualizations view
            if (vizSection && vizSection.classList.contains('active') && viewName !== 'visualizations') {
                window.visualizationsScrollPosition = window.scrollY;
            }
            
            // Hide all sections - CSS class will handle the hiding
            // Also ensure they're completely removed from layout flow
            if (vizSection) {
                vizSection.classList.remove('active');
                if (!vizSection.classList.contains('active')) {
                    vizSection.style.display = 'none';
                    vizSection.style.height = '0';
                    vizSection.style.minHeight = '0';
                    vizSection.style.maxHeight = '0';
                    vizSection.style.overflow = 'hidden';
                }
            }
            if (insightsSection) {
                insightsSection.classList.remove('active');
                if (!insightsSection.classList.contains('active')) {
                    insightsSection.style.display = 'none';
                    insightsSection.style.height = '0';
                    insightsSection.style.minHeight = '0';
                    insightsSection.style.maxHeight = '0';
                    insightsSection.style.overflow = 'hidden';
                }
            }
            
            // Remove active class from all nav items
            if (navVisualizations) navVisualizations.classList.remove('active');
            if (navInsights) navInsights.classList.remove('active');
            
            // Show selected section and update nav - CSS class will handle the showing
            if (viewName === 'visualizations') {
                if (vizSection) {
                    vizSection.classList.add('active');
                    // Reset styles for active section
                    vizSection.style.display = '';
                    vizSection.style.height = '';
                    vizSection.style.minHeight = '';
                    vizSection.style.maxHeight = '';
                    vizSection.style.overflow = '';
                }
                if (navVisualizations) navVisualizations.classList.add('active');
                // Reset container min-height for visualizations (which may need full height)
                if (mainContainer) {
                    mainContainer.style.minHeight = '100vh';
                    mainContainer.removeAttribute('data-view');
                }
                
                // Recalculate treemap dimensions when switching to visualizations
                // This fixes the issue where treemap is initialized with wrong size when page loads on insights tab
                if (typeof hierarchyData !== 'undefined' && hierarchyData) {
                    // Wait for DOM to update so container is visible before measuring
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Double RAF ensures layout has completed
                            const container = document.querySelector('.treemap-svg-container');
                            if (container) {
                                const newWidth = container.clientWidth;
                                const newHeight = container.clientHeight;
                                // Only re-render if dimensions are significantly different
                                if (newWidth && newHeight && newWidth > 100 && newHeight > 100) {
                                    const svg = document.getElementById('treemap');
                                    if (svg) {
                                        const currentWidth = parseInt(svg.getAttribute('width')) || 0;
                                        const currentHeight = parseInt(svg.getAttribute('height')) || 0;
                                        // Re-render if dimensions don't match (with some tolerance)
                                        if (Math.abs(newWidth - currentWidth) > 10 || Math.abs(newHeight - currentHeight) > 10) {
                                            console.log('[navigateToView] Re-rendering treemap with correct dimensions:', {
                                                old: { width: currentWidth, height: currentHeight },
                                                new: { width: newWidth, height: newHeight }
                                            });
                                            if (typeof renderTreemap === 'function') {
                                                renderTreemap(hierarchyData);
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    });
                }
                
                // Restore scroll position if it was previously saved
                if (window.visualizationsScrollPosition !== undefined) {
                    requestAnimationFrame(() => {
                        window.scrollTo({ top: window.visualizationsScrollPosition, behavior: 'auto' });
                    });
                }
            } else if (viewName === 'insights') {
                // Sync insightsCurrentClientId with currentClientId when navigating to insights
                if (currentClientId && insightsCurrentClientId !== currentClientId) {
                    insightsCurrentClientId = currentClientId;
                }
                
                if (insightsSection) {
                    insightsSection.classList.add('active');
                    // Reset styles for active section
                    insightsSection.style.display = '';
                    insightsSection.style.height = '';
                    insightsSection.style.minHeight = '';
                    insightsSection.style.maxHeight = '';
                    insightsSection.style.overflow = '';
                }
                if (navInsights) navInsights.classList.add('active');
                // Remove min-height constraint for insights to allow natural sizing
                if (mainContainer) {
                    mainContainer.style.minHeight = 'auto';
                    mainContainer.style.height = 'auto';
                    mainContainer.setAttribute('data-view', 'insights');
                }
                
                // Reload insights for the current client
                // Reset the initialized flag to force reload with current client data
                window.insightsInitialized = false;
                if (typeof initInsightsPage === 'function') {
                    initInsightsPage();
                }
                
                // Scroll to top to ensure insights section is visible
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // Also scroll the container if it's scrollable
                if (mainContainer && mainContainer.scrollTop > 0) {
                    mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
                }
                // Initialize insights page if not already loaded
                if (typeof initInsightsPage === 'function' && !window.insightsInitialized) {
                    initInsightsPage();
                }
            }
            
            // Update URL hash without reload
            const urlParams = new URLSearchParams(window.location.search);
            const hash = viewName === 'visualizations' ? '#/' : '#/insights';
            const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '') + hash;
            window.history.pushState({ view: viewName }, '', newUrl);
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else {
                navigateToView('visualizations');
            }
        });
        
        // Handle hash changes (for direct navigation)
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else {
                navigateToView('visualizations');
            }
        });
        
        // Set active navigation item based on current route
        function setActiveNavItem() {
            const hash = window.location.hash;
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            
            // Remove active class from all items
            if (navVisualizations) navVisualizations.classList.remove('active');
            if (navInsights) navInsights.classList.remove('active');
            
            // Set active based on hash
            if (hash === '#/insights' || hash === '#/insights') {
                if (navInsights) navInsights.classList.add('active');
            } else {
                // Default to visualizations
                if (navVisualizations) navVisualizations.classList.add('active');
            }
        }

        // Update navigation links to include current context
        function updateNavLinks() {
            const urlParams = new URLSearchParams(window.location.search);
            const clientUuid = urlParams.get('client_uuid') || currentClientId;
            const authToken = getAuthToken() || localStorage.getItem('visualizd_auth_token');
            
            // Get current visualization state to preserve it in navigation
            const currentProject = urlParams.get('project') || currentProjectName;
            const currentSource = urlParams.get('source') || currentDataSourceId;
            const currentDimension = urlParams.get('dimension') || currentQuestionRefKey;
            
            const navVisualizations = document.getElementById('navVisualizations');
            const navInsights = document.getElementById('navInsights');
            
            if (navVisualizations) {
                let vizUrl = '/';
                const vizParams = new URLSearchParams();
                if (clientUuid) {
                    vizParams.set('client_uuid', clientUuid);
                }
                if (authToken) {
                    vizParams.set('auth_token', authToken);
                }
                // Preserve visualization state when navigating back
                if (currentProject) {
                    vizParams.set('project', currentProject);
                }
                if (currentSource) {
                    vizParams.set('source', currentSource);
                }
                if (currentDimension) {
                    vizParams.set('dimension', currentDimension);
                }
                if (vizParams.toString()) {
                    vizUrl += `?${vizParams.toString()}`;
                }
                navVisualizations.href = vizUrl;
            }
            
            if (navInsights) {
                // Use SPA hash routing instead of separate page
                navInsights.href = '#';
                navInsights.onclick = (e) => {
                    e.preventDefault();
                    navigateToView('insights');
                    return false;
                };
            }
        }


        // Start the application - check auth first
        console.log('Starting application...');
        
        // Quick synchronous check - if no token, show login immediately to avoid flash
        const token = typeof Auth !== 'undefined' ? Auth.getAuthToken() : null;
        if (!token) {
            console.log('No token found, showing login immediately');
            if (typeof Auth !== 'undefined') {
                Auth.showLogin();
            } else {
                document.getElementById('loginOverlay').classList.remove('hidden');
            }
        }
        // If token exists, keep login hidden (it's already hidden by default)
        // and let async checkAuth() verify it
        
        // Initialize navigation when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setActiveNavItem();
                updateNavLinks();
                // Check hash on page load for routing
                const hash = window.location.hash;
                if (hash === '#/insights' || hash === '#/insights') {
                    navigateToView('insights');
                } else {
                    navigateToView('visualizations');
                }
            });
        } else {
            setActiveNavItem();
            updateNavLinks();
            // Check hash on page load for routing
            const hash = window.location.hash;
            if (hash === '#/insights') {
                navigateToView('insights');
            } else {
                navigateToView('visualizations');
            }
        }

        // Insights Page JavaScript
        let insightsCurrentClientId = null;
        let insightsCurrentInsightId = null;
        let insightsFilters = []; // Changed to array to support multiple filters
        let insightsCurrentSortBy = 'name';
        let insightsSortOrder = 'asc';
        let insightsSearchTerm = '';
        let insightsAllInsights = [];
        let insightsCurrentInsightEditor = null;
        // Get storage key scoped by client ID for filter persistence
        function getFilterStorageKey() {
            const clientId = insightsCurrentClientId || currentClientId || 'global';
            return `insights_filters_${clientId}`;
        }
        
        // Available filter fields
        const FILTER_FIELDS = [
            { id: 'status', label: 'Status', icon: '', type: 'select' },
            { id: 'project', label: 'Project', icon: '', type: 'select' },
            { id: 'data_source', label: 'Data Source', icon: '', type: 'select' },
            { id: 'created_at', label: 'Created', icon: '', type: 'date' }
        ];
        let insightsCurrentInsightNotesId = null;
        let insightsCurrentInsightData = null;
        let insightsSaveNotesTimeout = null;
        let insightsFieldSaveTimeout = null;
        let insightsEditorContextMenuHandlers = null;
        let selectedInsightIds = new Set();
        window.insightsInitialized = false;

        function getAuthHeadersSafe() {
            console.log('[DEBUG] getAuthHeadersSafe called');
            let headers = {};
            
            if (typeof getAuthHeaders !== 'undefined') {
                console.log('[DEBUG] getAuthHeaders function exists, calling it');
                headers = getAuthHeaders();
                console.log('[DEBUG] getAuthHeaders returned:', Object.keys(headers));
                if (headers.Authorization || headers.authorization) {
                    console.log('[DEBUG] Using headers from getAuthHeaders');
                    return headers;
                }
            } else {
                console.log('[DEBUG] getAuthHeaders function is undefined');
            }
            
            const token = localStorage.getItem('visualizd_auth_token');
            console.log('[DEBUG] Token from localStorage:', token ? 'exists (' + token.substring(0, 20) + '...)' : 'not found');
            if (token) {
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
                console.log('[DEBUG] Using token from localStorage');
                return headers;
            }
            
            console.warn('[DEBUG] No auth token found, returning headers without Authorization');
            return { 'Content-Type': 'application/json' };
        }

        async function initInsightsPage() {
            // Check if already initialized - this is reset to false when navigating to allow reload
            if (window.insightsInitialized) {
                return;
            }
            
            // Wait for auth to be available
            let attempts = 0;
            while (typeof getAuthHeaders === 'undefined' && attempts < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            const urlParams = new URLSearchParams(window.location.search);
            insightsCurrentClientId = urlParams.get('client_uuid') || currentClientId;
            
            const authTokenFromUrl = urlParams.get('auth_token');
            if (authTokenFromUrl) {
                console.log('[DEBUG] Found auth_token in URL, storing in localStorage');
                localStorage.setItem('visualizd_auth_token', authTokenFromUrl);
            }

            if (!insightsCurrentClientId) {
                // Wait for currentClientId to be set (with timeout)
                let retryAttempts = 0;
                const maxRetries = 50; // 5 seconds max wait
                while (!currentClientId && retryAttempts < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retryAttempts++;
                }
                
                if (currentClientId) {
                    insightsCurrentClientId = currentClientId;
                } else {
                    console.error('[DEBUG] currentClientId never became available');
                    const tbody = document.getElementById('insightsTableBody') || document.getElementById('insightsPageTableBody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>No client specified</h3><p style="font-size: 12px; color: #999;">Please select a client first</p></td></tr>';
                    }
                    window.insightsInitialized = true;
                    return;
                }
            }

            console.log('[DEBUG] Client ID is valid, proceeding to load insights...');
            
            // Load filters from storage on initialization
            loadFiltersFromStorage();
            
            // Update filter UI to reflect loaded filters
            updateFilterChips();
            updateActiveFiltersDisplay();
            
            await loadInsightsPage();
            window.insightsInitialized = true;
        }
        
        // Close filter dropdown when clicking outside
        // Use a small delay to allow button click to process first
        document.addEventListener('click', (e) => {
            setTimeout(() => {
                // Get the dropdown and button from the insights-section
                const insightsSection = document.getElementById('insights-section');
                const dropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
                const btn = document.getElementById('filterMenuBtn');
                
                if (dropdown && btn) {
                    // Check if click is outside both dropdown and button
                    const clickedInsideDropdown = dropdown.contains(e.target);
                    const clickedInsideButton = btn.contains(e.target);
                    
                    // Check if dropdown is visible (either has 'active' class or display is not 'none')
                    const isDropdownVisible = dropdown.classList.contains('active') || 
                                             (dropdown.style.display !== 'none' && 
                                              window.getComputedStyle(dropdown).display !== 'none');
                    
                    if (!clickedInsideDropdown && !clickedInsideButton && isDropdownVisible) {
                        dropdown.classList.remove('active');
                        dropdown.style.display = 'none';
                        console.log('[DEBUG click-outside] Closed main filter dropdown');
                    }
                }
                
                // Close inline filter dropdowns when clicking outside
                // But don't close if we just created one (give it a moment)
                document.querySelectorAll('.inline-filter-dropdown').forEach(inlineDropdown => {
                    // Check if this dropdown was just created (has a data-just-created attribute)
                    const justCreated = inlineDropdown.getAttribute('data-just-created') === 'true';
                    if (justCreated) {
                        // Remove the flag after a short delay
                        setTimeout(() => {
                            inlineDropdown.removeAttribute('data-just-created');
                        }, 100);
                        return; // Don't close it if it was just created
                    }
                    
                    if (!inlineDropdown.contains(e.target)) {
                        const header = inlineDropdown.querySelector('.inline-filter-header');
                        const options = inlineDropdown.querySelector('.inline-filter-options');
                        if (header && options && options.classList.contains('open')) {
                            console.log('[DEBUG click-outside] Closing inline filter dropdown');
                            header.classList.remove('open');
                            options.classList.remove('open');
                            options.style.display = 'none';
                        }
                    }
                });
            }, 10);
        });

        async function loadInsightsPage() {
            
            if (!insightsCurrentClientId) {
                console.error('[DEBUG] No client ID, cannot load insights');
                return;
            }

            const tbody = document.getElementById('insightsPageTableBody');
            if (!tbody) {
                console.error('[DEBUG] insightsPageTableBody element not found');
                return;
            }
            
            console.log('[DEBUG] Table body element found, showing loading state');
            tbody.innerHTML = '<tr><td colspan="9" class="loading">Loading insights...</td></tr>';

            try {
                // Map 'origin' to 'created_at' for backend sorting (backend doesn't support project sorting)
                // We'll sort by origin client-side after loading
                const backendSortBy = insightsCurrentSortBy === 'origin' ? 'created_at' : 
                                     insightsCurrentSortBy === 'name' ? 'name' : 
                                     insightsCurrentSortBy === 'created_at' ? 'created_at' : 'created_at';
                
                const params = new URLSearchParams({
                    page: '1',
                    page_size: '1000',
                    sort_by: backendSortBy,
                    sort_order: insightsSortOrder,
                });

                Object.entries(insightsFilters).forEach(([key, value]) => {
                    if (value) {
                        params.append(key, value);
                    }
                });

                const headers = getAuthHeadersSafe();
                const url = `${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights?${params.toString()}`;
                
                const response = await fetch(url, { headers });

                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Authentication required. Please log in.');
                    }
                    throw new Error(`Failed to load insights: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                insightsAllInsights = data.items || [];
                
                // Sort by origin client-side if needed (backend doesn't support project sorting)
                if (insightsCurrentSortBy === 'origin') {
                    insightsAllInsights.sort((a, b) => {
                        const aOrigin = a.origins?.[0] || {};
                        const bOrigin = b.origins?.[0] || {};
                        const aProject = aOrigin.project_name || '';
                        const bProject = bOrigin.project_name || '';
                        const aDimension = aOrigin.dimension_name || aOrigin.dimension_ref || '';
                        const bDimension = bOrigin.dimension_name || bOrigin.dimension_ref || '';
                        
                        // Sort by project first, then dimension
                        const projectCompare = aProject.localeCompare(bProject);
                        if (projectCompare !== 0) {
                            return insightsSortOrder === 'asc' ? projectCompare : -projectCompare;
                        }
                        const dimensionCompare = aDimension.localeCompare(bDimension);
                        return insightsSortOrder === 'asc' ? dimensionCompare : -dimensionCompare;
                    });
                }
                
                // Restore visible filter dropdowns after loading insights (so we have data for dropdown options)
                restoreFilterDropdowns();
                
                renderInsightsPage();
            } catch (error) {
                console.error('Error loading insights:', error);
                const errorTbody = document.getElementById('insightsPageTableBody');
                if (errorTbody) {
                    const errorMessage = error.message || 'Unknown error occurred';
                    errorTbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>Error loading insights</h3><p>' + escapeHtml(errorMessage) + '</p></td></tr>';
                }
            }
        }

        function renderInsightsPage() {
            const tbody = document.getElementById('insightsPageTableBody');
            if (!tbody) return;
            
            let filtered = [...insightsAllInsights];
            
            // Apply search
            if (insightsSearchTerm) {
                const term = insightsSearchTerm.toLowerCase();
                filtered = filtered.filter(insight => 
                    insight.name?.toLowerCase().includes(term) ||
                    insight.description?.toLowerCase().includes(term)
                );
            }
            
            // Apply filters
            if (insightsFilters && insightsFilters.length > 0) {
                filtered = filtered.filter(insight => {
                    return insightsFilters.every(filter => {
                        let insightValue = null;
                        
                        if (filter.field === 'status') {
                            insightValue = insight.status || 'Not Started';
                        } else if (filter.field === 'project' || filter.field === 'data_source') {
                            const firstOrigin = insight.origins?.[0] || {};
                            if (filter.field === 'project') {
                                insightValue = firstOrigin.project_name || '-';
                            } else if (filter.field === 'data_source') {
                                insightValue = firstOrigin.data_source || '-';
                            }
                        } else if (filter.field === 'created_at') {
                            const createdDate = new Date(insight.created_at);
                            const now = new Date();
                            let periodStart = null;
                            let periodEnd = null;
                            
                            if (filter.value === 'today') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
                            } else if (filter.value === 'yesterday') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                            } else if (filter.value === 'this_week') {
                                const dayOfWeek = now.getDay();
                                periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek + 7);
                            } else if (filter.value === 'this_month') {
                                periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);
                            } else if (filter.value === 'last_month') {
                                periodStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                                periodEnd = new Date(now.getFullYear(), now.getMonth(), 1);
                            }
                            
                            if (periodStart && periodEnd) {
                                return createdDate >= periodStart && createdDate < periodEnd;
                            }
                            return false;
                        }
                        
                        if (filter.operator === 'equals') {
                            return String(insightValue) === String(filter.value);
                        }
                        return false;
                    });
                });
                console.log('[DEBUG] After filters:', filtered.length, 'insights remain');
            }

            if (filtered.length === 0) {
                // Calculate colspan: 1 for checkbox + number of columns
                const columnCount = getColumnOrder().length;
                tbody.innerHTML = `<tr><td colspan="${columnCount + 1}" class="empty-state"><h3>No insights found</h3><p>Create your first insight to get started</p></td></tr>`;
                return;
            }

            const renderedHTML = filtered.map((insight, index) => {
                const currentStatus = insight.status || 'Not Started';
                const createdDate = new Date(insight.created_at).toLocaleDateString();
                const firstOrigin = insight.origins?.[0] || {};
                const projectName = firstOrigin.project_name || null;
                const dataSource = firstOrigin.data_source || null;
                const dimensionName = firstOrigin.dimension_name || null;
                const dimensionRef = firstOrigin.dimension_ref || null;
                const categoryName = firstOrigin.category || null;
                const topicName = firstOrigin.topic_label || null;
                const insightName = toPascalCase(insight.name || '');
                const highlightedInsightName = insightsSearchTerm ? highlightSearchTerms(insightName, insightsSearchTerm) : escapeHtml(insightName);
                
                // Build origin breadcrumb pills with PascalCase formatting
                const originPills = [];
                if (projectName) {
                    const pascalProject = toPascalCase(projectName);
                    originPills.push(`<span class="tag tag-project insight-origin-pill" data-origin-type="project" data-project-name="${escapeHtml(projectName)}" onclick="event.stopPropagation(); navigateToProjectFromInsight('${escapeHtml(projectName)}')" style="cursor: pointer;">${escapeHtml(pascalProject)}</span>`);
                }
                if (dimensionName && dimensionRef) {
                    const pascalDimension = toPascalCase(dimensionName);
                    originPills.push(`<span class="tag tag-data-source insight-origin-pill" data-origin-type="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtml(dimensionName)}" data-data-source="${dataSource || ''}" onclick="event.stopPropagation(); navigateToDimensionFromInsight('${dimensionRef}', '${escapeHtml(dimensionName)}', '${dataSource || ''}')" style="cursor: pointer;">${escapeHtml(pascalDimension)}</span>`);
                } else if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    originPills.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDimension)}</span>`);
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    originPills.push(`<span class="tag tag-category insight-origin-pill" data-origin-type="category" data-category="${escapeHtml(categoryName)}" data-topic="${topicName ? escapeHtml(topicName) : ''}" data-data-source="${dataSource || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" onclick="event.stopPropagation(); navigateToCategoryFromInsight('${escapeHtml(categoryName)}', '${topicName ? escapeHtml(topicName) : ''}', '${dataSource || ''}', '${dimensionRef || ''}')" style="cursor: pointer;">${escapeHtml(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    originPills.push(`<span class="tag tag-topic insight-origin-pill" data-origin-type="topic" data-category="${categoryName ? escapeHtml(categoryName) : ''}" data-topic="${escapeHtml(topicName)}" data-data-source="${dataSource || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" onclick="event.stopPropagation(); navigateToTopicFromInsight('${escapeHtml(topicName)}', '${categoryName ? escapeHtml(categoryName) : ''}', '${dataSource || ''}', '${dimensionRef || ''}')" style="cursor: pointer;">${escapeHtml(pascalTopic)}</span>`);
                }
                
                const originContent = originPills.length > 0 
                    ? originPills.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '-';
                
                // Build cells in default order, we'll reorder them after rendering
                const cells = {
                    name: `<td class="name-cell" data-column="name">
                        <div class="name-content" style="position: relative;">
                            <svg class="doc-icon" viewBox="0 0 16 16" fill="currentColor">
                                <path d="M2.5 2.5h11l.5.5v10l-.5.5h-11l-.5-.5V3l.5-.5zM3 4v8h10V4H3zm2 1h6v1H5V5zm0 2h6v1H5V7zm0 2h4v1H5V9z"/>
                            </svg>
                            <span>${highlightedInsightName}</span>
                            <button class="insight-open-btn-table" onclick="openInsightNotes('${insight.id}')" title="Open in side peek" style="display: none;">
                                <span style="font-size: 12px; margin-right: 4px;">OPEN</span>
                                <svg width="14" height="14" viewBox="0 0 16 16" fill="none" style="opacity: 0.6;">
                                    <rect x="4" y="4" width="8" height="8" stroke="currentColor" stroke-width="1.5" fill="none" rx="1"/>
                                    <path d="M6 2 L6 6 M10 2 L10 6 M2 6 L2 10 M2 6 L6 6 M10 6 L14 6 M14 6 L14 10" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                </svg>
                            </button>
                        </div>
                    </td>`,
                    status: `<td data-column="status">
                        <select class="status-select" 
                                onchange="console.log('[DEBUG status-select onchange] Triggered for insight:', '${insight.id}', 'new value:', this.value); updateInsightStatus('${insight.id}', this.value)" 
                                onclick="event.stopPropagation()"
                                data-insight-id="${insight.id}"
                                data-current-status="${insight.status || 'Not Started'}">
                            <option value="Not Started" ${(insight.status || 'Not Started') === 'Not Started' ? 'selected' : ''}>Not Started</option>
                            <option value="Queued" ${(insight.status || 'Not Started') === 'Queued' ? 'selected' : ''}>Queued</option>
                            <option value="Design" ${(insight.status || 'Not Started') === 'Design' ? 'selected' : ''}>Design</option>
                            <option value="Development" ${(insight.status || 'Not Started') === 'Development' ? 'selected' : ''}>Development</option>
                            <option value="QA" ${(insight.status || 'Not Started') === 'QA' ? 'selected' : ''}>QA</option>
                            <option value="Testing" ${(insight.status || 'Not Started') === 'Testing' ? 'selected' : ''}>Testing</option>
                            <option value="Win" ${(insight.status || 'Not Started') === 'Win' ? 'selected' : ''}> Win</option>
                            <option value="Disproved" ${(insight.status || 'Not Started') === 'Disproved' ? 'selected' : ''}>Disproved</option>
                        </select>
                    </td>`,
                    origin: `<td data-column="origin" style="white-space: nowrap;">
                        ${originContent}
                    </td>`,
                    created_at: `<td data-column="created_at">${createdDate}</td>`
                };
                
                // Get column order
                const columnOrder = getColumnOrder();
                
                // Build row HTML in the correct order
                const orderedCells = columnOrder.map(col => cells[col] || '').filter(cell => cell);
                const checkboxCell = `<td class="checkbox-cell" onclick="event.stopPropagation(); const checkbox = this.querySelector('.insight-checkbox'); if (checkbox && !event.target.matches('.insight-checkbox')) { checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change')); }">
                    <input type="checkbox" class="insight-checkbox" data-insight-id="${insight.id}" onchange="handleInsightCheckboxChange()" onclick="event.stopPropagation()">
                </td>`;
                
                return `<tr data-insight-id="${insight.id}" onclick="openInsightNotes('${insight.id}')" style="cursor: pointer;">${checkboxCell}${orderedCells.join('')}</tr>`;
            }).join('');
            
            tbody.innerHTML = renderedHTML;
            
            // Clear checkbox selections when table is re-rendered
            selectedInsightIds.clear();
            updateInsightsDeleteButton();
            updateSelectAllCheckbox();
            
            // Apply saved column order and initialize drag and drop
            setTimeout(() => {
                if (typeof applyColumnOrder === 'function') {
                    applyColumnOrder();
                }
                if (typeof initializeColumnDragAndDrop === 'function') {
                    initializeColumnDragAndDrop();
                }
            }, 0);
        }

        function sortBy(column) {
            // Update sort indicators
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('sorted');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            });
            
            const clickedTh = event.currentTarget;
            clickedTh.classList.add('sorted');
            const indicator = clickedTh.querySelector('.sort-indicator');
            
            if (insightsCurrentSortBy === column) {
                insightsSortOrder = insightsSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                insightsCurrentSortBy = column;
                insightsSortOrder = 'asc';
            }
            
            if (indicator) {
                indicator.textContent = insightsSortOrder === 'asc' ? '' : '';
            }
            
            loadInsightsPage();
        }

        // Helper function to convert text to PascalCase
        function toPascalCase(text) {
            if (!text) return '';
            return text
                .split(/[\s_-]+/)
                .map(word => {
                    // Keep US and USA as uppercase (case-insensitive check)
                    const upperWord = word.toUpperCase();
                    if (upperWord === 'US' || upperWord === 'USA') {
                        return upperWord;
                    }
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                })
                .join(' ');
        }

        // Navigation functions for origin breadcrumb pills
        function navigateToProjectFromInsight(projectName) {
            console.log('[InsightOriginNav] Navigating to project:', projectName);
            // Navigate to visualizations view
            navigateToView('visualizations');
            
            // Set the project selector
            const projectSelect = document.getElementById('projectSelect');
            if (projectSelect && projectSelect.value !== projectName) {
                projectSelect.value = projectName;
                // Trigger change event to load sources
                const changeEvent = new Event('change', { bubbles: true });
                projectSelect.dispatchEvent(changeEvent);
            } else if (projectSelect) {
                // Project already selected, just ensure we're on visualizations
                currentProjectName = projectName;
            }
        }

        async function navigateToDimensionFromInsight(dimensionRef, dimensionName, dataSource) {
            console.log('[InsightOriginNav] Navigating to dimension:', dimensionRef, dimensionName, 'dataSource:', dataSource);
            
            // Navigate to visualizations view
            navigateToView('visualizations');
            
            // Ensure we're on the correct data source before selecting dimension
            if (dataSource) {
                await ensureContextForInsightNavigation(dataSource, dimensionRef);
            } else {
                // If no data source specified, just switch dimension
                const questionSelect = document.getElementById('questionSelect');
                if (questionSelect) {
                    const previousRefKey = currentQuestionRefKey;
                    questionSelect.value = dimensionRef;
                    currentQuestionRefKey = dimensionRef;
                    
                    // Filter by this dimension
                    filterByQuestion(dimensionRef, previousRefKey);
                    
                    // Update navigation links
                    updateNavLinks();
                    
                    // Update AI Insights panel with current dimension
                    if (window.AIInsightsPanel) {
                        window.AIInsightsPanel.setCurrentDimension(dimensionRef);
                    }
                }
            }
        }

        // Helper function to ensure correct data source and dimension are selected before navigation
        async function ensureContextForInsightNavigation(dataSource, dimensionRef) {
            let needsDataSourceSwitch = false;
            let needsDimensionSwitch = false;
            
            // Check if data source needs to change
            if (dataSource && dataSource !== currentDataSourceId) {
                needsDataSourceSwitch = true;
            }
            
            // Check if dimension needs to change
            if (dimensionRef && dimensionRef !== currentQuestionRefKey) {
                needsDimensionSwitch = true;
            }
            
            // Switch data source if needed
            if (needsDataSourceSwitch) {
                console.log('[InsightOriginNav] Switching data source from', currentDataSourceId, 'to', dataSource);
                currentDataSourceId = dataSource;
                currentQuestionRefKey = null; // Reset dimension when switching data source
                dimensionFilters = {}; // Clear dimension filters
                saveState();
                updateNavLinks();
                
                // Update the data source dropdown UI
                const sourceSelect = document.getElementById('sourceSelect');
                if (sourceSelect) {
                    sourceSelect.value = dataSource;
                    console.log('[InsightOriginNav] Updated source dropdown to:', dataSource);
                }
                
                // Load the new data source - this will call detectAndSetupQuestionFilter
                // which loads availableQuestions, so we need to wait for it to complete
                await loadDataSource(currentClientId, currentDataSourceId);
                
                // Wait a bit for the question filter to be set up and availableQuestions to be populated
                // We'll check multiple times with a short delay
                let attempts = 0;
                const maxAttempts = 10;
                while (attempts < maxAttempts && (!availableQuestions || availableQuestions.length === 0)) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                // After loading, check if we still need to switch dimension
                if (dimensionRef) {
                    needsDimensionSwitch = true;
                }
            }
            
            // Switch dimension if needed
            if (needsDimensionSwitch && dimensionRef) {
                console.log('[InsightOriginNav] Switching dimension from', currentQuestionRefKey, 'to', dimensionRef);
                const questionSelect = document.getElementById('questionSelect');
                if (questionSelect) {
                    // Check if the dimension is available
                    // Wait a bit more if availableQuestions is not yet populated
                    let attempts = 0;
                    const maxAttempts = 10;
                    while (attempts < maxAttempts && (!availableQuestions || availableQuestions.length === 0)) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (availableQuestions && availableQuestions.includes(dimensionRef)) {
                        const previousRefKey = currentQuestionRefKey;
                        questionSelect.value = dimensionRef;
                        currentQuestionRefKey = dimensionRef;
                        filterByQuestion(dimensionRef, previousRefKey);
                        
                        // Update AI Insights panel
                        if (window.AIInsightsPanel) {
                            window.AIInsightsPanel.setCurrentDimension(dimensionRef);
                        }
                    } else {
                        console.warn('[InsightOriginNav] Dimension', dimensionRef, 'not available in current data source. Available:', availableQuestions);
                    }
                }
            }
        }

        async function navigateToCategoryFromInsight(categoryName, topicName, dataSource, dimensionRef) {
            console.log('[InsightOriginNav] Navigating to category:', categoryName, topicName, dataSource, dimensionRef);
            
            // Ensure we're in the correct context (data source and dimension)
            await ensureContextForInsightNavigation(dataSource, dimensionRef);
            
            // Use slideout to show chart view
            if (window.SlideoutPanel) {
                const dimensionName = dimensionRef ? getDimensionDisplayName(dimensionRef) : null;
                window.SlideoutPanel.navigateToChart(categoryName, topicName, null, dimensionName);
            }
        }

        async function navigateToTopicFromInsight(topicName, categoryName, dataSource, dimensionRef) {
            console.log('[InsightOriginNav] Navigating to topic:', topicName, categoryName, dataSource, dimensionRef);
            
            // Ensure we're in the correct context (data source and dimension)
            await ensureContextForInsightNavigation(dataSource, dimensionRef);
            
            // Use slideout to show verbatims directly
            if (window.SlideoutPanel) {
                // Get verbatims from chart data (now that we're in the correct context)
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                }
                
                console.log('[InsightOriginNav] Found', verbatims.length, 'verbatims for topic', topicName);
                
                // Navigate to verbatims view
                window.SlideoutPanel.openVerbatims(verbatims, topicName, categoryName);
            }
        }

        function handleSearch() {
            const searchInput = document.getElementById('searchInput');
            insightsSearchTerm = searchInput?.value.trim() || '';
            updateInsightsSectionSearchClearButton();
            renderInsightsPage();
        }

        function updateInsightsSectionSearchClearButton() {
            const searchInput = document.getElementById('searchInput');
            const clearButton = document.getElementById('insightsSectionSearchClear');
            if (!searchInput || !clearButton) return;

            clearButton.style.display = searchInput.value.trim() ? 'flex' : 'none';
        }

        function clearInsightsSectionSearch() {
            const searchInput = document.getElementById('searchInput');
            if (!searchInput) return;

            searchInput.value = '';
            insightsSearchTerm = '';
            updateInsightsSectionSearchClearButton();
            renderInsightsPage();
            searchInput.focus();
        }

        function updateFilterChips() {
            const chipsContainer = document.getElementById('filterChips');
            const badge = document.getElementById('insightsListFilterBadge');
            const hasFilters = insightsFilters && insightsFilters.length > 0;
            
            // Update filter badge
            if (badge) {
                if (hasFilters) {
                    badge.style.display = 'flex';
                    badge.textContent = insightsFilters.length;
                } else {
                    badge.style.display = 'none';
                }
            }
            
            // Don't render filter chips - filters are shown as checkboxes in the dropdown
            if (chipsContainer) {
                chipsContainer.innerHTML = '';
            }
        }

        function removeFilter(key) {
            // Legacy support - remove by field key
            insightsFilters = insightsFilters.filter(f => f.field !== key);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }

        function resetFilters() {
            insightsFilters = [];
            insightsSearchTerm = '';
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            updateInsightsSectionSearchClearButton();
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }

        // Load filters from localStorage (scoped by client ID)
        function loadFiltersFromStorage() {
            const storageKey = getFilterStorageKey();
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    insightsFilters = JSON.parse(saved);
                } catch (e) {
                    console.warn('Failed to parse saved filters:', e);
                    insightsFilters = [];
                }
            } else {
                insightsFilters = [];
            }
        }
        
        // Save filters to localStorage (scoped by client ID)
        function saveFiltersToStorage() {
            const storageKey = getFilterStorageKey();
            localStorage.setItem(storageKey, JSON.stringify(insightsFilters));
        }
        
        // Restore visible filter dropdowns for active filters
        function restoreFilterDropdowns() {
            if (!insightsFilters || insightsFilters.length === 0) {
                return;
            }
            
            // Get unique field IDs from active filters
            const activeFieldIds = new Set(insightsFilters.map(f => f.field));
            
            // Create dropdown UI for each active filter field
            activeFieldIds.forEach(fieldId => {
                // Check if dropdown already exists
                const existingDropdown = document.getElementById(`inline-filter-${fieldId}`);
                if (!existingDropdown) {
                    // Create the dropdown UI - but start with it closed
                    const field = FILTER_FIELDS.find(f => f.id === fieldId);
                    if (!field) return;
                    
                    // Get unique values for this field from insights
                    const values = field.type === 'select' ? getUniqueFieldValues(fieldId) : [];
                    
                    // Create inline filter dropdown
                    const filterChipsContainer = document.getElementById('filterChips');
                    if (!filterChipsContainer) return;
                    
                    const inlineFilter = document.createElement('div');
                    inlineFilter.className = 'inline-filter-dropdown';
                    inlineFilter.id = `inline-filter-${fieldId}`;
                    
                    let optionsHTML = '';
                    if (field.type === 'select') {
                        optionsHTML = values.map(value => {
                            const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                            const escapedValue = escapeHtml(value);
                            return `
                                <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                                     data-filter-value="${escapedValue}"
                                     onclick="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                                    <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} 
                                           data-filter-value="${escapedValue}"
                                           onclick="event.stopPropagation()" 
                                           onchange="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                                    <span>${escapedValue || '(empty)'}</span>
                                </div>
                            `;
                        }).join('');
                    } else if (field.type === 'date') {
                        const dateOptions = [
                            { value: 'today', label: 'Today' },
                            { value: 'yesterday', label: 'Yesterday' },
                            { value: 'this_week', label: 'This week' },
                            { value: 'this_month', label: 'This month' },
                            { value: 'last_month', label: 'Last month' }
                        ];
                        optionsHTML = dateOptions.map(opt => {
                            const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === opt.value);
                            return `
                                <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                                     onclick="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                                    <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation()" onchange="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                                    <span>${opt.label}</span>
                                </div>
                            `;
                        }).join('');
                    }
                    
                    // Create dropdown with closed state initially
                    inlineFilter.innerHTML = `
                        <div class="inline-filter-header" onclick="toggleInlineFilterDropdown('${fieldId}', event)">
                            <span class="inline-filter-icon">${field.icon}</span>
                            <span class="inline-filter-label">${field.label}</span>
                            <span class="inline-filter-chevron"></span>
                        </div>
                        <div class="inline-filter-options" style="display: none;">
                            ${optionsHTML}
                        </div>
                        <div class="inline-filter-remove" onclick="event.stopPropagation(); removeInlineFilter('${fieldId}')" title="Remove filter"></div>
                    `;
                    
                    // Insert before the filter button container
                    const filterButtonContainer = filterChipsContainer.nextElementSibling;
                    if (filterButtonContainer && filterButtonContainer.parentNode) {
                        filterButtonContainer.parentNode.insertBefore(inlineFilter, filterButtonContainer);
                    } else {
                        filterChipsContainer.parentNode.appendChild(inlineFilter);
                    }
                    
                    // Update header to show selected filter values
                    updateInlineFilterHeader(fieldId);
                } else {
                    // Update existing dropdown checkboxes to reflect current filter state
                    updateInlineFilterOptions(fieldId);
                }
            });
        }
        
        // Toggle filter menu
        function toggleFilterMenu(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            // Find the dropdown in the insights section (not the insights panel)
            const insightsSection = document.getElementById('insights-section');
            const dropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
            console.log('[DEBUG] toggleFilterMenu called, dropdown:', dropdown);
            if (dropdown) {
                const wasActive = dropdown.classList.contains('active');
                // Close all other dropdowns first
                document.querySelectorAll('.filter-dropdown.active').forEach(d => {
                    if (d !== dropdown) {
                        d.classList.remove('active');
                        d.style.display = 'none';
                    }
                });
                
                // Toggle this dropdown
                if (wasActive) {
                    dropdown.classList.remove('active');
                    dropdown.style.display = 'none';
                } else {
                    dropdown.classList.add('active');
                    dropdown.style.display = 'block';
                    populateFilterOptions();
                    updateActiveFiltersDisplay();
                    // Focus search input
                    setTimeout(() => {
                        const searchInput = document.getElementById('filterSearchInput');
                        if (searchInput) searchInput.focus();
                    }, 100);
                }
                console.log('[DEBUG] Dropdown active state:', dropdown.classList.contains('active'), 'display:', dropdown.style.display);
            } else {
                console.error('[DEBUG] filterDropdown element not found!');
            }
        }
        
        // Populate filter options list
        function populateFilterOptions() {
            const list = document.getElementById('filterOptionsList');
            if (!list) return;
            
            list.innerHTML = FILTER_FIELDS.map(field => {
                return `
                    <div class="filter-option" onclick="event.stopPropagation(); event.preventDefault(); openFilterValueDialog('${field.id}')">
                        <div class="filter-option-icon">${field.icon}</div>
                        <div class="filter-option-text">${field.label}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Filter filter options based on search
        function filterFilterOptions() {
            const searchInput = document.getElementById('filterSearchInput');
            const list = document.getElementById('filterOptionsList');
            if (!searchInput || !list) return;
            
            const searchTerm = searchInput.value.toLowerCase();
            const options = list.querySelectorAll('.filter-option');
            
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchTerm) ? 'flex' : 'none';
            });
        }
        
        // Open filter value dialog - now creates inline dropdown
        function openFilterValueDialog(fieldId) {
            console.log('[DEBUG openFilterValueDialog] Called with fieldId:', fieldId);
            const field = FILTER_FIELDS.find(f => f.id === fieldId);
            if (!field) {
                console.error('[DEBUG openFilterValueDialog] Field not found:', fieldId);
                return;
            }
            console.log('[DEBUG openFilterValueDialog] Found field:', field);
            
            // Close the main filter menu first
            const insightsSection = document.getElementById('insights-section');
            const mainDropdown = insightsSection ? insightsSection.querySelector('#filterDropdown') : document.getElementById('filterDropdown');
            console.log('[DEBUG openFilterValueDialog] Main dropdown:', mainDropdown);
            if (mainDropdown) {
                mainDropdown.classList.remove('active');
                mainDropdown.style.display = 'none';
                console.log('[DEBUG openFilterValueDialog] Closed main dropdown');
            }
            
            // Check if this filter dropdown already exists
            const existingDropdown = document.getElementById(`inline-filter-${fieldId}`);
            console.log('[DEBUG openFilterValueDialog] Existing dropdown:', existingDropdown);
            if (existingDropdown) {
                // Toggle it if it already exists
                const header = existingDropdown.querySelector('.inline-filter-header');
                const options = existingDropdown.querySelector('.inline-filter-options');
                console.log('[DEBUG openFilterValueDialog] Toggling existing dropdown, header:', header, 'options:', options);
                if (header && options) {
                    header.classList.toggle('open');
                    options.classList.toggle('open');
                    console.log('[DEBUG openFilterValueDialog] Toggled classes. Header open:', header.classList.contains('open'), 'Options open:', options.classList.contains('open'));
                    // Update checkbox states to reflect current filter state (in case filters were loaded from storage)
                    updateInlineFilterOptions(fieldId);
                }
                return;
            }
            
            // Get unique values for this field from insights
            const values = field.type === 'select' ? getUniqueFieldValues(fieldId) : [];
            console.log('[DEBUG openFilterValueDialog] Got values:', values);
            
            // Create inline filter dropdown
            const filterChipsContainer = document.getElementById('filterChips');
            console.log('[DEBUG openFilterValueDialog] Filter chips container:', filterChipsContainer);
            if (!filterChipsContainer) {
                console.error('[DEBUG openFilterValueDialog] Filter chips container not found!');
                return;
            }
            
            const inlineFilter = document.createElement('div');
            inlineFilter.className = 'inline-filter-dropdown';
            inlineFilter.id = `inline-filter-${fieldId}`;
            inlineFilter.setAttribute('data-just-created', 'true'); // Flag to prevent immediate closing
            console.log('[DEBUG openFilterValueDialog] Created inline filter element:', inlineFilter);
            
            let optionsHTML = '';
            if (field.type === 'select') {
                optionsHTML = values.map(value => {
                    const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                    const escapedValue = escapeHtml(value);
                    return `
                        <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                             data-filter-value="${escapedValue}"
                             onclick="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                            <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} 
                                   data-filter-value="${escapedValue}"
                                   onclick="event.stopPropagation()" 
                                   onchange="event.stopPropagation(); toggleInlineFilterValue('${fieldId}', '${escapedValue}')">
                            <span>${escapedValue || '(empty)'}</span>
                        </div>
                    `;
                }).join('');
            } else if (field.type === 'date') {
                const dateOptions = [
                    { value: 'today', label: 'Today' },
                    { value: 'yesterday', label: 'Yesterday' },
                    { value: 'this_week', label: 'This week' },
                    { value: 'this_month', label: 'This month' },
                    { value: 'last_month', label: 'Last month' }
                ];
                optionsHTML = dateOptions.map(opt => {
                    const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === opt.value);
                    return `
                        <div class="inline-filter-option ${isSelected ? 'selected' : ''}" 
                             onclick="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                            <input type="checkbox" class="inline-filter-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation()" onchange="event.stopPropagation(); addDateFilter('${fieldId}', '${opt.value}')">
                            <span>${opt.label}</span>
                        </div>
                    `;
                }).join('');
            }
            
            inlineFilter.innerHTML = `
                <div class="inline-filter-header open" onclick="toggleInlineFilterDropdown('${fieldId}', event)">
                    <span class="inline-filter-icon">${field.icon}</span>
                    <span class="inline-filter-label">${field.label}</span>
                    <span class="inline-filter-chevron"></span>
                </div>
                <div class="inline-filter-options open">
                    ${optionsHTML}
                </div>
                <div class="inline-filter-remove" onclick="event.stopPropagation(); removeInlineFilter('${fieldId}')" title="Remove filter"></div>
            `;
            
            // Update header to show selected filter values after creating dropdown
            setTimeout(() => {
                updateInlineFilterHeader(fieldId);
            }, 0);
            console.log('[DEBUG openFilterValueDialog] Set innerHTML, optionsHTML length:', optionsHTML.length);
            
            // Debug: Check checkboxes after rendering
            setTimeout(() => {
                const checkboxes = inlineFilter.querySelectorAll('.inline-filter-checkbox');
                console.log('[DEBUG openFilterValueDialog] After rendering, found', checkboxes.length, 'checkboxes');
                checkboxes.forEach((cb, idx) => {
                    const computedStyle = window.getComputedStyle(cb);
                    console.log(`[DEBUG openFilterValueDialog] Checkbox ${idx}:`, {
                        checked: cb.checked,
                        value: cb.value,
                        type: cb.type,
                        computedDisplay: computedStyle.display,
                        computedWidth: computedStyle.width,
                        computedHeight: computedStyle.height,
                        accentColor: computedStyle.accentColor || computedStyle.getPropertyValue('accent-color'),
                        appearance: computedStyle.appearance || computedStyle.getPropertyValue('-webkit-appearance'),
                        opacity: computedStyle.opacity,
                        visibility: computedStyle.visibility
                    });
                });
            }, 100);
            
            // Insert before the filter button container
            const filterButtonContainer = filterChipsContainer.nextElementSibling;
            console.log('[DEBUG openFilterValueDialog] Filter button container:', filterButtonContainer);
            if (filterButtonContainer) {
                filterChipsContainer.parentNode.insertBefore(inlineFilter, filterButtonContainer);
                console.log('[DEBUG openFilterValueDialog] Inserted before button container');
            } else {
                filterChipsContainer.parentNode.appendChild(inlineFilter);
                console.log('[DEBUG openFilterValueDialog] Appended to parent');
            }
            
            // Ensure the dropdown is open after insertion
            // Use a longer delay to ensure click events have processed
            setTimeout(() => {
                console.log('[DEBUG openFilterValueDialog] Checking dropdown state after insertion');
                const header = inlineFilter.querySelector('.inline-filter-header');
                const options = inlineFilter.querySelector('.inline-filter-options');
                console.log('[DEBUG openFilterValueDialog] Header element:', header);
                console.log('[DEBUG openFilterValueDialog] Options element:', options);
                console.log('[DEBUG openFilterValueDialog] Header classes:', header ? header.className : 'null');
                console.log('[DEBUG openFilterValueDialog] Options classes:', options ? options.className : 'null');
                console.log('[DEBUG openFilterValueDialog] Options computed display:', options ? window.getComputedStyle(options).display : 'null');
                
                if (header && options) {
                    // Force the classes to be set
                    header.classList.add('open');
                    options.classList.add('open');
                    // Also set style directly as backup
                    options.style.display = 'block';
                    console.log('[DEBUG openFilterValueDialog] Added open classes and set display');
                    console.log('[DEBUG openFilterValueDialog] Header has open:', header.classList.contains('open'));
                    console.log('[DEBUG openFilterValueDialog] Options has open:', options.classList.contains('open'));
                    console.log('[DEBUG openFilterValueDialog] Options style.display:', options.style.display);
                    console.log('[DEBUG openFilterValueDialog] Options computed display after:', window.getComputedStyle(options).display);
                } else {
                    console.error('[DEBUG openFilterValueDialog] Header or options not found!');
                }
            }, 50);
        }
        
        // Toggle inline filter dropdown
        function toggleInlineFilterDropdown(fieldId, e) {
            if (e) {
                e.stopPropagation();
            }
            console.log('[DEBUG toggleInlineFilterDropdown] Called with fieldId:', fieldId);
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            console.log('[DEBUG toggleInlineFilterDropdown] Dropdown:', dropdown);
            if (!dropdown) return;
            
            const header = dropdown.querySelector('.inline-filter-header');
            const options = dropdown.querySelector('.inline-filter-options');
            console.log('[DEBUG toggleInlineFilterDropdown] Header:', header, 'Options:', options);
            
            if (header && options) {
                const isOpen = options.classList.contains('open');
                console.log('[DEBUG toggleInlineFilterDropdown] Currently open:', isOpen);
                
                if (isOpen) {
                    header.classList.remove('open');
                    options.classList.remove('open');
                    options.style.display = 'none';
                    console.log('[DEBUG toggleInlineFilterDropdown] Closed dropdown');
                } else {
                    header.classList.add('open');
                    options.classList.add('open');
                    options.style.display = 'block';
                    console.log('[DEBUG toggleInlineFilterDropdown] Opened dropdown');
                }
            }
        }
        
        // Toggle inline filter value
        function toggleInlineFilterValue(fieldId, value) {
            const existingIndex = insightsFilters.findIndex(f => f.field === fieldId && f.value === value);
            
            if (existingIndex >= 0) {
                // Remove filter
                insightsFilters.splice(existingIndex, 1);
            } else {
                // Add filter
                insightsFilters.push({ field: fieldId, operator: 'equals', value: value });
            }
            
            // Update the inline dropdown options to reflect current filter state
            updateInlineFilterOptions(fieldId);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Update inline filter header label to show selected filter values
        function updateInlineFilterHeader(fieldId) {
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (!dropdown) {
                return;
            }
            
            const header = dropdown.querySelector('.inline-filter-header');
            const labelElement = header ? header.querySelector('.inline-filter-label') : null;
            if (!labelElement) {
                return;
            }
            
            // Get all active filters for this field
            const activeFilters = insightsFilters.filter(f => f.field === fieldId);
            
            if (activeFilters.length === 0) {
                // No filters active, show default label
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                labelElement.textContent = field ? field.label : fieldId;
            } else if (activeFilters.length === 1) {
                // Single filter, show the value (or label for date filters)
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                let displayValue = activeFilters[0].value;
                
                // Special case: status filter with "Win" should display as " Wins"
                if (fieldId === 'status' && displayValue === 'Win') {
                    displayValue = ' Wins';
                }
                // For date filters, convert value to label
                else if (field && field.type === 'date') {
                    const dateOptions = [
                        { value: 'today', label: 'Today' },
                        { value: 'yesterday', label: 'Yesterday' },
                        { value: 'this_week', label: 'This week' },
                        { value: 'this_month', label: 'This month' },
                        { value: 'last_month', label: 'Last month' }
                    ];
                    const dateOption = dateOptions.find(opt => opt.value === displayValue);
                    if (dateOption) {
                        displayValue = dateOption.label;
                    }
                }
                
                labelElement.textContent = displayValue;
            } else {
                // Multiple filters, show first value + count
                const field = FILTER_FIELDS.find(f => f.id === fieldId);
                let firstValue = activeFilters[0].value;
                
                // Special case: status filter with "Win" should display as " Wins"
                if (fieldId === 'status' && firstValue === 'Win') {
                    firstValue = ' Wins';
                }
                // For date filters, convert value to label
                else if (field && field.type === 'date') {
                    const dateOptions = [
                        { value: 'today', label: 'Today' },
                        { value: 'yesterday', label: 'Yesterday' },
                        { value: 'this_week', label: 'This week' },
                        { value: 'this_month', label: 'This month' },
                        { value: 'last_month', label: 'Last month' }
                    ];
                    const dateOption = dateOptions.find(opt => opt.value === firstValue);
                    if (dateOption) {
                        firstValue = dateOption.label;
                    }
                }
                
                labelElement.textContent = `${firstValue} + ${activeFilters.length - 1} more`;
            }
        }
        
        // Update inline filter options display to sync checkbox states with filter state
        function updateInlineFilterOptions(fieldId) {
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (!dropdown) {
                return;
            }
            
            const options = dropdown.querySelectorAll('.inline-filter-option');
            
            options.forEach((option) => {
                const checkbox = option.querySelector('.inline-filter-checkbox');
                if (!checkbox) {
                    return;
                }
                
                // Get the filter value from data attribute (most reliable)
                let value = checkbox.getAttribute('data-filter-value') || option.getAttribute('data-filter-value');
                
                // Fallback: extract from function call in onchange attribute if data attribute not found
                if (!value) {
                    const onchangeAttr = checkbox.getAttribute('onchange');
                    const valueMatch = onchangeAttr ? onchangeAttr.match(/toggleInlineFilterValue\(['"]([^'"]+)['"],\s*['"]([^'"]+)['"]\)/) : null;
                    if (valueMatch && valueMatch[2]) {
                        value = valueMatch[2];
                    } else {
                        // Last resort: try onclick on parent
                        const onclickAttr = option.getAttribute('onclick');
                        const onclickMatch = onclickAttr ? onclickAttr.match(/toggleInlineFilterValue\(['"]([^'"]+)['"],\s*['"]([^'"]+)['"]\)/) : null;
                        if (onclickMatch && onclickMatch[2]) {
                            value = onclickMatch[2];
                        } else {
                            return; // Cannot determine value, skip this option
                        }
                    }
                }
                
                // Check if this value is currently in the filters
                const isSelected = insightsFilters.some(f => f.field === fieldId && f.value === value);
                
                // Update checkbox state
                checkbox.checked = isSelected;
                
                // Update option selected class for styling
                if (isSelected) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
            
            // Update header label to show selected values
            updateInlineFilterHeader(fieldId);
        }
        
        // Remove inline filter
        function removeInlineFilter(fieldId) {
            // Remove all filters for this field
            insightsFilters = insightsFilters.filter(f => f.field !== fieldId);
            
            // Remove the dropdown element
            const dropdown = document.getElementById(`inline-filter-${fieldId}`);
            if (dropdown) {
                dropdown.remove();
            }
            
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Get unique values for a field
        function getUniqueFieldValues(fieldId) {
            const values = new Set();
            
            insightsAllInsights.forEach(insight => {
                let value = null;
                
                if (fieldId === 'status') {
                    value = insight.status || 'Not Started';
                } else if (fieldId === 'project' || fieldId === 'data_source' || fieldId === 'dimension') {
                    const firstOrigin = insight.origins?.[0] || {};
                    if (fieldId === 'project') {
                        value = firstOrigin.project_name;
                    } else if (fieldId === 'data_source') {
                        value = firstOrigin.data_source;
                    } else if (fieldId === 'dimension') {
                        value = firstOrigin.dimension_name || firstOrigin.dimension_ref;
                    }
                }
                
                if (value && value !== '-') {
                    values.add(value);
                }
            });
            
            return Array.from(values).sort();
        }
        
        // Toggle filter value
        function toggleFilterValue(fieldId, value) {
            const existingIndex = insightsFilters.findIndex(f => f.field === fieldId && f.value === value);
            
            if (existingIndex >= 0) {
                // Remove filter
                insightsFilters.splice(existingIndex, 1);
            } else {
                // Add filter
                insightsFilters.push({ field: fieldId, operator: 'equals', value: value });
            }
            
            // Update dialog
            openFilterValueDialog(fieldId);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Add date filter
        function addDateFilter(fieldId, period) {
            // Remove existing date filters for this field
            insightsFilters = insightsFilters.filter(f => f.field !== fieldId);
            
            // Add new filter
            insightsFilters.push({ field: fieldId, operator: 'equals', value: period });
            
            // Update the inline dropdown if it exists
            updateInlineFilterOptions(fieldId);
            
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Close filter value dialog
        function closeFilterValueDialog() {
            const dialog = document.getElementById('filterValueDialog');
            const overlay = document.getElementById('filterDialogOverlay');
            if (dialog) dialog.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }
        
        // Update active filters display in dropdown
        function updateActiveFiltersDisplay() {
            const section = document.getElementById('activeFiltersSection');
            const list = document.getElementById('activeFiltersList');
            
            if (!section || !list) return;
            
            if (insightsFilters.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            list.innerHTML = insightsFilters.map((filter, index) => {
                const field = FILTER_FIELDS.find(f => f.id === filter.field);
                const label = field ? field.label : filter.field;
                return `
                    <div class="filter-active-item">
                        <span>${label}: ${escapeHtml(String(filter.value))}</span>
                        <span class="filter-active-item-remove" onclick="removeFilterByIndex(${index})"></span>
                    </div>
                `;
            }).join('');
        }
        
        // Remove filter by index
        function removeFilterByIndex(index) {
            insightsFilters.splice(index, 1);
            updateFilterChips();
            updateActiveFiltersDisplay();
            saveFiltersToStorage();
            renderInsightsPage();
        }
        
        // Legacy function name for compatibility
        function openFilterMenu() {
            toggleFilterMenu();
        }

        function openCreateModal() {
            console.log('[openCreateModal] Function called');
            console.log('[openCreateModal] Current file:', window.location.pathname);
            console.log('[openCreateModal] SlideoutPanel available:', typeof SlideoutPanel !== 'undefined');
            
            insightsCurrentInsightId = null;
            
            // Check if we should use slideout panel
            if (typeof SlideoutPanel !== 'undefined' && SlideoutPanel.openCreateInsight) {
                console.log('[openCreateModal] Using slideout panel method');
                
                const urlParams = new URLSearchParams(window.location.search);
                const contextData = {
                    dimension_ref: urlParams.get('dimension_ref') || null,
                    project_name: urlParams.get('project_name') || null,
                    data_source: urlParams.get('data_source') || null,
                    dimension_name: urlParams.get('dimension_name') || null,
                };
                
                console.log('[openCreateModal] Context data:', contextData);
                console.log('[openCreateModal] Calling SlideoutPanel.openCreateInsight');
                
                SlideoutPanel.openCreateInsight(contextData);
                return;
            }
            
            // Fallback to modal (for debugging)
            console.warn('[openCreateModal] SlideoutPanel not available, falling back to modal');
            const modal = document.getElementById('insightModal');
            const modalTitle = document.getElementById('modalTitle');
            const form = document.getElementById('insightForm');
            
            console.log('[openCreateModal] Modal elements:', { 
                modal: !!modal, 
                modalTitle: !!modalTitle, 
                form: !!form 
            });
            
            if (!modal || !modalTitle || !form) {
                console.error('[openCreateModal] Modal elements not found:', { modal, modalTitle, form });
                return;
            }
            
            modalTitle.textContent = 'Create Insight';
            form.reset();
            
            const urlParams = new URLSearchParams(window.location.search);
            window.insightOriginContext = {
                dimension_ref: urlParams.get('dimension_ref') || null,
                project_name: urlParams.get('project_name') || null,
                data_source: urlParams.get('data_source') || null,
                dimension_name: urlParams.get('dimension_name') || null,
            };
            
            console.log('[openCreateModal] Opening modal');
            modal.classList.add('active');
        }

        function closeModal() {
            const modal = document.getElementById('insightModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        async function saveInsight(event) {
            event.preventDefault();
            if (!insightsCurrentClientId) return;

            let token = null;
            if (typeof getAuthToken !== 'undefined') {
                token = getAuthToken();
            }
            if (!token) {
                token = localStorage.getItem('visualizd_auth_token');
            }
            if (!token && window.opener) {
                try {
                    token = window.opener.localStorage.getItem('visualizd_auth_token');
                    if (token) localStorage.setItem('visualizd_auth_token', token);
                } catch (e) {}
            }
            
            if (!token) {
                alert('You are not logged in. Please log in and try again.');
                return;
            }

            const originContext = window.insightOriginContext || {};
            const toNull = (val) => (val && val.trim()) ? val.trim() : null;
            
            const insightData = {
                name: document.getElementById('insightName').value.trim(),
                type: '',
                application: '',
                description: toNull(document.getElementById('insightDescription').value),
                origins: [{
                    origin_type: originContext.category ? 'category' : (originContext.topic_label ? 'topic' : 'category'),
                    project_name: toNull(originContext.project_name),
                    data_source: toNull(originContext.data_source),
                    dimension_ref: toNull(originContext.dimension_ref),
                    dimension_name: toNull(originContext.dimension_name),
                    category: toNull(originContext.category),
                    topic_label: toNull(originContext.topic_label),
                    process_voc_id: originContext.process_voc_id || null,
                }],
            };

            try {
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
                
                let response;
                if (insightsCurrentInsightId) {
                    response = await fetch(`${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightsCurrentInsightId}`, {
                        method: 'PUT',
                        headers: headers,
                        body: JSON.stringify(insightData),
                    });
                } else {
                    response = await fetch(`${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(insightData),
                    });
                }
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                    throw new Error(errorData.detail || `Failed to ${insightsCurrentInsightId ? 'update' : 'create'} insight`);
                }
                
                closeModal();
                loadInsightsPage();
            } catch (error) {
                console.error('Error saving insight:', error);
                alert('Error saving insight: ' + error.message);
            }
        }

        async function editInsight(insightId) {
            console.log('[editInsight] Function called with insightId:', insightId);
            console.log('[editInsight] insightsCurrentClientId:', insightsCurrentClientId);
            
            if (!insightsCurrentClientId) {
                console.error('[editInsight] No client selected');
                return;
            }

            // Use the same function as opening insight notes (slideout panel)
            console.log('[editInsight] Calling openInsightNotes');
            openInsightNotes(insightId);
        }

        async function deleteInsight(insightId) {
            if (!insightsCurrentClientId) return;
            if (!confirm('Are you sure you want to delete this insight?')) return;

            try {
                const response = await fetch(`${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`, {
                    method: 'DELETE',
                    headers: getAuthHeadersSafe()
                });
                if (!response.ok) throw new Error('Failed to delete insight');
                loadInsightsPage();
            } catch (error) {
                console.error('Error deleting insight:', error);
                alert('Error deleting insight: ' + error.message);
            }
        }

        function handleInsightCheckboxChange() {
            selectedInsightIds.clear();
            const checkboxes = document.querySelectorAll('.insight-checkbox:checked');
            checkboxes.forEach(checkbox => {
                const insightId = checkbox.getAttribute('data-insight-id');
                if (insightId) {
                    selectedInsightIds.add(insightId);
                }
            });
            updateInsightsDeleteButton();
            updateSelectAllCheckbox();
        }

        function toggleSelectAllInsights(checked) {
            const checkboxes = document.querySelectorAll('.insight-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
                const insightId = checkbox.getAttribute('data-insight-id');
                if (checked && insightId) {
                    selectedInsightIds.add(insightId);
                } else if (insightId) {
                    selectedInsightIds.delete(insightId);
                }
            });
            updateInsightsDeleteButton();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('insightsSelectAll');
            if (!selectAllCheckbox) return;
            
            const checkboxes = document.querySelectorAll('.insight-checkbox');
            const checkedCount = document.querySelectorAll('.insight-checkbox:checked').length;
            selectAllCheckbox.checked = checkboxes.length > 0 && checkedCount === checkboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < checkboxes.length;
        }

        function updateInsightsDeleteButton() {
            // Try both button locations - insights section (main) and insights panel (in visualizations)
            const deleteBtn = document.getElementById('insightsSectionDeleteBtn') || document.getElementById('insightsDeleteBtn');
            if (!deleteBtn) return;
            
            const shouldShow = selectedInsightIds.size > 0;
            
            if (shouldShow) {
                // Remove the inline style attribute to clear the initial display:none
                deleteBtn.removeAttribute('style');
                deleteBtn.style.display = 'block';
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        async function deleteSelectedInsights() {
            if (!insightsCurrentClientId) return;
            if (selectedInsightIds.size === 0) return;

            const count = selectedInsightIds.size;
            const message = count === 1 
                ? 'Are you sure you want to delete this insight?'
                : `Are you sure you want to delete ${count} insights?`;
            
            if (!confirm(message)) return;

            try {
                const deletePromises = Array.from(selectedInsightIds).map(insightId =>
                    fetch(`${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`, {
                        method: 'DELETE',
                        headers: getAuthHeadersSafe()
                    }).then(response => {
                        if (!response.ok) throw new Error(`Failed to delete insight ${insightId}`);
                        return insightId;
                    })
                );

                await Promise.all(deletePromises);
                selectedInsightIds.clear();
                loadInsightsPage();
            } catch (error) {
                console.error('Error deleting insights:', error);
                alert('Error deleting insights: ' + error.message);
                // Reload page to sync state even if some deletes failed
                loadInsightsPage();
            }
        }

        async function updateInsightStatus(insightId, status) {
            console.log('[DEBUG updateInsightStatus] Function called');
            console.log('[DEBUG updateInsightStatus] Parameters:', { insightId, status, insightsCurrentClientId });
            
            if (!insightsCurrentClientId) {
                console.error('[DEBUG updateInsightStatus] No insightsCurrentClientId:', insightsCurrentClientId);
                alert('Error: No client selected. Please refresh the page.');
                return;
            }
            
            if (!insightId) {
                console.error('[DEBUG updateInsightStatus] No insightId provided:', insightId);
                alert('Error: No insight ID provided.');
                return;
            }
            
            if (!status) {
                console.error('[DEBUG updateInsightStatus] No status provided:', status);
                alert('Error: No status value provided.');
                return;
            }
            
            console.log('[DEBUG updateInsightStatus] Starting status update...');
            console.log('[DEBUG updateInsightStatus] API_BASE_URL:', API_BASE_URL);
            console.log('[DEBUG updateInsightStatus] Full URL will be:', `${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`);
            
            try {
                const headers = getAuthHeadersSafe();
                console.log('[DEBUG updateInsightStatus] Headers retrieved:', headers ? Object.keys(headers) : 'No headers');
                
                const token = headers?.Authorization || headers?.authorization || localStorage.getItem('visualizd_auth_token');
                console.log('[DEBUG updateInsightStatus] Token retrieved:', token ? `Token exists (${token.substring(0, 20)}...)` : 'No token found');
                
                if (!token) {
                    console.error('[DEBUG updateInsightStatus] Authentication failed - no token');
                    throw new Error('Not authenticated');
                }
                
                const requestBody = { status: status };
                console.log('[DEBUG updateInsightStatus] Request body:', requestBody);
                
                const requestHeaders = {
                    'Authorization': token.startsWith('Bearer') ? token : `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
                console.log('[DEBUG updateInsightStatus] Request headers:', { ...requestHeaders, 'Authorization': 'Bearer [REDACTED]' });
                
                const url = `${API_BASE_URL}/api/clients/${insightsCurrentClientId}/insights/${insightId}`;
                console.log('[DEBUG updateInsightStatus] Making PUT request to:', url);
                
                const fetchStartTime = Date.now();
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody)
                });
                const fetchDuration = Date.now() - fetchStartTime;
                
                console.log('[DEBUG updateInsightStatus] Response received in', fetchDuration, 'ms');
                console.log('[DEBUG updateInsightStatus] Response status:', response.status);
                console.log('[DEBUG updateInsightStatus] Response statusText:', response.statusText);
                console.log('[DEBUG updateInsightStatus] Response ok:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[DEBUG updateInsightStatus] Response not OK. Error text:', errorText);
                    try {
                        const errorJson = JSON.parse(errorText);
                        console.error('[DEBUG updateInsightStatus] Error JSON:', errorJson);
                        throw new Error(errorJson.detail || `Failed to update status: ${response.status} ${response.statusText}`);
                    } catch (parseError) {
                        throw new Error(`Failed to update status: ${response.status} ${response.statusText}. ${errorText}`);
                    }
                }
                
                const responseData = await response.json();
                console.log('[DEBUG updateInsightStatus] Response data:', responseData);
                console.log('[DEBUG updateInsightStatus] Status update successful!');
                
                // Update local data without reloading
                const insightIndex = insightsAllInsights.findIndex(insight => insight.id === insightId);
                if (insightIndex !== -1) {
                    insightsAllInsights[insightIndex].status = status;
                    console.log('[DEBUG updateInsightStatus] Updated local insight data');
                }
                
                // Update the select element's data attribute and selected option
                const selectElement = document.querySelector(`select.status-select[data-insight-id="${insightId}"]`);
                if (selectElement) {
                    selectElement.setAttribute('data-current-status', status);
                    selectElement.value = status;
                    console.log('[DEBUG updateInsightStatus] Updated select element UI');
                }
            } catch (error) {
                console.error('[DEBUG updateInsightStatus] ERROR caught:', error);
                console.error('[DEBUG updateInsightStatus] Error name:', error.name);
                console.error('[DEBUG updateInsightStatus] Error message:', error.message);
                console.error('[DEBUG updateInsightStatus] Error stack:', error.stack);
                alert('Error updating status: ' + error.message);
            }
        }

        async function openInsightNotes(insightId) {
            // Delegate to SlideoutPanel for consistent behavior
            if (window.SlideoutPanel && window.SlideoutPanel.openInsightNotes) {
                return await window.SlideoutPanel.openInsightNotes(insightId);
            } else {
                console.error('[openInsightNotes] SlideoutPanel not available');
                alert('Unable to open insight. Please refresh the page.');
            }
        }

        function closeInsightNotes() {
            if (window.SlideoutPanel && window.SlideoutPanel.close) {
                window.SlideoutPanel.close();
            }
            
            // Clean up any remaining standalone state
            insightsCurrentInsightNotesId = null;
            insightsCurrentInsightData = null;
            
            if (insightsSaveNotesTimeout) {
                clearTimeout(insightsSaveNotesTimeout);
                insightsSaveNotesTimeout = null;
            }
            if (insightsFieldSaveTimeout) {
                clearTimeout(insightsFieldSaveTimeout);
                insightsFieldSaveTimeout = null;
            }
        }

        // Shared media upload utilities for insight editors
        async function uploadMediaToBlob(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const frontendUrl = window.location.origin;
            const response = await fetch(`${frontendUrl}/api/upload-media`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
                throw new Error(errorData.error || errorData.detail || 'Upload failed');
            }
            
            const data = await response.json();
            return data.url;
        }
        
        function convertLoomUrl(url) {
            if (!url) return null;
            // Match various Loom URL formats: loom.com/share/ID, www.loom.com/share/ID, etc.
            // Also handle URLs with or without protocol
            const loomMatch = url.match(/(?:https?:\/\/)?(?:www\.)?loom\.com\/share\/([a-zA-Z0-9]+)/);
            if (loomMatch) {
                const videoId = loomMatch[1];
                return `https://www.loom.com/embed/${videoId}`;
            }
            return null;
        }
        
        function createMediaPasteHandler(getEditor, insertAndUploadMedia) {
            return (view, event, slice) => {
                console.log('[Paste Handler] Paste event triggered', { view, event, slice });
                console.log('[Paste Handler] Clipboard data available:', !!event.clipboardData);
                
                // Get editor reference at execution time (getEditor can be a function or the editor itself)
                const editor = typeof getEditor === 'function' ? getEditor() : getEditor;
                console.log('[Paste Handler] Editor available:', !!editor, editor);
                if (!editor) {
                    console.log('[Paste Handler] No editor available, allowing default paste');
                    return false; // Editor not available, allow default paste
                }
                
                const items = Array.from(event.clipboardData?.items || []);
                console.log('[Paste Handler] Clipboard items:', items.length, items.map(item => ({ type: item.type, kind: item.kind })));
                
                const imageItem = items.find(item => item.type.startsWith('image/'));
                const videoItem = items.find(item => item.type.startsWith('video/'));
                console.log('[Paste Handler] Image item:', !!imageItem, 'Video item:', !!videoItem);
                
                if (imageItem) {
                    console.log('[Paste Handler] Processing image paste');
                    event.preventDefault();
                    const file = imageItem.getAsFile();
                    if (file) {
                        insertAndUploadMedia(file, false);
                        return true;
                    }
                }
                
                if (videoItem) {
                    console.log('[Paste Handler] Processing video paste');
                    event.preventDefault();
                    const file = videoItem.getAsFile();
                    if (file) {
                        insertAndUploadMedia(file, true);
                        return true;
                    }
                }
                
                // Check for Loom URLs in both plain text and HTML clipboard data
                const pastedText = event.clipboardData?.getData('text/plain');
                const pastedHtml = event.clipboardData?.getData('text/html');
                console.log('[Paste Handler] Pasted text:', pastedText);
                console.log('[Paste Handler] Pasted HTML:', pastedHtml ? pastedHtml.substring(0, 200) + '...' : null);
                
                // Extract URL from pasted content (check plain text first, then HTML)
                let textToCheck = pastedText?.trim();
                if (!textToCheck && pastedHtml) {
                    console.log('[Paste Handler] Extracting URL from HTML');
                    // Try to extract URL from HTML (look for href attributes first, then text content)
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = pastedHtml;
                    const linkElement = tempDiv.querySelector('a[href]');
                    if (linkElement) {
                        textToCheck = linkElement.href;
                        console.log('[Paste Handler] Found URL in link href:', textToCheck);
                    } else {
                        // Fall back to text content if no link element found
                        textToCheck = tempDiv.textContent?.trim();
                        console.log('[Paste Handler] Using HTML text content:', textToCheck);
                    }
                }
                
                console.log('[Paste Handler] Text to check for Loom URL:', textToCheck);
                
                // Check if the pasted content contains a Loom URL (even if embedded in other text)
                if (textToCheck) {
                    const loomEmbedUrl = convertLoomUrl(textToCheck);
                    console.log('[Paste Handler] Loom embed URL:', loomEmbedUrl);
                    if (loomEmbedUrl) {
                        console.log('[Paste Handler] Inserting Loom iframe');
                        event.preventDefault();
                        // Use TipTap's iframe node instead of raw HTML
                        editor.chain().focus().insertContent({
                            type: 'iframe',
                            attrs: {
                                src: loomEmbedUrl,
                                width: '100%',
                                height: '500px',
                                frameborder: '0',
                                allowfullscreen: true,
                                style: 'width: 100%; border-radius: 0.5rem; aspect-ratio: 16/9; margin: 1rem 0; border: none;',
                            },
                        }).run();
                        const editorHtml = editor.getHTML();
                        console.log('[Paste Handler] Editor HTML after insertion:', editorHtml);
                        console.log('[Paste Handler] Editor HTML contains iframe:', editorHtml.includes('iframe'));
                        console.log('[Paste Handler] Editor HTML contains embed URL:', editorHtml.includes(loomEmbedUrl));
                        return true;
                    } else {
                        console.log('[Paste Handler] Not a Loom URL, allowing default paste');
                    }
                } else {
                    console.log('[Paste Handler] No text to check, allowing default paste');
                }
                
                console.log('[Paste Handler] Returning false, allowing default paste behavior');
                return false;
            };
        }
        
        function createMediaDropHandler(insertAndUploadMedia) {
            return (view, event, slice, moved) => {
                if (!moved && event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
                    const file = event.dataTransfer.files[0];
                    const isImage = file.type.startsWith('image/');
                    const isVideo = file.type.startsWith('video/');
                    
                    if (isImage || isVideo) {
                        event.preventDefault();
                        insertAndUploadMedia(file, isVideo);
                        return true;
                    }
                }
                return false;
            };
        }
        
        // Removed standalone functions - now using SlideoutPanel implementations:
        // - initializeInsightEditor -> SlideoutPanel.initializeInsightEditor
        // - setupInsightEditorContextMenu -> SlideoutPanel.setupEditorContextMenu
        // - cleanupInsightEditorContextMenu -> SlideoutPanel.cleanupEditorContextMenu
        
        function updateInsightContextMenuStates(menu, editor) {
            const items = menu.querySelectorAll('.context-menu-item');
            items.forEach(item => {
                const action = item.getAttribute('data-action');
                let isActive = false;
                
                switch (action) {
                    case 'heading-1':
                        isActive = editor.isActive('heading', { level: 1 });
                        break;
                    case 'heading-2':
                        isActive = editor.isActive('heading', { level: 2 });
                        break;
                    case 'heading-3':
                        isActive = editor.isActive('heading', { level: 3 });
                        break;
                    case 'bold':
                        isActive = editor.isActive('bold');
                        break;
                    case 'bulletList':
                        isActive = editor.isActive('bulletList');
                        break;
                    case 'taskList':
                        isActive = editor.isActive('taskList');
                        break;
                    case 'blockquote':
                        isActive = editor.isActive('blockquote');
                        break;
                }
                
                if (isActive) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function debouncedSaveInsightNotes(insightId, content) {
            // Use SlideoutPanel.currentInsightId if insightId is not provided
            if (!insightId && window.SlideoutPanel && window.SlideoutPanel.currentInsightId) {
                insightId = window.SlideoutPanel.currentInsightId;
            }
            clearTimeout(insightsSaveNotesTimeout);
            
            const statusEl = document.getElementById('insightNotesSaveStatus');
            if (statusEl) statusEl.textContent = 'Saving...';
            
            insightsSaveNotesTimeout = setTimeout(async () => {
                await saveInsightNotes(insightId, content);
            }, 500);
        }

        function debouncedSaveInsightField(fieldName, value) {
            clearTimeout(insightsFieldSaveTimeout);
            
            insightsFieldSaveTimeout = setTimeout(async () => {
                await saveInsightField(fieldName, value);
            }, 500);
        }

        async function saveInsightField(fieldName, value) {
            // Use SlideoutPanel.currentInsightId if available, otherwise fall back to insightsCurrentInsightNotesId
            const insightId = (window.SlideoutPanel && window.SlideoutPanel.currentInsightId) 
                ? window.SlideoutPanel.currentInsightId 
                : insightsCurrentInsightNotesId;
            const clientId = (window.SlideoutPanel && currentClientId) 
                ? currentClientId 
                : insightsCurrentClientId;
            
            if (!clientId || !insightId) return;
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    throw new Error('Not authenticated');
                }
                
                const updateData = {};
                updateData[fieldName] = value;
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${clientId}/insights/${insightId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save field');
                }
                
                if (insightsCurrentInsightData) {
                    insightsCurrentInsightData[fieldName] = value;
                }
                
                if (typeof loadInsightsPage === 'function') {
                    loadInsightsPage();
                }
            } catch (error) {
                console.error('Error saving field:', error);
            }
        }

        async function saveInsightNotes(insightId, content) {
            // Use SlideoutPanel.currentInsightId if insightId is not provided
            if (!insightId && window.SlideoutPanel && window.SlideoutPanel.currentInsightId) {
                insightId = window.SlideoutPanel.currentInsightId;
            }
            // Use SlideoutPanel.currentInsightId if available, otherwise fall back to insightsCurrentInsightNotesId
            const finalInsightId = insightId || ((window.SlideoutPanel && window.SlideoutPanel.currentInsightId) 
                ? window.SlideoutPanel.currentInsightId 
                : insightsCurrentInsightNotesId);
            const clientId = (window.SlideoutPanel && currentClientId) 
                ? currentClientId 
                : insightsCurrentClientId;
            
            if (!clientId || !finalInsightId) return;
            
            const statusEl = document.getElementById('insightNotesSaveStatus');
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    throw new Error('Not authenticated');
                }
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${clientId}/insights/${finalInsightId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ notes: content })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save notes');
                }
                
                if (statusEl) {
                    statusEl.textContent = 'Saved';
                    statusEl.style.color = '#B9F040';
                    setTimeout(() => {
                        if (statusEl) {
                            statusEl.textContent = '';
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('Error saving notes:', error);
                if (statusEl) {
                    statusEl.textContent = 'Error saving';
                    statusEl.style.color = 'oklch(0.577 0.245 27.325)';
                }
            }
        }

        // Column order management
        const COLUMN_ORDER_KEY = 'insights_column_order';
        
        function getDefaultColumnOrder() {
            return ['name', 'type', 'status', 'origin', 'created_at'];
        }
        
        function getColumnOrder() {
            const saved = localStorage.getItem(COLUMN_ORDER_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Migrate old column order: replace 'project' and 'data_source' with 'origin'
                    const migrated = parsed.map(col => {
                        if (col === 'project' || col === 'data_source') {
                            return 'origin';
                        }
                        return col;
                    }).filter((col, index, arr) => arr.indexOf(col) === index); // Remove duplicates
                    
                    // Validate that all default columns are present
                    const defaultOrder = getDefaultColumnOrder();
                    const hasAllColumns = defaultOrder.every(col => migrated.includes(col));
                    if (hasAllColumns && migrated.length === defaultOrder.length) {
                        // Save migrated order
                        if (JSON.stringify(migrated) !== JSON.stringify(parsed)) {
                            saveColumnOrder(migrated);
                        }
                        return migrated;
                    }
                } catch (e) {
                    console.warn('Failed to parse saved column order:', e);
                }
            }
            return getDefaultColumnOrder();
        }
        
        function saveColumnOrder(order) {
            localStorage.setItem(COLUMN_ORDER_KEY, JSON.stringify(order));
        }
        
        function initializeColumnDragAndDrop() {
            const tables = document.querySelectorAll('.notion-table');
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                if (!thead) return;
                
                const headers = Array.from(thead.querySelectorAll('th.draggable'));
                headers.forEach(header => {
                    header.addEventListener('dragstart', handleDragStart);
                    header.addEventListener('dragend', handleDragEnd);
                    header.addEventListener('dragover', handleDragOver);
                    header.addEventListener('drop', handleDrop);
                    header.addEventListener('dragleave', handleDragLeave);
                });
            });
        }
        
        let draggedColumn = null;
        
        function handleDragStart(e) {
            draggedColumn = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('drag-over');
            });
            draggedColumn = null;
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.target.closest('th.draggable');
            if (target && target !== draggedColumn) {
                target.classList.add('drag-over');
            }
            return false;
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('th.draggable');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const target = e.target.closest('th.draggable');
            if (!target || !draggedColumn || target === draggedColumn) {
                return false;
            }
            
            const table = target.closest('table');
            if (!table) return false;
            
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');
            
            if (!thead || !tbody) return false;
            
            // Get column names
            const draggedCol = draggedColumn.getAttribute('data-column');
            const targetCol = target.getAttribute('data-column');
            
            if (!draggedCol || !targetCol) return false;
            
            // Get current order
            const currentOrder = Array.from(thead.querySelectorAll('th.draggable'))
                .map(th => th.getAttribute('data-column'))
                .filter(col => col);
            
            // Calculate new order
            const draggedIndex = currentOrder.indexOf(draggedCol);
            const targetIndex = currentOrder.indexOf(targetCol);
            
            if (draggedIndex === -1 || targetIndex === -1) return false;
            
            // Remove dragged column from its current position
            const newOrder = [...currentOrder];
            newOrder.splice(draggedIndex, 1);
            
            // Insert at target position
            const insertIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
            newOrder.splice(insertIndex, 0, draggedCol);
            
            // Save new order
            saveColumnOrder(newOrder);
            
            // Reorder headers
            const headerMap = new Map();
            const nonDraggableHeaders = [];
            
            Array.from(thead.querySelectorAll('th')).forEach(th => {
                if (th.classList.contains('draggable')) {
                    const col = th.getAttribute('data-column');
                    if (col) {
                        headerMap.set(col, th);
                    }
                } else {
                    nonDraggableHeaders.push(th);
                }
            });
            
            thead.innerHTML = '';
            newOrder.forEach(col => {
                const header = headerMap.get(col);
                if (header) thead.appendChild(header);
            });
            nonDraggableHeaders.forEach(header => {
                thead.appendChild(header);
            });
            
            // Reorder body cells
            const rows = Array.from(tbody.querySelectorAll('tr'));
            rows.forEach(row => {
                const cellMap = new Map();
                const nonDraggableCells = [];
                
                Array.from(row.querySelectorAll('td')).forEach(cell => {
                    const col = cell.getAttribute('data-column');
                    if (col) {
                        cellMap.set(col, cell);
                    } else {
                        nonDraggableCells.push(cell);
                    }
                });
                
                row.innerHTML = '';
                newOrder.forEach(col => {
                    const cell = cellMap.get(col);
                    if (cell) row.appendChild(cell);
                });
                nonDraggableCells.forEach(cell => {
                    row.appendChild(cell);
                });
            });
            
            // Re-initialize drag and drop
            initializeColumnDragAndDrop();
            
            target.classList.remove('drag-over');
            return false;
        }
        
        function applyColumnOrder() {
            const order = getColumnOrder();
            const tables = document.querySelectorAll('.notion-table');
            
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                const tbody = table.querySelector('tbody');
                
                if (!thead || !tbody) return;
                
                // Get all headers and map them by column
                const allHeaders = Array.from(thead.querySelectorAll('th'));
                const headerMap = new Map();
                const nonDraggableHeaders = [];
                
                allHeaders.forEach(header => {
                    if (header.classList.contains('draggable')) {
                        const col = header.getAttribute('data-column');
                        if (col) {
                            headerMap.set(col, header);
                        }
                    } else {
                        nonDraggableHeaders.push(header);
                    }
                });
                
                // Reorder headers based on saved order
                const orderedHeaders = order.map(col => headerMap.get(col)).filter(h => h);
                
                // Clear and rebuild header row
                thead.innerHTML = '';
                orderedHeaders.forEach(header => {
                    thead.appendChild(header);
                });
                nonDraggableHeaders.forEach(header => {
                    thead.appendChild(header);
                });
                
                // Reorder body cells
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.forEach(row => {
                    const allCells = Array.from(row.querySelectorAll('td'));
                    const cellMap = new Map();
                    const nonDraggableCells = [];
                    
                    // Map cells by data-column attribute
                    allCells.forEach(cell => {
                        const col = cell.getAttribute('data-column');
                        if (col) {
                            cellMap.set(col, cell);
                        } else {
                            // Cells without data-column (like Actions) are non-draggable
                            nonDraggableCells.push(cell);
                        }
                    });
                    
                    // Clear and rebuild row in correct order
                    row.innerHTML = '';
                    order.forEach(col => {
                        const cell = cellMap.get(col);
                        if (cell) row.appendChild(cell);
                    });
                    nonDraggableCells.forEach(cell => {
                        row.appendChild(cell);
                    });
                });
            });
            
            // Re-initialize drag and drop after reordering
            initializeColumnDragAndDrop();
        }

        // Make insights functions globally accessible
        window.openCreateModal = openCreateModal;
        window.closeModal = closeModal;
        window.handleSearch = handleSearch;
        window.sortBy = sortBy;
        window.removeFilter = removeFilter;
        window.resetFilters = resetFilters;
        window.openFilterMenu = openFilterMenu;
        window.toggleFilterMenu = toggleFilterMenu;
        window.filterFilterOptions = filterFilterOptions;
        window.openFilterValueDialog = openFilterValueDialog;
        window.toggleFilterValue = toggleFilterValue;
        window.toggleInlineFilterValue = toggleInlineFilterValue;
        window.toggleInlineFilterDropdown = toggleInlineFilterDropdown;
        window.removeInlineFilter = removeInlineFilter;
        window.addDateFilter = addDateFilter;
        window.closeFilterValueDialog = closeFilterValueDialog;
        window.removeFilterByIndex = removeFilterByIndex;
        window.editInsight = editInsight;
        window.deleteInsight = deleteInsight;
        window.handleInsightCheckboxChange = handleInsightCheckboxChange;
        window.toggleSelectAllInsights = toggleSelectAllInsights;
        window.deleteSelectedInsights = deleteSelectedInsights;
        window.updateInsightStatus = updateInsightStatus;
        window.saveInsight = saveInsight;
        window.openInsightNotes = openInsightNotes;
        window.closeInsightNotes = closeInsightNotes;
        window.initInsightsPage = initInsightsPage;
        window.applyColumnOrder = applyColumnOrder;
        window.initializeColumnDragAndDrop = initializeColumnDragAndDrop;
        
        // Debug: Verify function is accessible
        console.log('[DEBUG] ========== Function Exposure Check ==========');
        console.log('[DEBUG] updateInsightStatus function exposed to window:', typeof window.updateInsightStatus);
        console.log('[DEBUG] updateInsightStatus function:', window.updateInsightStatus);
        console.log('[DEBUG] insightsCurrentClientId:', insightsCurrentClientId);
        console.log('[DEBUG] API_BASE_URL:', API_BASE_URL);
        console.log('[DEBUG] getAuthHeadersSafe function exists:', typeof getAuthHeadersSafe !== 'undefined');
        console.log('[DEBUG] ============================================');

        // Close modal/panel handlers
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('insightModal');
            if (modal && modal.classList.contains('active') && e.target === modal) {
                closeModal();
            }
            
            // Check for slideoutOverlay (SlideoutPanel) instead of insightNotesOverlay
            const overlay = document.getElementById('slideoutOverlay');
            if (overlay && e.target === overlay && window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                closeInsightNotes();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('insightModal');
                if (modal && modal.classList.contains('active')) {
                    closeModal();
                }
                
                // Check for slideoutPanel (SlideoutPanel) instead of insightNotesPanel
                const panel = document.getElementById('slideoutPanel');
                if (panel && panel.classList.contains('open') && window.SlideoutPanel && window.SlideoutPanel.isOpen) {
                    closeInsightNotes();
                }
            }
        });

        // Removed: closeInsightNotesPanel button event listener - now using SlideoutPanel's close button
        
        const authCheck = typeof Auth !== 'undefined' ? Auth.checkAuth() : Promise.resolve(false);
        authCheck.then(authenticated => {
            console.log('Auth check result:', authenticated);
            if (!authenticated) {
                console.log('Not authenticated, showing login');
                if (typeof Auth !== 'undefined') {
                    Auth.showLogin();
                }
            }
        }).catch(error => {
            console.error('Error in checkAuth:', error);
        });
        
        // Slideout Panel - handles AI Insights, Verbatims, Insight Notes, and Create Insight
        const SlideoutPanel = {
            isOpen: false,
            currentMode: null, // 'ai-insights', 'verbatims', 'insight-notes', 'create-insight', or 'chart'
            currentContext: null,
            currentDimensionRef: null,  // Track current dimension
            currentInsightEditor: null,  // Tiptap editor instance for insight notes
            currentInsightId: null,  // Currently open insight ID
            currentInsightData: null,  // Full insight data for editing
            createInsightContext: null,  // Context data for creating new insight
            navigationStack: [],  // Navigation stack: [{level, data, view}], levels: 'insight', 'chart', 'verbatims'
            dataSourceNameCache: {},  // Cache for data source names: {dataSourceId: name}
            currentChartCategoryName: null,  // Current chart view category
            currentChartTopicName: null,  // Current chart view topic (if any)
            currentChartDataSourceId: null,  // Current chart view data source
            currentChartDimensionName: null,  // Current chart view dimension
            
            init() {
                const tab = document.getElementById('slideoutTab');
                const panel = document.getElementById('slideoutPanel');
                const closeBtn = document.getElementById('closeSlideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                
                if (!tab || !panel) return;
                
                // Ensure tab is hidden initially
                tab.style.display = 'none';
                
                // Open on tab click
                tab.addEventListener('click', () => this.openAIInsights());
                
                // Close handlers
                if (closeBtn) closeBtn.addEventListener('click', () => this.close());
                if (overlay) overlay.addEventListener('click', () => this.close());
                
                // ESC key to close
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.close();
                    }
                });
                
                console.log('Slideout Panel initialized');
            },
            
            setCurrentDimension(dimensionRef) {
                this.currentDimensionRef = dimensionRef;
                console.log('Current dimension set to:', dimensionRef);
                
                // Show/hide the AI Insights tab based on whether a dimension is selected
                // TEMPORARILY DISABLED: Tab hidden until further notice
                const tab = document.getElementById('slideoutTab');
                if (tab) {
                    // Always keep tab hidden
                    tab.style.display = 'none';
                    // Close the panel if it's open
                    this.close();
                }
            },
            
            async openAIInsights() {
                // Get current context from the app state
                const clientSelect = document.getElementById('clientSelect');
                const client_uuid = clientSelect?.value;
                
                // Get data source (look for active project/source)
                const data_source = this.getCurrentDataSource();
                const dimension_ref = this.currentDimensionRef;
                
                if (!client_uuid) {
                    alert('Please select a client first');
                    return;
                }
                
                if (!dimension_ref) {
                    alert('Please select a dimension first by clicking on a treemap section');
                    return;
                }
                
                this.currentContext = { client_uuid, data_source, dimension_ref };
                this.currentMode = 'ai-insights';
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                
                // For AI insights mode, keep title as h2 (not editable)
                if (title) {
                    title.textContent = 'AI-Generated Insights';
                    // Remove contenteditable if it was set
                    title.removeAttribute('contenteditable');
                    title.setAttribute('data-placeholder', '');
                }
                if (panel) panel.classList.add('open');
                if (overlay) overlay.classList.add('visible');
                this.isOpen = true;
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Load content
                await this.loadSummary();
            },
            
            openVerbatims(verbatims, topicName, categoryName, skipUIUpdates = false, skipStackPush = false) {
                console.log('[BreadcrumbNav] SlideoutPanel.openVerbatims called with:', { 
                    verbatimsCount: verbatims?.length, 
                    topicName, 
                    categoryName,
                    firstVerbatim: verbatims?.[0],
                    currentMode: this.currentMode,
                    skipUIUpdates,
                    skipStackPush
                });
                
                // Save current state to navigation stack if not already in verbatims mode and not skipped
                if (!skipStackPush && this.currentMode !== 'verbatims') {
                    if (this.currentMode === 'chart') {
                        // Save chart state
                        this.navigationStack.push({
                            level: 'chart',
                            data: { 
                                categoryName: categoryName || null,
                                topicName: topicName || null
                            },
                            view: 'chart'
                        });
                        console.log('[BreadcrumbNav] Pushed chart state to stack');
                    } else if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                        // Save insight state
                        this.navigationStack.push({
                            level: 'insight',
                            data: { insightId: this.currentInsightId },
                            view: 'insight'
                        });
                        console.log('[BreadcrumbNav] Pushed insight state to stack');
                    }
                }
                
                this.currentMode = 'verbatims';
                this.currentVerbatimsData = verbatims;
                this.currentTopicName = topicName;
                this.currentCategoryName = categoryName;
                this.verbatimSearchTerm = '';
                
                // Update UI (unless already updated by caller)
                if (!skipUIUpdates) {
                    // Open UI
                    const panel = document.getElementById('slideoutPanel');
                    const overlay = document.getElementById('slideoutOverlay');
                    const title = document.getElementById('slideoutTitle');
                    const subtitle = document.getElementById('slideoutSubtitle');
                    const searchBox = document.getElementById('slideoutSearch');
                    const settingsBtn = document.getElementById('slideoutSettingsBtn');
                    
                    // Show search and settings for verbatims
                    if (searchBox) {
                        searchBox.style.display = 'block';
                        // Also show the wrapper div that contains the search box
                        const searchContainer = document.getElementById('slideoutSearchContainer');
                        if (searchContainer) {
                            searchContainer.style.display = 'block';
                        }
                    }
                    if (settingsBtn) settingsBtn.style.display = 'block';
                    
                    // For verbatims mode, keep title as h2 (not editable)
                    if (title) {
                        title.textContent = topicName || categoryName || 'Verbatims';
                        // Remove contenteditable if it was set
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    if (subtitle) {
                        subtitle.textContent = `${categoryName || ''}  ${verbatims.length} verbatim${verbatims.length !== 1 ? 's' : ''}`;
                        subtitle.style.display = 'block';
                    }
                    
                    // Update back button
                    this.updateBackButton();
                    
                    if (panel) panel.classList.add('open');
                    if (overlay) overlay.classList.add('visible');
                    this.isOpen = true;
                    
                    // Prevent body scroll
                    document.body.classList.add('slideout-open');
                    
                    // Update search bar z-index when slideout opens
                    if (typeof updateTreemapSearchZIndex === 'function') {
                        updateTreemapSearchZIndex();
                    }
                }
                
                // Render verbatims
                this.renderVerbatims(verbatims, topicName, categoryName);
            },
            
            async openCreateInsight(contextData, fromContextMenu = false) {
                console.log('[SlideoutPanel.openCreateInsight] Called with contextData:', contextData);
                console.log('[SlideoutPanel.openCreateInsight] currentClientId:', currentClientId);
                console.log('[SlideoutPanel.openCreateInsight] fromContextMenu:', fromContextMenu);
                
                if (!currentClientId) {
                    console.error('[SlideoutPanel.openCreateInsight] No client selected');
                    return;
                }
                
                // Reset navigation stack when creating new insight
                this.navigationStack = [];
                this.updateBackButton();
                
                this.currentMode = 'create-insight';
                this.createInsightContext = contextData;
                this.currentInsightId = null; // No existing insight
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const content = document.getElementById('slideoutContent');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                
                console.log('[SlideoutPanel.openCreateInsight] UI elements:', {
                    panel: !!panel,
                    overlay: !!overlay,
                    title: !!title,
                    subtitle: !!subtitle,
                    content: !!content,
                    searchBox: !!searchBox,
                    settingsBtn: !!settingsBtn
                });
                
                // Hide search and settings (only for verbatims)
                if (searchBox) {
                    searchBox.style.display = 'none';
                    // Also hide the wrapper div that contains the search box to remove unnecessary spacing
                    const searchContainer = document.getElementById('slideoutSearchContainer');
                    if (searchContainer) {
                        searchContainer.style.display = 'none';
                    }
                }
                if (settingsBtn) settingsBtn.style.display = 'none';
                if (subtitle) subtitle.style.display = 'none';
                
                // Set editable title in header (empty for new insight)
                if (title) {
                    title.textContent = '';
                    title.setAttribute('data-placeholder', 'New Insight');
                    title.setAttribute('contenteditable', 'true');
                }
                
                if (panel) {
                    console.log('[SlideoutPanel.openCreateInsight] Adding "open" class to panel');
                    panel.classList.add('open');
                    console.log('[SlideoutPanel.openCreateInsight] Panel classes after adding open:', panel.classList.toString());
                } else {
                    console.error('[SlideoutPanel.openCreateInsight] Panel element not found!');
                }
                
                if (overlay) {
                    console.log('[SlideoutPanel.openCreateInsight] Adding "visible" class to overlay');
                    overlay.classList.add('visible');
                } else {
                    console.error('[SlideoutPanel.openCreateInsight] Overlay element not found!');
                }
                
                this.isOpen = true;
                
                // Focus the title input after panel is opened
                if (title) {
                    setTimeout(() => {
                        title.focus();
                    }, 100);
                }
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                console.log('[SlideoutPanel.openCreateInsight] Body classes:', document.body.classList.toString());
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Initialize panel with empty form, pre-populated with context
                console.log('[SlideoutPanel.openCreateInsight] Calling initializeCreateInsightPanel');
                await this.initializeCreateInsightPanel(content, contextData, fromContextMenu);
                console.log('[SlideoutPanel.openCreateInsight] Panel initialization complete');
            },
            
            async openInsightNotes(insightId) {
                if (!currentClientId) {
                    console.error('No client selected');
                    return;
                }
                
                this.currentMode = 'insight-notes';
                this.currentInsightId = insightId;
                
                // Open UI
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const content = document.getElementById('slideoutContent');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                
                // Hide search and settings (only for verbatims)
                if (searchBox) searchBox.style.display = 'none';
                const searchContainer = document.getElementById('slideoutSearchContainer');
                if (searchContainer) searchContainer.style.display = 'none';
                if (settingsBtn) settingsBtn.style.display = 'none';
                if (subtitle) subtitle.style.display = 'none';
                
                if (panel) panel.classList.add('open');
                if (overlay) overlay.classList.add('visible');
                this.isOpen = true;
                
                // Prevent body scroll
                document.body.classList.add('slideout-open');
                
                // Update search bar z-index when slideout opens
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                // Load insight data
                try {
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${insightId}`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to load insight');
                    }
                    
                    const insight = await response.json();
                    this.currentInsightData = insight; // Store full insight data
                    
                    // Hide title in header, we'll show it in content
                    if (title) title.textContent = '';
                    
                    // Initialize panel with attributes and editor
                    await this.initializeInsightPanel(content, insight);
                    
                    // Remove transitioning class from all elements (for smooth fade-in)
                    const updatedContent = document.getElementById('slideoutContent');
                    const updatedTitle = document.getElementById('slideoutTitle');
                    const updatedSubtitle = document.getElementById('slideoutSubtitle');
                    const updatedSearchBox = document.getElementById('slideoutSearch');
                    const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                    
                    if (updatedContent) {
                        void updatedContent.offsetHeight;
                        updatedContent.classList.remove('transitioning');
                    }
                    if (updatedTitle) {
                        void updatedTitle.offsetHeight;
                        updatedTitle.classList.remove('transitioning');
                    }
                    if (updatedSubtitle) {
                        void updatedSubtitle.offsetHeight;
                        updatedSubtitle.classList.remove('transitioning');
                    }
                    if (updatedSearchBox) {
                        void updatedSearchBox.offsetHeight;
                        updatedSearchBox.classList.remove('transitioning');
                    }
                    if (updatedSettingsBtn) {
                        void updatedSettingsBtn.offsetHeight;
                        updatedSettingsBtn.classList.remove('transitioning');
                    }
                } catch (error) {
                    console.error('Error loading insight:', error);
                    if (content) {
                        content.innerHTML = `<div style="padding: 24px; color: #666;">Error loading insight: ${error.message}</div>`;
                    }
                    // Remove transitioning from all elements even on error
                    const allElements = [content, title, subtitle, searchBox, settingsBtn].filter(Boolean);
                    allElements.forEach(el => {
                        void el.offsetHeight;
                        el.classList.remove('transitioning');
                    });
                }
            },
            
            // Helper function to get verbatims from context data
            getVerbatimsFromContext(contextData) {
                if (!contextData || !hierarchyData) return [];
                
                const categoryName = contextData.category;
                const topicName = contextData.topic_label;
                const type = contextData.type;
                
                if (!categoryName) return [];
                
                // Find the category in hierarchy
                const categoryData = findCategoryInHierarchy(categoryName);
                if (!categoryData) return [];
                
                // If it's a topic, get verbatims from that specific topic
                if (type === 'topic' && topicName) {
                    const topicData = findTopicInCategory(categoryData, topicName);
                    if (topicData && topicData.verbatims) {
                        return topicData.verbatims;
                    }
                }
                
                // If it's a category, get all verbatims from that category
                if (type === 'category') {
                    return collectCategoryVerbatims(categoryData);
                }
                
                return [];
            },
            
            async initializeCreateInsightPanel(container, contextData, fromContextMenu = false) {
                console.log('[initializeCreateInsightPanel] Called');
                console.log('[initializeCreateInsightPanel] Container:', container);
                console.log('[initializeCreateInsightPanel] ContextData:', contextData);
                console.log('[initializeCreateInsightPanel] fromContextMenu:', fromContextMenu);
                
                if (!container) {
                    console.error('[initializeCreateInsightPanel] Container is null or undefined!');
                    return;
                }
                
                // Build origin object from context data
                // Map 'type' field to 'origin_type' (contextData.type is 'category' or 'topic')
                const origin = {
                    origin_type: contextData.type || contextData.origin_type || 'category',
                    process_voc_id: contextData.process_voc_id || null,
                    project_name: contextData.project_name || null,
                    data_source: contextData.data_source || null,
                    dimension_ref: contextData.dimension_ref || null,
                    dimension_name: contextData.dimension_name || null,
                    category: contextData.category || null,
                    topic_label: contextData.topic_label || null,
                };
                
                // Extract breadcrumb data from context data
                const categoryName = contextData.category || null;
                const topicName = contextData.topic_label || null;
                const dataSourceName = contextData.data_source || null; // This is the name, not ID in contextData
                const dimensionName = contextData.dimension_name || null;
                const dimensionRef = contextData.dimension_ref || null;
                
                console.log('[BreadcrumbNav] initializeCreateInsightPanel - Extracted breadcrumb data:', { categoryName, topicName, dataSourceName, dimensionName, dimensionRef });
                
                // Get verbatims for this context
                let availableVerbatims = this.getVerbatimsFromContext(contextData);
                
                // Check if there's a pre-pinned verbatim to add
                if (this.prePinnedVerbatim) {
                    // Find the verbatim in availableVerbatims by matching text and index
                    const prePinnedIndex = availableVerbatims.findIndex(v => {
                        const textMatch = v.text === this.prePinnedVerbatim.text;
                        const indexMatch = (v.index !== undefined && this.prePinnedVerbatim.index !== undefined) 
                            ? v.index === this.prePinnedVerbatim.index 
                            : true; // If index not available, just match by text
                        return textMatch && indexMatch;
                    });
                    
                    if (prePinnedIndex >= 0) {
                        // Found in available verbatims, store index to pin it
                        this.prePinnedVerbatimIndex = prePinnedIndex;
                    } else {
                        // Not found in available verbatims, add it to the list
                        availableVerbatims.push(this.prePinnedVerbatim);
                        this.prePinnedVerbatimIndex = availableVerbatims.length - 1;
                    }
                } else {
                    this.prePinnedVerbatimIndex = null;
                }
                
                // Build breadcrumb HTML with pill format (matching insights list)
                const breadcrumbParts = [];
                if (dataSourceName) {
                    const pascalDataSource = toPascalCase(dataSourceName);
                    breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDataSource)}</span>`);
                }
                if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    // Make dimension clickable if we have dimension_ref
                    if (dimensionRef) {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill" data-breadcrumb-click="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtml(dimensionName)}" style="cursor: pointer;">${escapeHtml(pascalDimension)}</span>`);
                    } else {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDimension)}</span>`);
                    }
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    // For create mode, we don't have data source ID yet, so we'll pass the name
                    breadcrumbParts.push(`<span class="tag tag-category insight-origin-pill" data-breadcrumb-click="category" data-category="${escapeHtml(categoryName)}" data-topic="${topicName ? escapeHtml(topicName) : ''}" data-data-source-name="${dataSourceName || ''}" data-dimension="${dimensionName || ''}" style="cursor: pointer;">${escapeHtml(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    breadcrumbParts.push(`<span class="tag tag-topic insight-origin-pill" data-breadcrumb-click="topic" data-category="${categoryName ? escapeHtml(categoryName) : ''}" data-topic="${escapeHtml(topicName)}" data-data-source-name="${dataSourceName || ''}" data-dimension="${dimensionName || ''}" style="cursor: pointer;">${escapeHtml(pascalTopic)}</span>`);
                }
                
                const breadcrumbHTML = breadcrumbParts.length > 0 
                    ? breadcrumbParts.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '';
                
                console.log('[BreadcrumbNav] initializeCreateInsightPanel - Generated breadcrumb HTML');
                
                // Create panel structure with attributes (title is now in header)
                // Use flexbox layout with scrollable content and fixed footer
                // Adjust padding and gap when opened from context menu to reduce whitespace
                const attributesPadding = fromContextMenu ? '0.5rem 1.5rem 0.75rem 1.5rem' : '1rem 1.5rem';
                const attributesGap = fromContextMenu ? '0.5rem' : '0.75rem';
                const hasBreadcrumb = breadcrumbHTML && !fromContextMenu;
                container.innerHTML = `
                    <div style="padding: 0; display: flex; flex-direction: column; height: 100%;">
                        <!-- Scrollable Content Area -->
                        <div style="flex: 1; overflow-y: auto; display: flex; flex-direction: column;">
                            <!-- Attributes Section - Only show if there's breadcrumb content -->
                            ${hasBreadcrumb ? `
                            <div style="padding: ${attributesPadding}; border-bottom: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div id="insightAttributes" style="display: flex; flex-direction: column; gap: ${attributesGap};">
                                    <!-- Breadcrumb -->
                                    <div class="insight-attribute-row">
                                        <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 500; color: oklch(0.556 0 0); flex-shrink: 0;">Origin</div>
                                        <div style="flex: 1;">
                                            ${breadcrumbHTML}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                            
                            <!-- Notes Section -->
                            <div style="padding: 1.5rem; flex-shrink: 0; border-top: none;">
                                <div id="insightNotesSaveStatus" style="font-size: 0.75rem; font-family: 'Lato', sans-serif; color: oklch(0.556 0 0); margin-bottom: 0.5rem; min-height: 1rem;"></div>
                                <div id="insightNotesEditor" style="min-height: 200px; outline: none; font-size: 0.875rem; font-family: 'Lato', sans-serif; line-height: 1.5; color: oklch(0.145 0 0);"></div>
                            </div>
                            
                            <!-- Verbatims Section -->
                            <div style="padding: 1.5rem; border-top: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 600; color: oklch(0.145 0 0); margin-bottom: 0.75rem;">
                                    Verbatims (${availableVerbatims.length})
                                </div>
                                <div id="insightVerbatimsList" style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;">
                                    <!-- Verbatims will be rendered here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Fixed Footer with Save Button -->
                        <div style="padding: 1rem 1.5rem; border-top: 1px solid oklch(0.922 0 0); background: oklch(0.98 0 0); display: flex; justify-content: flex-end; flex-shrink: 0; position: sticky; bottom: 0;">
                            <button id="saveNewInsightBtn" style="background: #B9F040; color: #000; border: none; padding: 0.5rem 1.5rem; border-radius: 0.5rem; font-weight: 600; font-size: 0.875rem; font-family: 'Lato', sans-serif; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#a0d636'" onmouseout="this.style.background='#B9F040'">
                                Create Insight
                            </button>
                        </div>
                    </div>
                `;
                
                // Store available verbatims and initialize pinned verbatims set
                this.availableVerbatims = availableVerbatims;
                this.pinnedVerbatims = new Set();
                
                // Pre-pin the verbatim if it was provided
                if (this.prePinnedVerbatimIndex !== null && this.prePinnedVerbatimIndex !== undefined) {
                    this.pinnedVerbatims.add(this.prePinnedVerbatimIndex);
                }
                
                // Clear the pre-pinned verbatim after using it
                this.prePinnedVerbatim = null;
                this.prePinnedVerbatimIndex = null;
                
                // Store origin for saving
                this.createInsightOrigin = origin;
                
                // Set up editable title in header (no auto-save in create mode)
                const titleEl = document.getElementById('slideoutTitle');
                if (titleEl) {
                    titleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            titleEl.blur();
                        }
                    });
                }
                
                // Set up save button
                const saveBtn = document.getElementById('saveNewInsightBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => {
                        this.saveNewInsight();
                    });
                }
                
                // Set up breadcrumb click handlers
                const breadcrumbClickItems = container.querySelectorAll('[data-breadcrumb-click]');
                breadcrumbClickItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        const clickType = item.getAttribute('data-breadcrumb-click');
                        const catName = item.getAttribute('data-category') || null;
                        const topName = item.getAttribute('data-topic') || null;
                        const dsName = item.getAttribute('data-data-source-name') || null;
                        const dimName = item.getAttribute('data-dimension') || null;
                        const dimRef = item.getAttribute('data-dimension-ref') || null;
                        
                        console.log('[BreadcrumbNav] initializeCreateInsightPanel - Breadcrumb clicked:', { clickType, catName, topName, dsName, dimName, dimRef });
                        
                        if (clickType === 'dimension' && dimRef) {
                            // Dimension click: navigate to visualizations and filter by dimension
                            navigateToView('visualizations');
                            
                            // Set the dimension selector to the clicked dimension
                            const questionSelect = document.getElementById('questionSelect');
                            if (questionSelect) {
                                const previousRefKey = currentQuestionRefKey;
                                questionSelect.value = dimRef;
                                currentQuestionRefKey = dimRef;
                                
                                // Filter by this dimension (this will reload charts/data in the background)
                                filterByQuestion(dimRef, previousRefKey);
                                
                                // Update navigation links
                                updateNavLinks();
                                
                                // Update AI Insights panel with current dimension
                                if (window.AIInsightsPanel) {
                                    window.AIInsightsPanel.setCurrentDimension(dimRef);
                                }
                            }
                        } else if (clickType === 'category' || clickType === 'topic') {
                            // For create mode, we need to find the data source ID from the name
                            // We'll navigate to chart view, and it should work with current rawData
                            this.navigateToChart(catName, topName, null, dimName);
                        }
                    });
                });
                
                // Initialize editor with empty notes
                await this.initializeInsightEditor(document.getElementById('insightNotesEditor'), '');
                
                // Render verbatims list
                this.renderVerbatimsList();
            },
            
            // Render verbatims list with pin icons
            renderVerbatimsList() {
                const container = document.getElementById('insightVerbatimsList');
                if (!container) return;
                
                if (!this.availableVerbatims || this.availableVerbatims.length === 0) {
                    container.innerHTML = '<div style="padding: 1rem; text-align: center; color: oklch(0.556 0 0); font-size: 0.875rem; font-family: \'Lato\', sans-serif;">No verbatims available</div>';
                    return;
                }
                
                container.innerHTML = this.availableVerbatims.map((verbatim, index) => {
                    const isPinned = this.pinnedVerbatims.has(index);
                    const verbatimText = escapeHtml((verbatim.text || '').substring(0, 200)) + (verbatim.text && verbatim.text.length > 200 ? '...' : '');
                    
                    return `
                        <div class="insight-verbatim-item" data-index="${index}" style="
                            display: flex;
                            align-items: flex-start;
                            gap: 0.75rem;
                            padding: 0.75rem;
                            border: 1px solid oklch(0.922 0 0);
                            border-radius: 0.5rem;
                            background: ${isPinned ? 'oklch(0.98 0.02 120)' : 'oklch(1 0 0)'};
                            transition: all 0.2s ease;
                            cursor: pointer;
                        " onmouseover="this.style.borderColor='oklch(0.8 0 0)'" onmouseout="this.style.borderColor='oklch(0.922 0 0)'">
                            <div style="flex: 1; font-size: 0.875rem; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); line-height: 1.5;">
                                ${verbatimText}
                            </div>
                            <button class="verbatim-pin-btn" data-index="${index}" style="
                                background: none;
                                border: none;
                                cursor: pointer;
                                padding: 0.25rem;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                flex-shrink: 0;
                                color: ${isPinned ? '#B9F040' : 'oklch(0.556 0 0)'};
                                transition: all 0.2s ease;
                            " onclick="event.stopPropagation(); SlideoutPanel.togglePinVerbatim(${index})" title="${isPinned ? 'Unpin verbatim' : 'Pin verbatim'}">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="${isPinned ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M8 2v12M5 6l3-4 3 4"/>
                                    ${isPinned ? '<circle cx="8" cy="6" r="1.5" fill="currentColor"/>' : ''}
                                </svg>
                            </button>
                        </div>
                    `;
                }).join('');
            },
            
            // Toggle pin state for a verbatim
            togglePinVerbatim(index) {
                if (this.pinnedVerbatims.has(index)) {
                    this.pinnedVerbatims.delete(index);
                } else {
                    this.pinnedVerbatims.add(index);
                }
                // Re-render to update visual state
                this.renderVerbatimsList();
            },
            
            async saveNewInsight() {
                if (!currentClientId) {
                    alert('No client selected');
                    return;
                }
                
                const titleEl = document.getElementById('slideoutTitle');
                
                const name = titleEl?.textContent.trim() || '';
                const notes = this.currentInsightEditor ? this.currentInsightEditor.getHTML() : '';
                
                console.log('[saveNewInsight] Notes content:', notes);
                console.log('[saveNewInsight] Notes contains blob URL:', notes.includes('blob:'));
                
                // Check for blob URLs and warn user
                if (notes.includes('blob:')) {
                    console.warn('[saveNewInsight] WARNING: Notes contain blob URLs - images may not persist!');
                    const blobUrlMatch = notes.match(/blob:[^"'\s]+/);
                    if (blobUrlMatch) {
                        console.warn('[saveNewInsight] Blob URL found:', blobUrlMatch[0]);
                    }
                    // Still allow save, but warn user
                    if (!confirm('Warning: Some images are still uploading. They may not appear after saving. Continue anyway?')) {
                        return;
                    }
                }
                
                if (!name || name === 'AI-Generated Insights') {
                    alert('Please enter an insight name');
                    return;
                }
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                if (statusEl) statusEl.textContent = 'Creating...';
                
                // Collect pinned verbatims
                const pinnedVerbatimsArray = [];
                if (this.pinnedVerbatims && this.availableVerbatims) {
                    this.pinnedVerbatims.forEach(index => {
                        if (this.availableVerbatims[index]) {
                            pinnedVerbatimsArray.push(this.availableVerbatims[index]);
                        }
                    });
                }
                
                try {
                    const insightData = {
                        name: name,
                        type: '',
                        application: '',
                        notes: notes || null,
                        origins: [this.createInsightOrigin],
                        verbatims: pinnedVerbatimsArray.length > 0 ? pinnedVerbatimsArray : null,
                    };
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights`, {
                        method: 'POST',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(insightData)
                    });
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ detail: 'Failed to create insight' }));
                        throw new Error(error.detail || 'Failed to create insight');
                    }
                    
                    const newInsight = await response.json();
                    
                    if (statusEl) {
                        statusEl.textContent = 'Created!';
                        statusEl.style.color = '#B9F040';
                    }
                    
                    // Always refresh insights list so new insight appears when navigating to insights tab
                    // Check if insights section is visible to refresh it immediately
                    const insightsSection = document.getElementById('insights-section');
                    const isInsightsViewActive = insightsSection && insightsSection.classList.contains('active');
                    
                    console.log('[saveNewInsight] Insights section check:', {
                        element: !!insightsSection,
                        isActive: isInsightsViewActive,
                        hasLoadInsightsPage: typeof loadInsightsPage === 'function',
                        hasLoadInsights: typeof loadInsights === 'function'
                    });
                    
                    // Always try to refresh insights page first (for insights tab)
                    if (typeof loadInsightsPage === 'function') {
                        console.log('[saveNewInsight] Refreshing insights list via loadInsightsPage()');
                        loadInsightsPage();
                    }
                    
                    // Also refresh the other insights view if it exists (for compatibility)
                    if (typeof loadInsights === 'function') {
                        console.log('[saveNewInsight] Refreshing insights list via loadInsights()');
                        loadInsights();
                    }
                    
                    // Reset insights initialization flag so it can reload if needed
                    if (window.insightsInitialized) {
                        window.insightsInitialized = false;
                    }
                    
                    // Close panel after a brief delay
                    setTimeout(() => {
                        this.close();
                        // Optionally open the newly created insight
                        // this.openInsightNotes(newInsight.id);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error creating insight:', error);
                    if (statusEl) {
                        statusEl.textContent = 'Error creating';
                        statusEl.style.color = 'oklch(0.577 0.245 27.325)';
                    }
                    alert('Error creating insight: ' + error.message);
                }
            },
            
            async initializeInsightPanel(container, insight) {
                console.log('[BreadcrumbNav] initializeInsightPanel called for insight:', insight.id);
                if (!container) return;
                
                // Reset navigation stack when opening a new insight
                this.navigationStack = [];
                this.updateBackButton();
                
                // Extract breadcrumb data from origins JSONB
                const firstOrigin = insight.origins?.[0] || {};
                const categoryName = firstOrigin.category || null;
                const topicName = firstOrigin.topic_label || null;
                const dataSourceId = firstOrigin.data_source || null;
                const dimensionName = firstOrigin.dimension_name || null;
                const dimensionRef = firstOrigin.dimension_ref || null;
                
                console.log('[BreadcrumbNav] Extracted breadcrumb data:', { categoryName, topicName, dataSourceId, dimensionName, dimensionRef });
                
                // Fetch data source name
                let dataSourceName = null;
                if (dataSourceId) {
                    dataSourceName = await this.fetchDataSourceName(dataSourceId);
                    console.log('[BreadcrumbNav] Fetched data source name:', dataSourceName);
                }
                
                // Set editable title in header
                const insightTitleEl = document.getElementById('slideoutTitle');
                if (insightTitleEl) {
                    insightTitleEl.textContent = toPascalCase(insight.name || '');
                    insightTitleEl.setAttribute('data-placeholder', 'Insight Title');
                    insightTitleEl.setAttribute('contenteditable', 'true');
                }
                
                // Get verbatims from insight
                const insightVerbatims = insight.verbatims || [];
                
                // Build breadcrumb HTML with pill format (matching insights list)
                const breadcrumbParts = [];
                if (dataSourceName) {
                    const pascalDataSource = toPascalCase(dataSourceName);
                    breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDataSource)}</span>`);
                }
                if (dimensionName) {
                    const pascalDimension = toPascalCase(dimensionName);
                    // Make dimension clickable if we have dimension_ref
                    if (dimensionRef) {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill" data-breadcrumb-click="dimension" data-dimension-ref="${dimensionRef}" data-dimension-name="${escapeHtml(dimensionName)}" style="cursor: pointer;">${escapeHtml(pascalDimension)}</span>`);
                    } else {
                        breadcrumbParts.push(`<span class="tag tag-data-source insight-origin-pill">${escapeHtml(pascalDimension)}</span>`);
                    }
                }
                if (categoryName) {
                    const pascalCategory = toPascalCase(categoryName);
                    breadcrumbParts.push(`<span class="tag tag-category insight-origin-pill" data-breadcrumb-click="category" data-category="${escapeHtml(categoryName)}" data-topic="${topicName ? escapeHtml(topicName) : ''}" data-data-source="${dataSourceId || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" style="cursor: pointer;">${escapeHtml(pascalCategory)}</span>`);
                }
                if (topicName) {
                    const pascalTopic = toPascalCase(topicName);
                    breadcrumbParts.push(`<span class="tag tag-topic insight-origin-pill" data-breadcrumb-click="topic" data-category="${categoryName ? escapeHtml(categoryName) : ''}" data-topic="${escapeHtml(topicName)}" data-data-source="${dataSourceId || ''}" data-dimension="${dimensionName || ''}" data-dimension-ref="${dimensionRef || ''}" style="cursor: pointer;">${escapeHtml(pascalTopic)}</span>`);
                }
                
                const breadcrumbHTML = breadcrumbParts.length > 0 
                    ? breadcrumbParts.join('<span style="margin: 0 4px; color: oklch(0.7 0 0);">|</span>')
                    : '';
                
                console.log('[BreadcrumbNav] Generated breadcrumb HTML');
                
                // Create panel structure with attributes (title is now in header)
                container.innerHTML = `
                    <div style="padding: 0; display: flex; flex-direction: column; height: 100%;">
                        <!-- Scrollable Content Area -->
                        <div style="flex: 1; overflow-y: auto; display: flex; flex-direction: column;">
                            <!-- Attributes Section -->
                            <div style="padding: 1rem 1.5rem; border-bottom: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div id="insightAttributes" style="display: flex; flex-direction: column; gap: 0.75rem;">
                                    <!-- Breadcrumb -->
                                    ${breadcrumbHTML ? `
                                    <div class="insight-attribute-row">
                                        <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 500; color: oklch(0.556 0 0); flex-shrink: 0;">Origin</div>
                                        <div style="flex: 1;">
                                            ${breadcrumbHTML}
                                        </div>
                                    </div>
                                    ` : ''}
                                    
                                </div>
                            </div>
                            
                            <!-- Notes Section -->
                            <div style="padding: 1.5rem; flex-shrink: 0;">
                                <div id="insightNotesSaveStatus" style="font-size: 0.75rem; font-family: 'Lato', sans-serif; color: oklch(0.556 0 0); margin-bottom: 0.5rem; min-height: 1rem;"></div>
                                <div id="insightNotesEditor" style="min-height: 200px; outline: none; font-size: 0.875rem; font-family: 'Lato', sans-serif; line-height: 1.5; color: oklch(0.145 0 0);"></div>
                            </div>
                            
                            <!-- Verbatims Section (read-only) -->
                            ${insightVerbatims.length > 0 ? `
                            <div style="padding: 1.5rem; border-top: 1px solid oklch(0.922 0 0); flex-shrink: 0;">
                                <div style="font-size: 0.875rem; font-family: 'Lato', sans-serif; font-weight: 600; color: oklch(0.145 0 0); margin-bottom: 0.75rem;">
                                    Pinned Verbatims (${insightVerbatims.length})
                                </div>
                                <div id="insightVerbatimsList" style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;">
                                    ${insightVerbatims.map(verbatim => {
                                        const verbatimText = escapeHtml((verbatim.text || '').substring(0, 200)) + (verbatim.text && verbatim.text.length > 200 ? '...' : '');
                                        return `
                                            <div class="insight-verbatim-item" style="
                                                display: flex;
                                                align-items: flex-start;
                                                gap: 0.75rem;
                                                padding: 0.75rem;
                                                border: 1px solid oklch(0.922 0 0);
                                                border-radius: 0.5rem;
                                                background: oklch(0.98 0.02 120);
                                            ">
                                                <div style="flex: 1; font-size: 0.875rem; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); line-height: 1.5;">
                                                    ${verbatimText}
                                                </div>
                                                <div style="flex-shrink: 0; color: #B9F040; display: flex; align-items: center; justify-content: center; padding: 0.25rem;">
                                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M8 2v12M5 6l3-4 3 4"/>
                                                        <circle cx="8" cy="6" r="2" fill="currentColor"/>
                                                    </svg>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    </div>
                `;
                
                // Set up breadcrumb click handlers
                const breadcrumbClickItems = container.querySelectorAll('[data-breadcrumb-click]');
                breadcrumbClickItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        const clickType = item.getAttribute('data-breadcrumb-click');
                        const catName = item.getAttribute('data-category') || null;
                        const topName = item.getAttribute('data-topic') || null;
                        const dsId = item.getAttribute('data-data-source') || null;
                        const dimName = item.getAttribute('data-dimension') || null;
                        const dimRef = item.getAttribute('data-dimension-ref') || null;
                        
                        console.log('[BreadcrumbNav] Breadcrumb clicked:', { clickType, catName, topName, dsId, dimName, dimRef });
                        
                        if (clickType === 'dimension' && dimRef) {
                            // Dimension click: navigate to visualizations and filter by dimension
                            navigateToView('visualizations');
                            
                            // Set the dimension selector to the clicked dimension
                            const questionSelect = document.getElementById('questionSelect');
                            if (questionSelect) {
                                const previousRefKey = currentQuestionRefKey;
                                questionSelect.value = dimRef;
                                currentQuestionRefKey = dimRef;
                                
                                // Filter by this dimension (this will reload charts/data in the background)
                                filterByQuestion(dimRef, previousRefKey);
                                
                                // Update navigation links
                                updateNavLinks();
                                
                                // Update AI Insights panel with current dimension
                                if (window.AIInsightsPanel) {
                                    window.AIInsightsPanel.setCurrentDimension(dimRef);
                                }
                            }
                        } else if (clickType === 'topic' && topName && catName) {
                            // Topic click: go directly to verbatims
                            this.navigateToVerbatimsFromBreadcrumb(topName, catName, dsId, dimRef);
                        } else if (clickType === 'category') {
                            // Category click: go to chart view
                            // Ensure we're in the correct context before navigating
                            ensureContextForInsightNavigation(dsId, dimRef).then(() => {
                                const dimName = dimRef ? getDimensionDisplayName(dimRef) : null;
                                this.navigateToChart(catName, null, dsId, dimName);
                            });
                        }
                    });
                });
                
                // Set up editable title in header (with auto-save for edit mode)
                const headerTitleEl = document.getElementById('slideoutTitle');
                if (headerTitleEl) {
                    headerTitleEl.addEventListener('blur', () => {
                        // Only auto-save if we're in edit mode, not create mode
                        if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                            const newName = headerTitleEl.textContent.trim() || '';
                            if (newName) {
                                this.debouncedSaveInsightField('name', newName);
                            }
                        }
                    });
                    headerTitleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            headerTitleEl.blur();
                        }
                    });
                }
                
                
                // Set up editable application chip (with auto-save for edit mode)
                
                // Initialize editor with notes
                console.log('[initializeInsightPanel] Initializing editor with notes:', insight.notes);
                console.log('[initializeInsightPanel] Notes length:', insight.notes?.length);
                console.log('[initializeInsightPanel] Notes contains img:', insight.notes?.includes('<img'));
                try {
                    await this.initializeInsightEditor(document.getElementById('insightNotesEditor'), insight.notes || '');
                    console.log('[initializeInsightPanel] Editor initialization completed');
                } catch (error) {
                    console.error('[initializeInsightPanel] Error initializing editor:', error);
                }
                
                // After editor initialization, check what was parsed
                if (this.currentInsightEditor) {
                    setTimeout(() => {
                        const html = this.currentInsightEditor.getHTML();
                        console.log('[initializeInsightPanel] Editor HTML after initialization:', html);
                        console.log('[initializeInsightPanel] Editor HTML contains img:', html.includes('<img'));
                        const editorElement = document.getElementById('insightNotesEditor');
                        if (editorElement) {
                            const images = editorElement.querySelectorAll('img');
                            console.log('[initializeInsightPanel] Found', images.length, 'img elements in DOM');
                            if (images.length === 0) {
                                console.warn('[initializeInsightPanel]  No images found in DOM!');
                                console.warn('[initializeInsightPanel] Editor element:', editorElement);
                                console.warn('[initializeInsightPanel] Editor element innerHTML:', editorElement.innerHTML.substring(0, 1000));
                            }
                            images.forEach((img, idx) => {
                                console.log(`[initializeInsightPanel] Image ${idx}:`, {
                                    src: img.src,
                                    complete: img.complete,
                                    naturalWidth: img.naturalWidth,
                                    naturalHeight: img.naturalHeight,
                                    onerror: img.onerror
                                });
                            });
                        } else {
                            console.error('[initializeInsightPanel] Editor element not found!');
                        }
                    }, 500);
                } else {
                    console.error('[initializeInsightPanel] Editor not created - currentInsightEditor is null!');
                }
            },
            
            async initializeInsightEditor(editorElement, initialContent) {
                console.log('[initializeInsightEditor] Called with initialContent:', initialContent);
                console.log('[initializeInsightEditor] InitialContent contains img:', initialContent?.includes('<img'));
                console.log('[initializeInsightEditor] InitialContent contains iframe:', initialContent?.includes('<iframe'));
                
                // Clean up existing editor if any
                if (this.currentInsightEditor) {
                    this.currentInsightEditor.destroy();
                    this.currentInsightEditor = null;
                }
                
                // Clean up context menu handlers
                this.cleanupEditorContextMenu();
                
                // Clean up image click handlers
                if (this.imageClickHandler && this.currentEditorElement) {
                    this.currentEditorElement.removeEventListener('click', this.imageClickHandler);
                    this.imageClickHandler = null;
                }
                
                if (!editorElement) return;
                
                // Initialize Tiptap editor using ES modules
                try {
                    // Dynamically import Tiptap modules
                    const { Editor, Extension, Node, mergeAttributes } = await import('https://esm.sh/@tiptap/core@2.1.13');
                    const StarterKitModule = await import('https://esm.sh/@tiptap/starter-kit@2.1.13');
                    const StarterKit = StarterKitModule.default || StarterKitModule;
                    const { TaskList } = await import('https://esm.sh/@tiptap/extension-task-list@2.1.13');
                    const { TaskItem } = await import('https://esm.sh/@tiptap/extension-task-item@2.1.13');
                    const { Image } = await import('https://esm.sh/@tiptap/extension-image@2.1.13');
                    
                    // Create a custom iframe extension for Loom embeds
                    const Iframe = Node.create({
                        name: 'iframe',
                        group: 'block',
                        atom: true,
                        addAttributes() {
                            return {
                                src: {
                                    default: null,
                                },
                                width: {
                                    default: '100%',
                                },
                                height: {
                                    default: '500px',
                                },
                                frameborder: {
                                    default: '0',
                                },
                                allowfullscreen: {
                                    default: true,
                                },
                                style: {
                                    default: 'width: 100%; border-radius: 0.5rem; aspect-ratio: 16/9; margin: 1rem 0; border: none;',
                                },
                            };
                        },
                        parseHTML() {
                            return [{
                                tag: 'iframe',
                            }];
                        },
                        renderHTML({ HTMLAttributes }) {
                            return ['iframe', mergeAttributes(HTMLAttributes)];
                        },
                    });
                    
                    // Store reference to this for use in handlers
                    const self = this;
                    
                    // Function to insert image/video immediately and upload in background
                    const insertAndUploadMedia = async (file, isVideo = false) => {
                        const objectURL = URL.createObjectURL(file);
                        const editor = self.currentInsightEditor;
                        
                        // Insert immediately with object URL
                        if (isVideo) {
                            console.log('[insertAndUploadMedia] Inserting video with object URL');
                            editor.chain().focus().insertContent(`<video src="${objectURL}" controls width="100%" style="max-width: 100%; height: auto; border-radius: 0.5rem; margin: 1rem 0;"></video>`).run();
                        } else {
                            console.log('[insertAndUploadMedia] Inserting image with object URL');
                            editor.chain().focus().setImage({ src: objectURL }).run();
                            console.log('[insertAndUploadMedia] Image inserted, current HTML:', editor.getHTML());
                        }
                        
                        // Upload in background and replace URL when done
                        try {
                            const permanentURL = await uploadMediaToBlob(file);
                            
                            // Use Tiptap's transaction API to find and update the image node
                            const { state } = editor.view;
                            const { tr } = state;
                            
                            let foundImage = false;
                            
                            // Find the image node with the object URL and update it
                            tr.doc.descendants((node, pos) => {
                                if (node.type.name === 'image' && node.attrs.src === objectURL) {
                                    tr.setNodeMarkup(pos, undefined, { ...node.attrs, src: permanentURL });
                                    foundImage = true;
                                }
                            });
                            
                            // Handle videos (which are raw HTML)
                            if (isVideo) {
                                const currentHTML = editor.getHTML();
                                const escapedObjectURL = objectURL.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                const updatedHTML = currentHTML.replace(new RegExp(escapedObjectURL, 'g'), permanentURL);
                                editor.commands.setContent(updatedHTML, false);
                            } else {
                                // For images, use the transaction
                                if (foundImage) {
                                    editor.view.dispatch(tr);
                                } else {
                                    // Fallback: try HTML replacement
                                    const currentHTML = editor.getHTML();
                                    const escapedObjectURL = objectURL.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    const updatedHTML = currentHTML.replace(new RegExp(escapedObjectURL, 'g'), permanentURL);
                                    editor.commands.setContent(updatedHTML, false);
                                }
                            }
                            
                            URL.revokeObjectURL(objectURL);
                        } catch (error) {
                            console.error('Error uploading media:', error);
                        }
                    };
                    
                    this.currentInsightEditor = new Editor({
                        element: editorElement,
                        extensions: [
                            StarterKit,
                            TaskList,
                            TaskItem.configure({
                                nested: true,
                            }),
                            Image.configure({
                                inline: true,
                                allowBase64: false,
                                HTMLAttributes: {
                                    class: 'insight-image',
                                },
                            }),
                            Iframe,
                        ],
                        content: initialContent || '', // Set content directly in constructor
                        editorProps: {
                            attributes: {
                                class: 'prose prose-sm max-w-none focus:outline-none',
                                style: 'min-height: 400px;'
                            },
                            handlePaste: (view, event, slice) => {
                                console.log('[Editor Setup] Paste handler called for self.currentInsightEditor');
                                const handler = createMediaPasteHandler(() => {
                                    console.log('[Editor Setup] Getting editor, current value:', self.currentInsightEditor);
                                    return self.currentInsightEditor;
                                }, insertAndUploadMedia);
                                return handler(view, event, slice);
                            },
                            handleDrop: createMediaDropHandler(insertAndUploadMedia)
                        },
                        onUpdate: ({ editor }) => {
                            // Only auto-save if we're in edit mode, not create mode
                            if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                                const html = editor.getHTML();
                                console.log('[onUpdate] Editor updated, mode:', this.currentMode, 'insightId:', this.currentInsightId);
                                console.log('[onUpdate] HTML content:', html);
                                console.log('[onUpdate] HTML contains img tags:', html.includes('<img'));
                                
                                // Check for blob URLs - warn if found
                                if (html.includes('blob:')) {
                                    console.warn('[onUpdate] WARNING: HTML contains blob URLs - these will not persist!', html);
                                }
                                
                                this.debouncedSaveInsightNotes(this.currentInsightId, html);
                            } else {
                                console.log('[onUpdate] Not saving - mode:', this.currentMode, 'insightId:', this.currentInsightId);
                            }
                        },
                        onSelectionUpdate: ({ editor }) => {
                            // Show context menu when text is selected
                            if (this.editorContextMenuHandlers && this.editorContextMenuHandlers.showMenuOnSelection) {
                                this.editorContextMenuHandlers.showMenuOnSelection(editor);
                            }
                        }
                    });
                    
                    // Log immediately after editor creation
                    console.log('[initializeInsightEditor] Editor created successfully');
                    console.log('[initializeInsightEditor] Editor HTML immediately after creation:', this.currentInsightEditor.getHTML());
                    console.log('[initializeInsightEditor] Editor HTML contains img:', this.currentInsightEditor.getHTML().includes('<img'));
                    
                    // Check DOM directly after editor is ready
                    setTimeout(() => {
                        const html = this.currentInsightEditor.getHTML();
                        console.log('[initializeInsightEditor] Editor HTML after delay:', html);
                        console.log('[initializeInsightEditor] Editor HTML contains iframe:', html.includes('<iframe'));
                        const images = editorElement.querySelectorAll('img');
                        const iframes = editorElement.querySelectorAll('iframe');
                        console.log('[initializeInsightEditor] Found', images.length, 'img elements in DOM');
                        console.log('[initializeInsightEditor] Found', iframes.length, 'iframe elements in DOM');
                        if (images.length > 0) {
                            images.forEach((img, idx) => {
                                console.log(`[initializeInsightEditor] Image ${idx}:`, {
                                    src: img.src,
                                    complete: img.complete,
                                    naturalWidth: img.naturalWidth,
                                    naturalHeight: img.naturalHeight,
                                    width: img.width,
                                    height: img.height,
                                    style: img.style.cssText
                                });
                                // Test if image loads
                                img.onload = () => console.log(`[initializeInsightEditor] Image ${idx} loaded successfully`);
                                img.onerror = (e) => console.error(`[initializeInsightEditor] Image ${idx} failed to load:`, e);
                            });
                        } else {
                            console.warn('[initializeInsightEditor]  No images found in DOM!');
                            console.warn('[initializeInsightEditor] Editor HTML:', html);
                            console.warn('[initializeInsightEditor] Editor element innerHTML:', editorElement.innerHTML.substring(0, 500));
                        }
                        if (iframes.length === 0 && initialContent?.includes('<iframe')) {
                            console.warn('[initializeInsightEditor]  Iframe in content but not in DOM!');
                            console.warn('[initializeInsightEditor] Initial content:', initialContent);
                            console.warn('[initializeInsightEditor] Parsed HTML:', html);
                        }
                    }, 300);
                    
                    // Set up context menu for formatting
                    // IMPORTANT: This must be called AFTER editor creation so onSelectionUpdate callback can access the handlers
                    this.setupEditorContextMenu(editorElement);
                    
                    // Set up image click handlers to open modal
                    this.setupImageClickHandlers(editorElement);
                } catch (error) {
                    console.error('[initializeInsightEditor] Error initializing editor:', error);
                    console.error('[initializeInsightEditor] Error stack:', error.stack);
                    if (editorElement && editorElement.parentElement) {
                        editorElement.parentElement.innerHTML = `<div style="padding: 24px; color: #666;">Error initializing editor: ${error.message}</div>`;
                    }
                    throw error; // Re-throw so caller knows it failed
                }
            },
            
            setupEditorContextMenu(editorElement) {
                // Clean up existing context menu setup if any
                if (this.editorContextMenuHandlers) {
                    this.cleanupEditorContextMenu();
                }
                
                // Get or create context menu element
                let contextMenu = document.getElementById('editorContextMenu');
                if (!contextMenu) {
                    contextMenu = document.createElement('div');
                    contextMenu.id = 'editorContextMenu';
                    contextMenu.className = 'editor-context-menu';
                    contextMenu.style.display = 'none';
                    contextMenu.innerHTML = `
                        <div class="context-menu-item" data-action="heading-1">H1</div>
                        <div class="context-menu-item" data-action="heading-2">H2</div>
                        <div class="context-menu-item" data-action="heading-3">H3</div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="bold">Bold</div>
                        <div class="context-menu-item" data-action="bulletList">Bullets</div>
                        <div class="context-menu-item" data-action="taskList">Checklist</div>
                        <div class="context-menu-item" data-action="blockquote">Callout</div>
                    `;
                    document.body.appendChild(contextMenu);
                } else {
                    // Hide menu if it was previously visible
                    contextMenu.style.display = 'none';
                }
                
                // Store current editor element for cleanup
                this.currentEditorElement = editorElement;
                
                // Function to show menu when text is selected
                const showMenuOnSelection = (editor) => {
                    if (!editor) {
                        editor = this.currentInsightEditor;
                    }
                    if (!editor) {
                        return;
                    }
                    
                    const { from, to } = editor.state.selection;
                    const isEmpty = from === to;
                    
                    if (isEmpty) {
                        // Hide menu if no text is selected
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    // Get selection coordinates from the editor view
                    const view = editor.view;
                    if (!view) {
                        return;
                    }
                    
                    const coords = view.coordsAtPos(to);
                    
                    if (coords) {
                        // Position menu near the end of the selection
                        // coordsAtPos returns viewport coordinates, so we need position: fixed
                        contextMenu.style.position = 'fixed';
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = `${coords.right}px`;
                        contextMenu.style.top = `${coords.bottom + 5}px`;
                        
                        // Ensure menu stays within viewport
                        requestAnimationFrame(() => {
                            const menuRect = contextMenu.getBoundingClientRect();
                            
                            if (menuRect.right > window.innerWidth) {
                                contextMenu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
                            }
                            if (menuRect.bottom > window.innerHeight) {
                                contextMenu.style.top = `${coords.top - menuRect.height - 5}px`;
                            }
                            if (menuRect.left < 0) {
                                contextMenu.style.left = '10px';
                            }
                            if (menuRect.top < 0) {
                                contextMenu.style.top = '10px';
                            }
                        });
                        
                        // Update active states
                        this.updateContextMenuStates(contextMenu, editor);
                    }
                };
                
                // Handle menu item clicks
                const menuClickHandler = (e) => {
                    e.stopPropagation(); // Prevent event from bubbling to document
                    e.preventDefault();
                    
                    const action = e.target.getAttribute('data-action');
                    if (!action) {
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    const editor = this.currentInsightEditor;
                    if (!editor) {
                        contextMenu.style.display = 'none';
                        return;
                    }
                    
                    // Hide menu first to prevent conflicts
                    contextMenu.style.display = 'none';
                    
                    // Small delay to ensure menu is hidden before applying command
                    setTimeout(() => {
                        switch (action) {
                            case 'heading-1':
                                editor.chain().focus().toggleHeading({ level: 1 }).run();
                                break;
                            case 'heading-2':
                                editor.chain().focus().toggleHeading({ level: 2 }).run();
                                break;
                            case 'heading-3':
                                editor.chain().focus().toggleHeading({ level: 3 }).run();
                                break;
                            case 'bold':
                                editor.chain().focus().toggleBold().run();
                                break;
                            case 'bulletList':
                                editor.chain().focus().toggleBulletList().run();
                                break;
                            case 'taskList':
                                editor.chain().focus().toggleTaskList().run();
                                break;
                            case 'blockquote':
                                // Toggle blockquote
                                if (editor.isActive('blockquote')) {
                                    // If already in blockquote, lift it
                                    editor.chain().focus().lift('blockquote').run();
                                } else {
                                    // Wrap the current block in blockquote
                                    // This works for both selections and empty cursor positions
                                    editor.chain().focus().wrapIn('blockquote').run();
                                }
                                break;
                        }
                    }, 10);
                };
                
                contextMenu.addEventListener('click', menuClickHandler);
                
                // Hide menu on click outside, scroll, or escape key
                const hideMenu = (e) => {
                    if (contextMenu.style.display !== 'none') {
                        // Don't hide if clicking inside the menu itself or the editor
                        if (!contextMenu.contains(e.target) && (!editorElement || !editorElement.contains(e.target))) {
                            contextMenu.style.display = 'none';
                        }
                    }
                };
                
                const scrollHandler = () => {
                    contextMenu.style.display = 'none';
                };
                
                const keydownHandler = (e) => {
                    if (e.key === 'Escape' && contextMenu.style.display !== 'none') {
                        contextMenu.style.display = 'none';
                    }
                };
                
                // Use capture phase to handle clicks before they bubble
                document.addEventListener('click', hideMenu, true);
                document.addEventListener('scroll', scrollHandler, true);
                document.addEventListener('keydown', keydownHandler);
                
                // Store handlers for cleanup
                this.editorContextMenuHandlers = {
                    showMenuOnSelection, // Function to show menu on text selection
                    menuClickHandler,
                    hideMenu,
                    scrollHandler,
                    keydownHandler,
                    editorElement,
                    contextMenu
                };
            },
            
            setupImageClickHandlers(editorElement) {
                if (!editorElement) return;
                
                // Clean up existing handler if any
                if (this.imageClickHandler && this.currentEditorElement) {
                    this.currentEditorElement.removeEventListener('click', this.imageClickHandler);
                }
                
                // Store editor element reference for cleanup
                this.currentEditorElement = editorElement;
                
                // Use event delegation to handle clicks on images
                // This works for both existing and dynamically added images
                const clickHandler = (e) => {
                    // Check if the clicked element or its parent is an image
                    let img = e.target;
                    if (img.tagName !== 'IMG') {
                        img = img.closest('img');
                    }
                    
                    if (img && (img.classList.contains('insight-image') || editorElement.contains(img))) {
                        e.preventDefault();
                        e.stopPropagation();
                        openImageModal(img.src);
                    }
                };
                
                // Store handler for cleanup
                this.imageClickHandler = clickHandler;
                
                // Add click listener to editor element
                editorElement.addEventListener('click', clickHandler);
            },
            
            cleanupEditorContextMenu() {
                if (!this.editorContextMenuHandlers) return;
                
                const { menuClickHandler, hideMenu, scrollHandler, keydownHandler, editorElement, contextMenu } = this.editorContextMenuHandlers;
                
                // No event listeners to remove for selection-based menu (handled by Tiptap's onSelectionUpdate)
                if (contextMenu && menuClickHandler) {
                    contextMenu.removeEventListener('click', menuClickHandler);
                }
                if (hideMenu) {
                    document.removeEventListener('click', hideMenu, true);
                }
                if (scrollHandler) {
                    document.removeEventListener('scroll', scrollHandler, true);
                }
                if (keydownHandler) {
                    document.removeEventListener('keydown', keydownHandler);
                }
                
                // Hide menu if visible
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
                
                // Clear handlers
                this.editorContextMenuHandlers = null;
                this.currentEditorElement = null;
            },
            
            updateContextMenuStates(menu, editor) {
                const items = menu.querySelectorAll('.context-menu-item');
                items.forEach(item => {
                    const action = item.getAttribute('data-action');
                    let isActive = false;
                    
                    switch (action) {
                        case 'heading-1':
                            isActive = editor.isActive('heading', { level: 1 });
                            break;
                        case 'heading-2':
                            isActive = editor.isActive('heading', { level: 2 });
                            break;
                        case 'heading-3':
                            isActive = editor.isActive('heading', { level: 3 });
                            break;
                        case 'bold':
                            isActive = editor.isActive('bold');
                            break;
                        case 'bulletList':
                            isActive = editor.isActive('bulletList');
                            break;
                        case 'taskList':
                            isActive = editor.isActive('taskList');
                            break;
                        case 'blockquote':
                            isActive = editor.isActive('blockquote');
                            break;
                    }
                    
                    if (isActive) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            },
            
            saveTimeout: null,
            fieldSaveTimeout: null,
            
            debouncedSaveInsightNotes(insightId, content) {
                clearTimeout(this.saveTimeout);
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                if (statusEl) statusEl.textContent = 'Saving...';
                
                this.saveTimeout = setTimeout(async () => {
                    await this.saveInsightNotes(insightId, content);
                }, 500);
            },
            
            debouncedSaveInsightField(fieldName, value) {
                clearTimeout(this.fieldSaveTimeout);
                
                this.fieldSaveTimeout = setTimeout(async () => {
                    await this.saveInsightField(fieldName, value);
                }, 500);
            },
            
            async saveInsightField(fieldName, value) {
                if (!currentClientId || !this.currentInsightId) return;
                
                try {
                    const updateData = {};
                    updateData[fieldName] = value;
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${this.currentInsightId}`, {
                        method: 'PUT',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(updateData)
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save field');
                    }
                    
                    // Update local data
                    if (this.currentInsightData) {
                        this.currentInsightData[fieldName] = value;
                    }
                } catch (error) {
                    console.error('Error saving field:', error);
                }
            },
            
            async saveInsightNotes(insightId, content) {
                console.log('[saveInsightNotes] Called with insightId:', insightId, 'currentClientId:', currentClientId);
                console.log('[saveInsightNotes] Content length:', content?.length);
                console.log('[saveInsightNotes] Content preview:', content?.substring(0, 200));
                console.log('[saveInsightNotes] Content contains img:', content?.includes('<img'));
                console.log('[saveInsightNotes] Full content:', content);
                
                if (!currentClientId || !insightId) {
                    console.warn('[saveInsightNotes] Missing clientId or insightId, aborting');
                    return;
                }
                
                const statusEl = document.getElementById('insightNotesSaveStatus');
                
                try {
                    const payload = { notes: content };
                    console.log('[saveInsightNotes] Sending payload:', JSON.stringify(payload).substring(0, 300));
                    
                    const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${insightId}`, {
                        method: 'PUT',
                        headers: {
                            ...getAuthHeaders(),
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    console.log('[saveInsightNotes] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('[saveInsightNotes] Error response:', errorText);
                        throw new Error('Failed to save notes');
                    }
                    
                    const responseData = await response.json();
                    console.log('[saveInsightNotes] Save successful, response:', responseData);
                    console.log('[saveInsightNotes] Saved notes content (first 500 chars):', responseData.notes?.substring(0, 500));
                    console.log('[saveInsightNotes] Saved notes contains img:', responseData.notes?.includes('<img'));
                    
                    // Check if image URL is complete
                    if (responseData.notes?.includes('<img')) {
                        const imgMatch = responseData.notes.match(/<img[^>]+src="([^"]+)"/);
                        if (imgMatch) {
                            const imgSrc = imgMatch[1];
                            console.log('[saveInsightNotes] Image src found:', imgSrc);
                            console.log('[saveInsightNotes] Image src length:', imgSrc.length);
                            console.log('[saveInsightNotes] Image src ends with .png:', imgSrc.endsWith('.png'));
                            if (!imgSrc.endsWith('.png') && !imgSrc.endsWith('.jpg') && !imgSrc.endsWith('.gif')) {
                                console.warn('[saveInsightNotes]  Image URL appears truncated!');
                            }
                        }
                    }
                    
                    if (statusEl) {
                        statusEl.textContent = 'Saved';
                        statusEl.style.color = '#B9F040'; /* Brand lime green */
                        setTimeout(() => {
                            if (statusEl) {
                                statusEl.textContent = '';
                            }
                        }, 2000);
                    }
                } catch (error) {
                    console.error('[saveInsightNotes] Error saving notes:', error);
                    if (statusEl) {
                        statusEl.textContent = 'Error saving';
                        statusEl.style.color = 'oklch(0.577 0.245 27.325)'; /* Destructive red from style guide */
                    }
                }
            },
            
            close() {
                const panel = document.getElementById('slideoutPanel');
                const overlay = document.getElementById('slideoutOverlay');
                const subtitle = document.getElementById('slideoutSubtitle');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                const title = document.getElementById('slideoutTitle');
                
                // Clean up editor
                if (this.currentInsightEditor) {
                    this.currentInsightEditor.destroy();
                    this.currentInsightEditor = null;
                }
                
                // Clean up context menu handlers
                this.cleanupEditorContextMenu();
                
                // Reset title to default (remove contenteditable for non-insight modes)
                if (title) {
                    title.removeAttribute('contenteditable');
                    title.setAttribute('data-placeholder', '');
                    title.textContent = 'AI-Generated Insights';
                }
                
                if (panel) panel.classList.remove('open');
                if (overlay) overlay.classList.remove('visible');
                if (subtitle) subtitle.style.display = 'none';
                
                // Re-enable body scroll
                document.body.classList.remove('slideout-open');
                
                // Update search bar z-index when slideout closes
                if (typeof updateTreemapSearchZIndex === 'function') {
                    updateTreemapSearchZIndex();
                }
                
                this.isOpen = false;
                this.currentMode = null;
                this.currentInsightId = null;
                this.currentInsightData = null;
                this.createInsightContext = null;
                this.createInsightOrigin = null;
                this.navigationStack = [];  // Reset navigation stack
                
                // Hide back button
                const backButton = document.getElementById('slideoutBackButton');
                if (backButton) backButton.style.display = 'none';
                
                // Clear save timeouts
                if (this.saveTimeout) {
                    clearTimeout(this.saveTimeout);
                    this.saveTimeout = null;
                }
                if (this.fieldSaveTimeout) {
                    clearTimeout(this.fieldSaveTimeout);
                    this.fieldSaveTimeout = null;
                }
            },
            
            // Fetch data source name from API
            async fetchDataSourceName(dataSourceId) {
                console.log('[BreadcrumbNav] fetchDataSourceName called with:', dataSourceId);
                if (!dataSourceId) {
                    console.log('[BreadcrumbNav] No data source ID provided');
                    return null;
                }
                
                // Check cache first
                if (this.dataSourceNameCache[dataSourceId]) {
                    console.log('[BreadcrumbNav] Using cached data source name:', this.dataSourceNameCache[dataSourceId]);
                    return this.dataSourceNameCache[dataSourceId];
                }
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/data-sources/${dataSourceId}`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        console.warn('[BreadcrumbNav] Failed to fetch data source:', response.status);
                        return null;
                    }
                    
                    const dataSource = await response.json();
                    const name = dataSource.name || dataSource.source_name || null;
                    
                    if (name) {
                        this.dataSourceNameCache[dataSourceId] = name;
                        console.log('[BreadcrumbNav] Cached data source name:', name);
                    }
                    
                    return name;
                } catch (error) {
                    console.error('[BreadcrumbNav] Error fetching data source name:', error);
                    return null;
                }
            },
            
            // Update back button visibility
            updateBackButton() {
                const backButton = document.getElementById('slideoutBackButton');
                if (backButton) {
                    if (this.navigationStack.length > 0) {
                        backButton.style.display = 'flex';
                        console.log('[BreadcrumbNav] Back button shown, stack length:', this.navigationStack.length);
                    } else {
                        backButton.style.display = 'none';
                        console.log('[BreadcrumbNav] Back button hidden');
                    }
                }
            },
            
            // Navigate back through navigation stack
            async navigateBack() {
                console.log('[BreadcrumbNav] navigateBack called, stack:', this.navigationStack);
                
                if (this.navigationStack.length === 0) {
                    console.warn('[BreadcrumbNav] Navigation stack is empty, cannot navigate back');
                    return;
                }
                
                const previousState = this.navigationStack.pop();
                console.log('[BreadcrumbNav] Popped state:', previousState);
                
                // Get all UI elements
                const content = document.getElementById('slideoutContent');
                const title = document.getElementById('slideoutTitle');
                const subtitle = document.getElementById('slideoutSubtitle');
                const searchBox = document.getElementById('slideoutSearch');
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                const backButton = document.getElementById('slideoutBackButton');
                
                // Start transition: fade out ALL UI elements simultaneously
                if (content) content.classList.add('transitioning');
                if (title) title.classList.add('transitioning');
                if (subtitle) subtitle.classList.add('transitioning');
                if (searchBox) searchBox.classList.add('transitioning');
                if (settingsBtn) settingsBtn.classList.add('transitioning');
                
                // Wait for fade out
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Update ALL UI elements simultaneously before restoring content
                // This ensures everything changes at once, not sequentially
                this.updateBackButton();
                
                // Restore previous view based on level (this will update content)
                if (previousState.level === 'insight') {
                    // Restore insight view - load data first, then update all UI at once
                    if (previousState.data.insightId) {
                        // Load insight data
                        const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights/${previousState.data.insightId}`, {
                            headers: getAuthHeaders()
                        });
                        
                        if (response.ok) {
                            const insight = await response.json();
                            this.currentInsightData = insight;
                            this.currentMode = 'insight-notes';
                            this.currentInsightId = previousState.data.insightId;
                            
                            // Update ALL UI elements at once (before content update)
                            if (title) {
                                title.textContent = toPascalCase(insight.name || '');
                                title.setAttribute('contenteditable', 'true');
                                title.setAttribute('data-placeholder', 'Insight Title');
                            }
                            if (subtitle) subtitle.style.display = 'none';
                            if (searchBox) searchBox.style.display = 'none';
                            const searchContainer = document.getElementById('slideoutSearchContainer');
                            if (searchContainer) searchContainer.style.display = 'none';
                            if (settingsBtn) settingsBtn.style.display = 'none';
                            
                            // Update content (this happens after all UI elements are set)
                            await this.initializeInsightPanel(content, insight);
                        }
                    }
                } else if (previousState.level === 'chart') {
                    // Restore chart view
                    this.currentMode = 'chart';
                    
                    // Update ALL UI elements at once (before content update)
                    if (title) {
                        if (previousState.data.topicName && previousState.data.categoryName) {
                            title.textContent = `${previousState.data.categoryName} / ${previousState.data.topicName}`;
                        } else if (previousState.data.categoryName) {
                            title.textContent = previousState.data.categoryName;
                        } else {
                            title.textContent = 'Topics by Category';
                        }
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    if (subtitle) subtitle.style.display = 'none';
                    if (searchBox) searchBox.style.display = 'none';
                    const searchContainer = document.getElementById('slideoutSearchContainer');
                    if (searchContainer) searchContainer.style.display = 'none';
                    if (settingsBtn) settingsBtn.style.display = 'none';
                    
                    // Update content (this happens after all UI elements are set)
                    await this.renderChartView(
                        previousState.data.categoryName,
                        previousState.data.topicName,
                        previousState.data.dataSourceId,
                        previousState.data.dimensionName,
                        true // Skip UI updates, already done above
                    );
                }
                
                // End transition: fade in all elements (re-get elements in case DOM was updated)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                // Force reflow and remove transitioning class from all elements
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
            },
            
            // Navigate to chart view from breadcrumb
            async navigateToChart(categoryName, topicName, dataSourceId, dimensionName) {
                console.log('[BreadcrumbNav] navigateToChart called:', { categoryName, topicName, dataSourceId, dimensionName });
                
                // Save current state to navigation stack
                if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                    this.navigationStack.push({
                        level: 'insight',
                        data: { insightId: this.currentInsightId },
                        view: 'insight'
                    });
                    console.log('[BreadcrumbNav] Pushed insight state to stack');
                }
                
                // Navigate to chart view
                await this.renderChartView(categoryName, topicName, dataSourceId, dimensionName);
            },
            
            // Render chart view in slideout
            async renderChartView(categoryName, topicName, dataSourceId, dimensionName, skipUIUpdates = false) {
                console.log('[BreadcrumbNav] renderChartView called:', { categoryName, topicName, dataSourceId, dimensionName, skipUIUpdates });
                
                this.currentMode = 'chart';
                // Track current chart state
                this.currentChartCategoryName = categoryName;
                this.currentChartTopicName = topicName;
                this.currentChartDataSourceId = dataSourceId;
                this.currentChartDimensionName = dimensionName;
                
                // Update UI (unless already updated by caller)
                if (!skipUIUpdates) {
                    const panel = document.getElementById('slideoutPanel');
                    const overlay = document.getElementById('slideoutOverlay');
                    const title = document.getElementById('slideoutTitle');
                    const searchBox = document.getElementById('slideoutSearch');
                    const settingsBtn = document.getElementById('slideoutSettingsBtn');
                    const subtitle = document.getElementById('slideoutSubtitle');
                    
                    // Hide search and settings
                    if (searchBox) searchBox.style.display = 'none';
                    if (settingsBtn) settingsBtn.style.display = 'none';
                    if (subtitle) subtitle.style.display = 'none';
                    
                    // Set title
                    if (title) {
                        if (topicName && categoryName) {
                            title.textContent = `${categoryName} / ${topicName}`;
                        } else if (categoryName) {
                            title.textContent = categoryName;
                        } else {
                            title.textContent = 'Topics by Category';
                        }
                        title.removeAttribute('contenteditable');
                        title.setAttribute('data-placeholder', '');
                    }
                    
                    // Update back button
                    this.updateBackButton();
                    
                    // Open panel if not already open
                    if (panel && !panel.classList.contains('open')) {
                        panel.classList.add('open');
                    }
                    if (overlay && !overlay.classList.contains('visible')) {
                        overlay.classList.add('visible');
                    }
                    this.isOpen = true;
                    document.body.classList.add('slideout-open');
                    
                    // Update search bar z-index when slideout opens
                    if (typeof updateTreemapSearchZIndex === 'function') {
                        updateTreemapSearchZIndex();
                    }
                }
                
                const content = document.getElementById('slideoutContent');
                
                // Process chart data using existing function
                const { categories: allCategories, totalTopicInstances } = processBarChartData();
                const colorPalette = generateCategoryColorPalette();
                
                // Filter to only show the specified category if categoryName is provided
                const categories = categoryName 
                    ? allCategories.filter(c => c.name === categoryName)
                    : allCategories;
                
                // Calculate total for filtered categories
                const filteredTotal = categories.reduce((sum, cat) => sum + cat.count, 0);
                
                // Get max percent for scaling (use filtered categories)
                const maxPercent = categories.length > 0 
                    ? Math.max(...categories.map(c => c.percent))
                    : 0;
                
                // Render chart in content
                if (!content) {
                    console.error('[BreadcrumbNav] Content container not found');
                    return;
                }
                
                // Build chart HTML
                let chartHTML = `
                    <div style="padding: 1rem 1.5rem; display: flex; flex-direction: column; height: 100%; overflow-y: auto;">
                        <div style="margin-bottom: 1rem; font-size: 0.875rem; color: oklch(0.556 0 0);">
                            Frequency (n=${filteredTotal})
                        </div>
                        <div id="chartViewContainer" style="display: flex; flex-direction: column; gap: 1rem;">
                `;
                
                // Render each category (now filtered to only show the selected one if categoryName provided)
                categories.forEach((category, catIndex) => {
                    const categoryId = `chart-cat-${catIndex}`;
                    const baseColor = colorPalette[category.name] || categoryColors[catIndex % categoryColors.length];
                    
                    // Category header
                    chartHTML += `
                        <div class="chart-category-group" style="border: 1px solid oklch(0.922 0 0); border-radius: 4px; padding: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <div style="flex: 1; font-weight: 600; font-size: 0.875rem; color: oklch(0.145 0 0);">${escapeHtml(category.name)}</div>
                                <div style="font-size: 0.875rem; color: oklch(0.556 0 0);">${category.percent.toFixed(1)}%</div>
                            </div>
                            
                            <!-- Category bar -->
                            <div style="margin-bottom: 0.5rem; cursor: pointer;"
                                 onclick="SlideoutPanel.navigateToVerbatimsFromChart(null, '${escapeHtml(category.name)}')">
                                <div style="position: relative; height: 24px; background: oklch(0.97 0 0); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${(category.percent / maxPercent) * 100}%; background: ${baseColor}; transition: width 0.3s ease;"></div>
                                    <div style="position: absolute; top: 50%; left: 8px; transform: translateY(-50%); font-size: 0.75rem; color: ${category.percent / maxPercent > 0.15 ? '#fff' : 'oklch(0.145 0 0)'}; font-weight: 500;">
                                        ${category.percent.toFixed(1)}%
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Topics panel -->
                            <div id="${categoryId}" style="display: block; margin-top: 0.5rem; padding-left: 0;">
                                ${category.topics.map((topic, topicIndex) => {
                                    const isTopicHighlighted = topicName && topic.name === topicName;
                                    const topicColor = adjustColorLightness(baseColor, (topicIndex % 3 - 1) * 15);
                                    return `
                                        <div class="chart-topic-row" 
                                             style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; border-radius: 4px; ${isTopicHighlighted ? 'background: oklch(0.97 0.05 120); border-left: 3px solid #B9F040; padding-left: 8px;' : ''}"
                                             onclick="SlideoutPanel.navigateToVerbatimsFromChart('${escapeHtml(topic.name)}', '${escapeHtml(category.name)}')">
                                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${topicColor}; opacity: 0.6;"></div>
                                            <div style="flex: 1; font-size: 0.875rem; color: oklch(0.145 0 0);">${escapeHtml(topic.name)}</div>
                                            <div style="font-size: 0.75rem; color: oklch(0.556 0 0);">${topic.percent.toFixed(1)}%</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                });
                
                chartHTML += `
                        </div>
                    </div>
                `;
                
                content.innerHTML = chartHTML;
                
                // Remove transitioning class from all elements (for smooth fade-in)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
                
                console.log('[BreadcrumbNav] Chart view rendered');
            },
            
            // Toggle category expansion in chart view
            
            // Navigate to verbatims from breadcrumb (direct navigation, skipping chart)
            async navigateToVerbatimsFromBreadcrumb(topicName, categoryName, dataSource, dimensionRef) {
                console.log('[BreadcrumbNav] navigateToVerbatimsFromBreadcrumb called:', { topicName, categoryName, dataSource, dimensionRef });
                
                // Ensure we're in the correct context (data source and dimension)
                if (dataSource || dimensionRef) {
                    await ensureContextForInsightNavigation(dataSource, dimensionRef);
                }
                
                // Save current insight state to navigation stack
                if (this.currentMode === 'insight-notes' && this.currentInsightId) {
                    this.navigationStack.push({
                        level: 'insight',
                        data: { insightId: this.currentInsightId },
                        view: 'insight'
                    });
                    console.log('[BreadcrumbNav] Pushed insight state to stack from breadcrumb');
                }
                
                // Get verbatims from chart data (now that we're in the correct context)
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    // Get verbatims for specific topic
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                }
                
                console.log('[BreadcrumbNav] Found verbatims from breadcrumb:', verbatims.length);
                
                // Navigate to verbatims view
                this.openVerbatims(verbatims, topicName, categoryName);
            },
            
            // Navigate to verbatims from chart view
            navigateToVerbatimsFromChart(topicName, categoryName) {
                console.log('[BreadcrumbNav] navigateToVerbatimsFromChart called:', { topicName, categoryName });
                
                // Save current chart state to navigation stack (use current chart state, not navigation target)
                this.navigationStack.push({
                    level: 'chart',
                    data: { 
                        categoryName: this.currentChartCategoryName || null,
                        topicName: this.currentChartTopicName || null,
                        dataSourceId: this.currentChartDataSourceId || null,
                        dimensionName: this.currentChartDimensionName || null
                    },
                    view: 'chart'
                });
                console.log('[BreadcrumbNav] Pushed current chart state to stack:', {
                    categoryName: this.currentChartCategoryName,
                    topicName: this.currentChartTopicName,
                    dataSourceId: this.currentChartDataSourceId,
                    dimensionName: this.currentChartDimensionName
                });
                
                // Get verbatims from chart data
                const { categories } = processBarChartData();
                let verbatims = [];
                
                if (topicName && categoryName) {
                    // Get verbatims for specific topic
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        const topic = category.topics.find(t => t.name === topicName);
                        if (topic) {
                            verbatims = topic.verbatims || [];
                        }
                    }
                } else if (categoryName) {
                    // Get all verbatims for category
                    const category = categories.find(c => c.name === categoryName);
                    if (category) {
                        category.topics.forEach(topic => {
                            if (topic.verbatims) {
                                verbatims.push(...topic.verbatims);
                            }
                        });
                    }
                }
                
                console.log('[BreadcrumbNav] Found verbatims:', verbatims.length);
                
                // Navigate to verbatims view - pass skipStackPush=true since we already pushed chart state
                this.openVerbatims(verbatims, topicName || categoryName, categoryName, false, true);
            },
            
            // Extract all available metadata fields from verbatims
            extractAvailableMetadataFields(verbatims) {
                const fields = new Set();
                
                verbatims.forEach(v => {
                    if (!v) return;
                    
                    // Add special composite fields
                    if (v.sentiment) fields.add('sentiment');
                    if (v.city || v.country) fields.add('location');
                    if (v.index !== undefined || v.row_id !== undefined) fields.add('index');
                    
                    // Add all other fields from the verbatim object
                    Object.keys(v).forEach(key => {
                        // Skip internal/metadata fields that are handled as special cases
                        if (key !== 'text' && 
                            key !== 'sentiment' && 
                            key !== 'city' &&  // Handled as part of 'location'
                            key !== 'country' &&  // Handled as part of 'location'
                            key !== 'index' && 
                            key !== 'row_id' &&
                            key !== 'category' &&
                            key !== 'topic') {
                            const value = v[key];
                            // Only add fields that have non-empty values
                            if (value !== null && value !== undefined && value !== '') {
                                fields.add(key);
                            }
                        }
                    });
                });
                
                return Array.from(fields).sort();
            },
            
            // Generate metadata settings panel with dynamic checkboxes
            generateMetadataSettingsPanel(availableFields, preserveState = false) {
                const panel = document.getElementById('slideoutSettingsPanel');
                if (!panel) return;
                
                // Preserve existing checkbox states if requested
                const savedStates = {};
                if (preserveState) {
                    availableFields.forEach(field => {
                        const checkbox = document.getElementById(`showMetadata_${field}`);
                        if (checkbox) {
                            savedStates[field] = checkbox.checked;
                        }
                    });
                }
                
                // Clear existing content
                panel.innerHTML = '';
                
                // Add header
                const header = document.createElement('h3');
                header.style.cssText = 'font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #333;';
                header.textContent = 'Display Metadata';
                panel.appendChild(header);
                
                // Helper to create a checkbox option
                const createCheckboxOption = (fieldName, label, defaultValue = false) => {
                    const option = document.createElement('div');
                    option.className = 'settings-option';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `showMetadata_${fieldName}`;
                    // Use saved state if available, otherwise use default
                    checkbox.checked = preserveState && savedStates.hasOwnProperty(fieldName) 
                        ? savedStates[fieldName] 
                        : defaultValue;
                    checkbox.onchange = () => updateSlideoutSettings();
                    
                    const labelEl = document.createElement('label');
                    labelEl.htmlFor = `showMetadata_${fieldName}`;
                    labelEl.textContent = label;
                    
                    option.appendChild(checkbox);
                    option.appendChild(labelEl);
                    return option;
                };
                
                // Add standard fields first (if available)
                if (availableFields.includes('sentiment')) {
                    panel.appendChild(createCheckboxOption('sentiment', 'Sentiment', false));
                }
                if (availableFields.includes('location')) {
                    panel.appendChild(createCheckboxOption('location', 'Location', false));
                }
                if (availableFields.includes('index')) {
                    panel.appendChild(createCheckboxOption('index', 'Index', false));
                }
                
                // Add other metadata fields
                availableFields.forEach(field => {
                    if (field !== 'sentiment' && field !== 'location' && field !== 'index') {
                        // Format field name for display (convert snake_case to Title Case)
                        const displayName = field
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        panel.appendChild(createCheckboxOption(field, displayName, false));
                    }
                });
            },
            
            renderVerbatims(verbatims, topicName, categoryName) {
                console.log('SlideoutPanel.renderVerbatims called with:', { 
                    verbatimsCount: verbatims?.length, 
                    topicName, 
                    categoryName 
                });
                
                const content = document.getElementById('slideoutContent');
                if (!content) {
                    console.error('slideoutContent element not found!');
                    return;
                }
                
                // Setup search input (preserve existing value if re-rendering)
                const searchInput = document.getElementById('slideoutSearch');
                const clearBtn = document.getElementById('slideoutSearchClear');
                if (searchInput) {
                    // Only clear if this is a fresh render (verbatimSearchTerm is empty)
                    if (!this.verbatimSearchTerm) {
                        searchInput.value = '';
                    } else {
                        // Preserve the search term
                        searchInput.value = this.verbatimSearchTerm;
                    }
                    searchInput.style.display = 'block';
                    searchInput.placeholder = 'Search verbatims...';
                    
                    // Show/hide clear button based on search term
                    if (clearBtn) {
                        clearBtn.style.display = this.verbatimSearchTerm && this.verbatimSearchTerm.trim() ? 'flex' : 'none';
                    }
                }
                
                // Show settings button
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                if (settingsBtn) settingsBtn.style.display = 'flex';
                
                // Extract available metadata fields and generate settings panel
                this.availableMetadataFields = this.extractAvailableMetadataFields(verbatims);
                // Preserve checkbox states if they already exist (when re-rendering)
                const hasExistingCheckboxes = document.getElementById('slideoutSettingsPanel')?.querySelector('input[type="checkbox"]') !== null;
                this.generateMetadataSettingsPanel(this.availableMetadataFields, hasExistingCheckboxes);
                
                // Filter verbatims by search term
                let displayVerbatims = verbatims;
                const searchTerm = (this.verbatimSearchTerm || '').trim();
                if (searchTerm) {
                    const searchLower = searchTerm.toLowerCase();
                    displayVerbatims = verbatims.filter(v => 
                        (v.text || '').toLowerCase().includes(searchLower)
                    );
                }
                
                console.log('Rendering', displayVerbatims.length, 'verbatim cards');
                
                // Render verbatim cards
                content.innerHTML = '';
                
                if (displayVerbatims.length === 0) {
                    content.innerHTML = '<div class="ai-error" style="background: #f8f9fa; border: none; margin: 20px 0;"><p>No verbatims match your search.</p></div>';
                    return;
                }
                
                displayVerbatims.forEach((v, index) => {
                    const card = document.createElement('div');
                    card.className = 'verbatim-card';
                    
                    // Highlight search terms if there's a search
                    const highlightedText = searchTerm ? highlightSearchTerms(v.text || 'No text available', searchTerm) : escapeHtml(v.text || 'No text available');
                    
                    // Build metadata HTML based on settings
                    const metaItems = [];
                    
                    // Helper function to check if a metadata field should be shown
                    const shouldShowField = (fieldName) => {
                        const checkbox = document.getElementById(`showMetadata_${fieldName}`);
                        return checkbox?.checked !== false; // Default to true if checkbox doesn't exist
                    };
                    
                    // Check and render sentiment
                    if (shouldShowField('sentiment') && v.sentiment) {
                        const sentimentClass = `sentiment-${v.sentiment}`;
                        const sentimentLabel = v.sentiment.charAt(0).toUpperCase() + v.sentiment.slice(1);
                        metaItems.push(`<span class="verbatim-metadata-item ${sentimentClass}">${sentimentLabel}</span>`);
                    }
                    
                    // Check and render location (combines city and country)
                    if (shouldShowField('location')) {
                        let locationValue = '';
                        if (v.city && v.country) {
                            locationValue = `${escapeHtml(v.city)}, ${escapeHtml(v.country)}`;
                        } else if (v.country) {
                            locationValue = escapeHtml(v.country);
                        } else if (v.city) {
                            locationValue = escapeHtml(v.city);
                        }
                        if (locationValue) {
                            metaItems.push(`<span class="verbatim-metadata-item">${locationValue}</span>`);
                        }
                    }
                    
                    // Check and render index
                    if (shouldShowField('index')) {
                        const indexValue = v.index !== undefined ? v.index : (v.row_id !== undefined ? v.row_id : index + 1);
                        metaItems.push(`<span class="verbatim-metadata-item">#${indexValue}</span>`);
                    }
                    
                    // Render all other metadata fields dynamically
                    (this.availableMetadataFields || []).forEach(field => {
                        if (field === 'sentiment' || field === 'location' || field === 'index') {
                            return; // Already handled above
                        }
                        
                        if (!shouldShowField(field)) {
                            return; // Skip if checkbox is unchecked
                        }
                        
                        const value = v[field];
                        if (value !== null && value !== undefined && value !== '') {
                            // Format value based on type
                            let displayValue = value;
                            if (typeof value === 'object') {
                                displayValue = JSON.stringify(value);
                            } else if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) {
                                // Looks like a date, try to format it nicely
                                try {
                                    const date = new Date(value);
                                    if (!isNaN(date.getTime())) {
                                        displayValue = date.toLocaleDateString();
                                    }
                                } catch (e) {
                                    // Keep original value if parsing fails
                                }
                            }
                            
                            metaItems.push(`<span class="verbatim-metadata-item">${escapeHtml(String(displayValue))}</span>`);
                        }
                    });
                    
                    const metaHTML = metaItems.length > 0 
                        ? `<div class="verbatim-metadata">${metaItems.join('')}</div>` 
                        : '';
                    
                    // Store verbatim data in a data attribute for the onclick handler
                    // Include all fields from v, plus category and topic if not already present
                    const verbatimObj = {
                        ...v,
                        category: v.category || categoryName,
                        topic: v.topic || topicName
                    };
                    // Use base64 encoding with Unicode-safe encoding (matches handleFavouriteClick format)
                    const verbatimJson = JSON.stringify(verbatimObj);
                    const verbatimData = btoa(unescape(encodeURIComponent(verbatimJson)));
                    card.innerHTML = `
                        <div class="verbatim-card-header">
                            <div class="verbatim-text" style="flex: 1; margin-bottom: 0; padding-right: 8px;">${highlightedText}</div>
                            <button class="create-insight-button" data-verbatim="${verbatimData}" onclick="createInsightFromVerbatim(this)" title="Create insight from this verbatim" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; color: oklch(0.556 0 0); transition: all 0.2s ease;" onmouseover="this.style.color='#B9F040'" onmouseout="this.style.color='oklch(0.556 0 0)'">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 5v14M5 12h14"/>
                                </svg>
                            </button>
                        </div>
                        ${metaHTML}
                    `;
                    
                    content.appendChild(card);
                });
                
                console.log('Finished rendering', displayVerbatims.length, 'cards to slideoutContent');
                
                // Remove transitioning class from all elements (for smooth fade-in)
                const updatedContent = document.getElementById('slideoutContent');
                const updatedTitle = document.getElementById('slideoutTitle');
                const updatedSubtitle = document.getElementById('slideoutSubtitle');
                const updatedSearchBox = document.getElementById('slideoutSearch');
                const updatedSettingsBtn = document.getElementById('slideoutSettingsBtn');
                
                if (updatedContent) {
                    void updatedContent.offsetHeight;
                    updatedContent.classList.remove('transitioning');
                }
                if (updatedTitle) {
                    void updatedTitle.offsetHeight;
                    updatedTitle.classList.remove('transitioning');
                }
                if (updatedSubtitle) {
                    void updatedSubtitle.offsetHeight;
                    updatedSubtitle.classList.remove('transitioning');
                }
                if (updatedSearchBox) {
                    void updatedSearchBox.offsetHeight;
                    updatedSearchBox.classList.remove('transitioning');
                }
                if (updatedSettingsBtn) {
                    void updatedSettingsBtn.offsetHeight;
                    updatedSettingsBtn.classList.remove('transitioning');
                }
            },
            
            async loadSummary(forceRegenerate = false) {
                const content = document.getElementById('slideoutContent');
                if (!content) return;
                
                // Hide search and settings for AI insights
                const searchInput = document.getElementById('slideoutSearch');
                if (searchInput) searchInput.style.display = 'none';
                
                const settingsBtn = document.getElementById('slideoutSettingsBtn');
                if (settingsBtn) settingsBtn.style.display = 'none';
                
                // Show loading
                content.innerHTML = `
                    <div class="ai-loading">
                        <div class="ai-loading-spinner"></div>
                        <p>${forceRegenerate ? 'Regenerating insights...' : 'Loading AI insights...'}</p>
                        <small>This may take a few seconds</small>
                    </div>
                `;
                
                try {
                    const { client_uuid, data_source, dimension_ref } = this.currentContext;
                    const url = `${API_BASE_URL}/api/dimensions/${client_uuid}/${data_source}/${dimension_ref}/summary${forceRegenerate ? '?force_regenerate=true' : ''}`;
                    
                    console.log('Fetching AI summary from:', url);
                    
                    const response = await fetch(url, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
                        throw new Error(error.detail || 'Failed to load summary');
                    }
                    
                    const data = await response.json();
                    console.log('AI summary loaded:', data);
                    this.renderSummary(data);
                    
                } catch (error) {
                    console.error('Error loading AI summary:', error);
                    content.innerHTML = `
                        <div class="ai-error">
                            <h3> Error Loading Insights</h3>
                            <p>${error.message}</p>
                            <button onclick="SlideoutPanel.loadSummary()">Try Again</button>
                        </div>
                    `;
                }
            },
            
            // Simple markdown to HTML converter
            convertMarkdown(text) {
                if (!text) return '';
                return text
                    // Fix malformed bold: **TEXT\n\n** -> **TEXT:**
                    .replace(/\*\*([A-Z\s]+)\n\n\*\*/g, '**$1:**')
                    // Fix incomplete bold at line end: **TEXT\n -> **TEXT:**\n
                    .replace(/\*\*([A-Z\s]+)$/gm, '**$1:**')
                    // Remove orphaned ** at start of line (after whitespace/newlines)
                    .replace(/^[\s\n]*\*\*\s+/gm, '')
                    // Remove orphaned ** in the middle of sentences
                    .replace(/\s+\*\*\s+/g, ' ')
                    // Bold: **text** -> <strong>text</strong>
                    .replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>')
                    // Italic: *text* -> <em>text</em>
                    .replace(/\*([^*\n]+)\*/g, '<em>$1</em>')
                    // Line breaks (but keep double breaks as paragraphs)
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');
            },
            
            renderSummary(data) {
                const { summary, status, generated_at, duration_ms, from_cache } = data;
                const content = document.getElementById('slideoutContent');
                if (!content) return;
                
                const statusBadge = from_cache
                    ? '<span class="ai-status-badge ai-status-cached"> From cache</span>'
                    : '<span class="ai-status-badge ai-status-generated"> Freshly generated</span>';
                
                // Parse summary paragraphs with markdown support
                const paragraphs = summary.summary_text.split('\n\n')
                    .map(para => `<p class="ai-summary-text">${this.convertMarkdown(para)}</p>`)
                    .join('');
                
                // Format key insights with markdown support
                const insightsList = (summary.key_insights || [])
                    .map(insight => `<li>${this.convertMarkdown(insight)}</li>`)
                    .join('');
                
                // Format category snapshot with markdown support
                const categoryItems = summary.category_snapshot 
                    ? Object.entries(summary.category_snapshot).map(([cat, desc]) => `
                        <div class="ai-category-item">
                            <div class="ai-category-name">${this.convertMarkdown(cat)}</div>
                            <div>${this.convertMarkdown(desc)}</div>
                        </div>
                    `).join('')
                    : '<p>No category breakdown available</p>';
                
                content.innerHTML = `
                    <div class="ai-summary-section">
                        <h3> Summary</h3>
                        ${paragraphs}
                    </div>
                    
                    ${insightsList ? `
                        <div class="ai-summary-section">
                            <h3> Key Insights</h3>
                            <ul class="ai-insights-list">
                                ${insightsList}
                            </ul>
                        </div>
                    ` : ''}
                    
                    ${categoryItems ? `
                        <div class="ai-summary-section">
                            <h3> Category Breakdown</h3>
                            ${categoryItems}
                        </div>
                    ` : ''}
                    
                    ${summary.patterns ? `
                        <div class="ai-summary-section">
                            <h3> Patterns</h3>
                            <div class="ai-patterns-box">${this.convertMarkdown(summary.patterns)}</div>
                        </div>
                    ` : ''}
                    
                    <div class="ai-metadata">
                        <div>
                            ${statusBadge}
                            Generated ${new Date(generated_at).toLocaleDateString()}
                            ${summary.tokens_used ? `  ${summary.tokens_used} tokens` : ''}
                            ${duration_ms ? `  ${(duration_ms / 1000).toFixed(1)}s` : ''}
                        </div>
                        <div>
                            ${summary.sample_size} / ${summary.total_responses} responses analyzed
                        </div>
                    </div>
                    
                    <button class="ai-regenerate-btn" onclick="SlideoutPanel.loadSummary(true)">
                         Regenerate Insights
                    </button>
                `;
            },
            
            getCurrentDataSource() {
                // Try to find current data source from the UI state
                // This is a simple implementation - adjust based on your app's state management
                const sourceSelect = document.getElementById('sourceSelect');
                if (sourceSelect && sourceSelect.value) {
                    return sourceSelect.value;
                }
                return 'all';  // Default fallback
            }
        };
        
        // Initialize Slideout Panel when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => SlideoutPanel.init());
        } else {
            SlideoutPanel.init();
        }
        
        // Make it globally accessible
        window.SlideoutPanel = SlideoutPanel;
        // Keep backward compatibility
        window.AIInsightsPanel = SlideoutPanel;

        // Insights Panel Management
        let insightsAutoFilter = true;
        let insightsCurrentFilters = {};
        let allInsights = [];
        // insightsSearchTerm, insightsFilters, and insightsSortOrder are already declared above (lines 9225, 9222, 9224)
        let insightsSortBy = 'name';

        function toggleInsightsPanel() {
            const body = document.getElementById('insightsPanelBody');
            const container = document.querySelector('.insights-panel-container');
            if (body.classList.contains('collapsed')) {
                body.classList.remove('collapsed');
                if (container) container.classList.remove('collapsed');
            } else {
                body.classList.add('collapsed');
                if (container) container.classList.add('collapsed');
            }
        }

        function updateInsightsAutoFilter() {
            if (!currentClientId) return;
            
            // Always show all insights (no filtering)
            const badge = document.getElementById('insightsFilterBadge');
            if (badge) {
                badge.style.display = 'none';
            }
            
            insightsCurrentFilters = {};
            loadInsights({});
        }

        async function loadInsights(filters = {}) {
            if (!currentClientId) return;
            
            const tbody = document.getElementById('insightsTableBody');
            if (!tbody) return;
            
            try {
                const params = new URLSearchParams({
                    page: '1',
                    page_size: '1000',
                    sort_by: insightsSortBy === 'name' ? 'name' : insightsSortBy === 'created_at' ? 'created_at' : 'created_at',
                    sort_order: insightsSortOrder,
                });
                
                // Merge auto-filters with manual filters
                const allFilters = { ...insightsCurrentFilters, ...filters };
                Object.entries(allFilters).forEach(([key, value]) => {
                    if (value) params.append(key, value);
                });
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights?${params.toString()}`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) throw new Error('Failed to load insights');
                
                const data = await response.json();
                allInsights = data.items || [];
                renderInsights();
            } catch (error) {
                console.error('Error loading insights:', error);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="9" class="empty-state"><h3>Error loading insights</h3><p>' + escapeHtml(error.message) + '</p></td></tr>';
                }
            }
        }

        function renderInsights(insights) {
            const tbody = document.getElementById('insightsTableBody');
            if (!tbody) return;

            let filtered = [...(insights || allInsights)];

            // Apply search
            if (insightsSearchTerm) {
                const term = insightsSearchTerm.toLowerCase();
                filtered = filtered.filter(insight =>
                    insight.name?.toLowerCase().includes(term) ||
                    insight.description?.toLowerCase().includes(term)
                );
            }

            // Apply filters
            Object.entries(insightsFilters).forEach(([key, value]) => {
                if (value) {
                    filtered = filtered.filter(insight => {
                        // Filter logic (type filter removed)
                        return true;
                    });
                }
            });

            // Apply sorting
            filtered.sort((a, b) => {
                let aVal, bVal;
                if (insightsSortBy === 'name') {
                    aVal = a.name || '';
                    bVal = b.name || '';
                } else if (insightsSortBy === 'created_at') {
                    aVal = new Date(a.created_at).getTime();
                    bVal = new Date(b.created_at).getTime();
                } else {
                    return 0;
                }

                if (typeof aVal === 'string') {
                    return insightsSortOrder === 'asc' 
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else {
                    return insightsSortOrder === 'asc' ? aVal - bVal : bVal - aVal;
                }
            });

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="empty-state"><h3>No insights found</h3><p>Create your first insight to get started</p></td></tr>';
                return;
            }

            tbody.innerHTML = filtered.map(insight => {
                const createdDate = new Date(insight.created_at).toLocaleDateString();
                // Highlight search terms in insight name if there's a search term
                const insightName = toPascalCase(insight.name || '');
                const highlightedName = insightsSearchTerm ? highlightSearchTerms(insightName, insightsSearchTerm) : escapeHtml(insightName);

                return `
                    <tr data-insight-id="${insight.id}" onclick="SlideoutPanel.openInsightNotes('${insight.id}')" style="cursor: pointer;">
                        <td class="name-cell">
                            <div class="name-content" style="position: relative;">
                                <svg class="doc-icon" viewBox="0 0 16 16" fill="currentColor">
                                    <path d="M2.5 2.5h11l.5.5v10l-.5.5h-11l-.5-.5V3l.5-.5zM3 4v8h10V4H3zm2 1h6v1H5V5zm0 2h6v1H5V7zm0 2h4v1H5V9z"/>
                                </svg>
                                <span>${highlightedName}</span>
                                <button class="insight-open-btn-table" onclick="SlideoutPanel.openInsightNotes('${insight.id}')" title="Open in side peek" style="display: none;">
                                    <span style="font-size: 12px; margin-right: 4px;">OPEN</span>
                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="none" style="opacity: 0.6;">
                                        <rect x="4" y="4" width="8" height="8" stroke="currentColor" stroke-width="1.5" fill="none" rx="1"/>
                                        <path d="M6 2 L6 6 M10 2 L10 6 M2 6 L2 10 M2 6 L6 6 M10 6 L14 6 M14 6 L14 10" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                    </svg>
                                </button>
                            </div>
                        </td>
                        <td>${createdDate}</td>
                    </tr>
                `;
            }).join('');
        }

        function handleInsightsSearch() {
            const searchInput = document.getElementById('insightsSearchInput');
            insightsSearchTerm = searchInput?.value.trim() || '';
            updateInsightsSearchClearButton();
            renderInsights();
        }

        function updateInsightsSearchClearButton() {
            const searchInput = document.getElementById('insightsSearchInput');
            const clearButton = document.getElementById('insightsSearchClear');
            if (!searchInput || !clearButton) return;

            if (searchInput.value.trim() !== '') {
                clearButton.style.display = 'flex';
            } else {
                clearButton.style.display = 'none';
            }
        }

        function clearInsightsSearch() {
            const searchInput = document.getElementById('insightsSearchInput');
            if (!searchInput) return;

            searchInput.value = '';
            insightsSearchTerm = '';
            updateInsightsSearchClearButton();
            renderInsights();
            searchInput.focus();
        }

        function sortInsightsBy(column) {
            // Update sort indicators
            document.querySelectorAll('.notion-table th').forEach(th => {
                th.classList.remove('sorted');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            });

            const clickedTh = event.currentTarget;
            clickedTh.classList.add('sorted');
            const indicator = clickedTh.querySelector('.sort-indicator');

            if (insightsSortBy === column) {
                insightsSortOrder = insightsSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                insightsSortBy = column;
                insightsSortOrder = 'asc';
            }

            if (indicator) {
                indicator.textContent = insightsSortOrder === 'asc' ? '' : '';
            }

            renderInsights();
        }

        function updateInsightsFilterChips() {
            const chipsContainer = document.getElementById('insightsFilterChips');

            // Don't render filter chips - filters are shown as checkboxes in the dropdown
            if (chipsContainer) {
                chipsContainer.innerHTML = '';
            }
        }

        function removeInsightsFilter(key) {
            delete insightsFilters[key];
            updateInsightsFilterChips();
            renderInsights();
        }

        function resetInsightsFilters() {
            insightsFilters = {};
            insightsSearchTerm = '';
            const searchInput = document.getElementById('insightsSearchInput');
            if (searchInput) searchInput.value = '';
            updateInsightsSearchClearButton();
            updateInsightsFilterChips();
            renderInsights();
        }

        function openInsightsFilterMenu() {
            // Type filter removed
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function openCreateInsightModal() {
            // Build origin from current view context
            const origin = {
                origin_type: 'category', // Default
                project_name: currentProjectName || null,
                data_source: currentDataSourceId || null,
                dimension_ref: currentQuestionRefKey || null,
                dimension_name: null,
                category: null,
                topic_label: null,
                process_voc_id: null,
            };
            
            // Open create modal - for now, redirect to standalone page with context
            const params = new URLSearchParams({ client_uuid: currentClientId });
            if (currentQuestionRefKey) params.append('dimension_ref', currentQuestionRefKey);
            if (currentProjectName) params.append('project_name', currentProjectName);
            if (currentDataSourceId) params.append('data_source', currentDataSourceId);
            
            // Pass auth token via URL parameter (will be stored in localStorage on the new page)
            const token = getAuthToken();
            if (token) {
                params.append('auth_token', token);
            }
            
            // Use SPA navigation with hash routing
            const url = `${window.location.origin}${window.location.pathname}?${params.toString()}#/insights`;
            window.open(url, '_blank');
        }

        function editInsightFromView(insightId) {
            const params = new URLSearchParams({ client_uuid: currentClientId, insight_id: insightId });
            
            // Pass auth token via URL parameter
            const token = getAuthToken();
            if (token) {
                params.append('auth_token', token);
            }
            
            // Use SPA navigation with hash routing
            const url = `${window.location.origin}${window.location.pathname}?${params.toString()}#/insights`;
            window.open(url, '_blank');
        }

        // Update insights when view context changes
        const originalLoadDataSource = window.loadDataSource;
        if (typeof loadDataSource === 'function') {
            // Wrap to update insights after data loads
            const wrapper = async function(...args) {
                await originalLoadDataSource.apply(this, args);
                updateInsightsAutoFilter();
            };
            window.loadDataSource = wrapper;
        }

        // Context Menu Management
        let currentContextData = null;
        let contextMenuJustClicked = false;

        function showContextMenu(event, contextData) {
            event.preventDefault();
            event.stopPropagation();
            
            const contextMenu = document.getElementById('contextMenu');
            if (!contextMenu) return;
            
            currentContextData = contextData;
            contextMenuJustClicked = false;
            
            // Show/hide "Exclude Category" menu item based on context type
            const excludeCategoryItem = contextMenu.querySelector('[data-action="exclude-category"]');
            if (excludeCategoryItem) {
                if (contextData && contextData.type === 'category') {
                    excludeCategoryItem.style.display = 'block';
                } else {
                    excludeCategoryItem.style.display = 'none';
                }
            }
            
            // Position menu at cursor
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            
            // Ensure menu stays within viewport
            const rect = contextMenu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                contextMenu.style.left = `${window.innerWidth - rect.width - 10}px`;
            }
            if (rect.bottom > window.innerHeight) {
                contextMenu.style.top = `${window.innerHeight - rect.height - 10}px`;
            }
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            currentContextData = null;
            contextMenuJustClicked = false;
        }

        // Handle context menu item clicks and closing menu on click outside
        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            const isMenuVisible = contextMenu && contextMenu.style.display !== 'none';
            
            // Check if click is on a context menu item
            const item = e.target.closest('.context-menu-item');
            const clickedInMenu = contextMenu && contextMenu.contains(e.target);
            
            console.log('Click detected:', {
                isMenuVisible,
                clickedInMenu,
                item: !!item,
                target: e.target,
                targetClass: e.target.className,
                targetTag: e.target.tagName
            });
            
            if (item && isMenuVisible) {
                e.preventDefault();
                e.stopPropagation();
                contextMenuJustClicked = true;
                
                const action = item.getAttribute('data-action');
                console.log('=== CONTEXT MENU CLICK ===');
                console.log('Action:', action);
                console.log('Current context data:', currentContextData);
                console.log('Event target:', e.target);
                console.log('Closest item:', item);
                
                if (action === 'create-insight') {
                    console.log('Create insight action triggered');
                    if (currentContextData) {
                        console.log('Context data exists:', currentContextData);
                        // Save context data before hiding menu (which clears it)
                        // Use JSON parse/stringify to ensure deep copy
                        const savedContextData = JSON.parse(JSON.stringify(currentContextData));
                        console.log('Saved context data:', savedContextData);
                        // Use setTimeout to ensure click event completes
                        setTimeout(() => {
                            console.log('About to open slideout panel with saved data:', savedContextData);
                            hideContextMenu();
                            SlideoutPanel.openCreateInsight(savedContextData, true);
                        }, 10);
                    } else {
                        console.error('No context data available when clicking create insight');
                        alert('Error: No context data available. Please try right-clicking again.');
                    }
                } else if (action === 'exclude-category') {
                    console.log('=== EXCLUDE CATEGORY ACTION ===');
                    console.log('Current context data:', currentContextData);
                    if (currentContextData && currentContextData.type === 'category' && currentContextData.category) {
                        const categoryName = currentContextData.category;
                        console.log('Excluding category:', categoryName);
                        console.log('Current filterRules before update:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                            type: r.type,
                            mode: r.mode,
                            values: Array.from(r.values)
                        })))));
                        
                        // Find or create a category filter rule with mode 'exclude'
                        let existingRuleIndex = filterRules.findIndex(r => r.type === 'category');
                        console.log('Existing category rule index:', existingRuleIndex);
                        
                        if (existingRuleIndex >= 0) {
                            // Update existing rule
                            const existingRule = filterRules[existingRuleIndex];
                            console.log('Existing rule before update:', {
                                type: existingRule.type,
                                mode: existingRule.mode,
                                values: Array.from(existingRule.values)
                            });
                            // If mode is 'include', we need to switch to exclude mode
                            if (existingRule.mode === 'include') {
                                // Switch to exclude mode and clear existing selections
                                console.log('Switching from include to exclude mode');
                                existingRule.mode = 'exclude';
                                existingRule.values = new Set([categoryName]);
                            } else {
                                // Already in exclude mode, add the category to the set
                                console.log('Adding category to existing exclude rule');
                                existingRule.values.add(categoryName);
                            }
                            console.log('Existing rule after update:', {
                                type: existingRule.type,
                                mode: existingRule.mode,
                                values: Array.from(existingRule.values)
                            });
                        } else {
                            // Create new exclude rule
                            console.log('Creating new exclude rule');
                            filterRules.push({
                                type: 'category',
                                mode: 'exclude',
                                values: new Set([categoryName])
                            });
                        }
                        
                        console.log('FilterRules after update:', JSON.parse(JSON.stringify(filterRules.map(r => ({
                            type: r.type,
                            mode: r.mode,
                            values: Array.from(r.values)
                        })))));
                        console.log('Category rule values after update:', Array.from(filterRules.find(r => r.type === 'category')?.values || []));
                        console.log('availableCategories:', availableCategories);
                        
                        // Save filters for current dimension
                        saveFiltersForDimension(currentQuestionRefKey);
                        console.log('Saved filters for dimension:', currentQuestionRefKey);
                        
                        // Check filter dropdown state before updating
                        const filterDropdown = document.getElementById('filterDropdown');
                        const filterSelectionView = document.getElementById('filterSelectionView');
                        const filterTypeView = document.getElementById('filterTypeView');
                        const isDropdownVisible = filterDropdown && window.getComputedStyle(filterDropdown).display !== 'none';
                        const isSelectionViewVisible = filterSelectionView && window.getComputedStyle(filterSelectionView).display !== 'none';
                        const isTypeViewVisible = filterTypeView && window.getComputedStyle(filterTypeView).display !== 'none';
                        
                        console.log('Filter dropdown state:', {
                            filterDropdownExists: !!filterDropdown,
                            isDropdownVisible: isDropdownVisible,
                            filterSelectionViewExists: !!filterSelectionView,
                            isSelectionViewVisible: isSelectionViewVisible,
                            filterTypeViewExists: !!filterTypeView,
                            isTypeViewVisible: isTypeViewVisible,
                            currentFilterType: currentFilterType,
                            currentFilterSelections: Array.from(currentFilterSelections || [])
                        });
                        
                        // Update filter UI to show the active filter (this updates the badge)
                        updateFilterUI();
                        console.log('Called updateFilterUI()');
                        
                        // If filter dropdown is open and showing category filter selection view, refresh it
                        if (isDropdownVisible && isSelectionViewVisible) {
                            if (currentFilterType === 'category') {
                                console.log('Filter dropdown is open showing category filter - refreshing view');
                                // Refresh the filter selection view to show the newly added category as checked
                                showFilterSelectionView();
                                console.log('Called showFilterSelectionView()');
                            } else {
                                console.log('Filter dropdown is open but showing different filter type:', currentFilterType);
                                console.log('Setting currentFilterType to category and refreshing view');
                                // Set currentFilterType to category and refresh the view
                                currentFilterType = 'category';
                                showFilterSelectionView();
                                console.log('Called showFilterSelectionView() with category type');
                            }
                        } else if (isDropdownVisible && isTypeViewVisible) {
                            console.log('Filter dropdown is open but showing type view - just updating active filters list');
                            // If showing type view, updateFilterUI already refreshed the active filters list
                        } else {
                            console.log('Filter dropdown is not open or not showing selection view');
                            console.log('isDropdownVisible:', isDropdownVisible, 'isSelectionViewVisible:', isSelectionViewVisible);
                        }
                        
                        // Apply filters and re-render charts
                        console.log('Applying filters and re-rendering...');
                        applyFiltersAndRender();
                        console.log('Filters applied and charts re-rendered');
                        
                        // Hide the context menu
                        hideContextMenu();
                        console.log('Context menu hidden');
                    } else {
                        console.error('Invalid context data for exclude category action:', currentContextData);
                        alert('Error: Unable to exclude category. Please try right-clicking again.');
                    }
                } else {
                    console.warn('Unknown action:', action);
                }
                return; // Don't close menu when clicking menu item
            }
            
            // Close context menu on click outside
            if (isMenuVisible && !contextMenuJustClicked && !contextMenu.contains(e.target)) {
                hideContextMenu();
            }
            
            // Reset flag after processing
            if (contextMenuJustClicked) {
                contextMenuJustClicked = false;
            }
        });
        
        // Close context menu on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideContextMenu();
                const modal = document.getElementById('createInsightModal');
                if (modal && modal.style.display !== 'none') {
                    closeCreateInsightModal();
                }
            }
        });

        // Open create insight modal from context menu
        function openCreateInsightModalFromContext(contextData) {
            console.log('=== OPENING CREATE INSIGHT MODAL ===');
            console.log('Context data:', contextData);
            const modal = document.getElementById('createInsightModal');
            const form = document.getElementById('createInsightForm');
            console.log('Modal element:', modal);
            console.log('Form element:', form);
            
            if (!modal) {
                console.error('Modal element not found!');
                alert('Error: Modal element not found. Please check the console.');
                return;
            }
            if (!form) {
                console.error('Form element not found!');
                alert('Error: Form element not found. Please check the console.');
                return;
            }
            
            // Reset form
            form.reset();
            
            // Validate contextData
            if (!contextData) {
                console.error('contextData is null or undefined');
                alert('Error: Context data is missing. Please try right-clicking again.');
                return;
            }
            
            console.log('Creating origin from contextData:', contextData);
            
            // Pre-populate origin data
            const origin = {
                origin_type: contextData.type, // 'category' or 'topic'
                project_name: contextData.project_name || null,
                data_source: contextData.data_source || null,
                dimension_ref: contextData.dimension_ref || null,
                dimension_name: contextData.dimension_name || null,
                category: contextData.category || null,
                topic_label: contextData.topic_label || null,
                process_voc_id: null,
            };
            
            console.log('Created origin object:', origin);
            
            // Store origin for form submission
            window.currentInsightOrigin = origin;
            
            // Display origin preview
            const originPreview = document.getElementById('insightModalOriginPreview');
            if (originPreview) {
                const originText = [];
                if (origin.origin_type === 'category') {
                    originText.push(`<strong>Type:</strong> Category`);
                    if (origin.category) originText.push(`<strong>Category:</strong> ${escapeHtml(origin.category)}`);
                } else if (origin.origin_type === 'topic') {
                    originText.push(`<strong>Type:</strong> Topic`);
                    if (origin.category) originText.push(`<strong>Category:</strong> ${escapeHtml(origin.category)}`);
                    if (origin.topic_label) originText.push(`<strong>Topic:</strong> ${escapeHtml(origin.topic_label)}`);
                }
                if (origin.project_name) originText.push(`<strong>Project:</strong> ${escapeHtml(origin.project_name)}`);
                if (origin.data_source) originText.push(`<strong>Data Source:</strong> ${escapeHtml(origin.data_source)}`);
                if (origin.dimension_ref) {
                    const dimensionDisplay = origin.dimension_name || origin.dimension_ref;
                    originText.push(`<strong>Dimension:</strong> ${escapeHtml(dimensionDisplay)}`);
                }
                
                originPreview.innerHTML = originText.join('<br>') || 'No origin information';
            }
            
            // Show modal
            modal.style.display = 'flex';
            console.log('Modal should now be visible');
        }

        function closeCreateInsightModal() {
            console.log('Closing create insight modal');
            const modal = document.getElementById('createInsightModal');
            if (modal) {
                modal.style.display = 'none';
            }
            const form = document.getElementById('createInsightForm');
            if (form) {
                form.reset();
            }
            window.currentInsightOrigin = null;
        }
        
        // Make functions globally accessible
        window.closeCreateInsightModal = closeCreateInsightModal;
        window.openCreateInsightModalFromContext = openCreateInsightModalFromContext;

        async function handleCreateInsightSubmit(event) {
            event.preventDefault();
            
            if (!currentClientId) {
                alert('No client selected');
                return;
            }
            
            const name = document.getElementById('insightModalName').value.trim();
            const description = document.getElementById('insightModalDescription').value.trim() || null;
            
            if (!name) {
                alert('Please fill in required fields (Name)');
                return;
            }
            
            const origin = window.currentInsightOrigin;
            if (!origin) {
                alert('Origin information is missing');
                return;
            }
            
            const insightData = {
                name,
                type: '',
                application: '',
                description,
                origins: [origin],
            };
            
            try {
                const token = getAuthToken() || localStorage.getItem('visualizd_auth_token');
                if (!token) {
                    alert('You are not logged in. Please log in and try again.');
                    return;
                }
                
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };
                
                const response = await fetch(`${API_BASE_URL}/api/clients/${currentClientId}/insights`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(insightData),
                });
                
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { detail: response.statusText };
                    }
                    throw new Error(errorData.detail || `HTTP ${response.status}: Failed to create insight`);
                }
                
                // Success - close modal and refresh insights panel
                closeCreateInsightModal();
                
                // Always refresh insights list so new insight appears when navigating to insights tab
                // Check if insights section is visible to refresh it immediately
                const insightsSection = document.getElementById('insights-section');
                const isInsightsViewActive = insightsSection && insightsSection.classList.contains('active');
                
                console.log('[handleCreateInsightSubmit] Insights section check:', {
                    element: !!insightsSection,
                    isActive: isInsightsViewActive,
                    hasLoadInsightsPage: typeof loadInsightsPage === 'function',
                    hasLoadInsights: typeof loadInsights === 'function'
                });
                
                // Always try to refresh insights page first (for insights tab)
                if (typeof loadInsightsPage === 'function') {
                    console.log('[handleCreateInsightSubmit] Refreshing insights list via loadInsightsPage()');
                    loadInsightsPage();
                }
                
                // Also refresh the other insights view if it exists (for compatibility)
                if (typeof loadInsights === 'function') {
                    console.log('[handleCreateInsightSubmit] Refreshing insights list via loadInsights()');
                    loadInsights();
                }
                
                // Reset insights initialization flag so it can reload if needed
                if (window.insightsInitialized) {
                    window.insightsInitialized = false;
                }
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 12px 24px; border-radius: 6px; z-index: 10004; box-shadow: 0 4px 12px rgba(0,0,0,0.2);';
                successMsg.textContent = 'Insight created successfully!';
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);
                
            } catch (error) {
                console.error('Error creating insight:', error);
                alert('Error creating insight: ' + error.message);
            }
        }

        // Image Modal Functions
        function openImageModal(imageSrc) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('imageModalImg');
            
            if (modal && modalImg) {
                modalImg.src = imageSrc;
                modal.classList.add('active');
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) {
                modal.classList.remove('active');
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }
        
        // Close modal on backdrop click
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('createInsightModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeCreateInsightModal();
                    }
                });
            }
            
            // Set up image modal backdrop click
            const imageModal = document.getElementById('imageModal');
            const imageModalContent = imageModal?.querySelector('.image-modal-content');
            
            if (imageModal) {
                // Prevent clicks on content from closing modal
                if (imageModalContent) {
                    imageModalContent.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }
                
                // Close when clicking on overlay background
                imageModal.addEventListener('click', (e) => {
                    if (e.target === imageModal) {
                        closeImageModal();
                    }
                });
            }
            
            // Close image modal on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const imageModal = document.getElementById('imageModal');
                    if (imageModal && imageModal.classList.contains('active')) {
                        closeImageModal();
                    }
                }
            });
        });
    </script>
    
    <!-- Marketing site header -->
    <script src="/header.js"></script>
    
    <!-- Slideout Panel (AI Insights / Verbatims) -->
    <div id="slideoutTab" class="ai-insights-tab" style="display: none !important;">
        <span> AI Insights</span>
    </div>
    
    <div id="slideoutPanel" class="ai-insights-panel">
        <div class="ai-insights-header">
            <button id="slideoutBackButton" class="slideout-back-button" onclick="SlideoutPanel.navigateBack()" title="Back">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 4l-6 6 6 6"/>
                </svg>
            </button>
            <div style="flex: 1;">
                <div id="slideoutTitle" 
                     contenteditable="true" 
                     style="font-size: 1.5rem; font-weight: 600; font-family: 'Lato', sans-serif; color: oklch(0.145 0 0); outline: none; min-height: 1.75rem; line-height: 1.2;"
                     data-placeholder="Insight Title">AI-Generated Insights</div>
                <p id="slideoutSubtitle" class="overlay-subtitle" style="display: none; margin-top: 4px; font-size: 13px; color: #666;"></p>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <button id="slideoutSettingsBtn" class="settings-button" onclick="toggleSlideoutSettings()" title="Card Settings" style="display: none;">
                    <img src="https://neeuv3c4wu4qzcdw.public.blob.vercel-storage.com/icons/settings.svg" alt="Settings" width="18" height="18">
                </button>
                <button id="closeSlideoutPanel" class="ai-close-btn">&times;</button>
            </div>
        </div>
        
        <!-- Settings panel for verbatims -->
        <div id="slideoutSettingsPanel" class="settings-panel" style="display: none; margin-top: 12px; padding: 0 10px 10px 10px;">
            <!-- Metadata checkboxes will be dynamically generated here -->
        </div>
        
        <div id="slideoutContent" class="ai-insights-content">
            <!-- Content loaded dynamically -->
        </div>
    </div>
    
    <div id="slideoutOverlay" class="ai-insights-overlay"></div>
    
    <!-- Image Modal for Full-Size Image Viewing -->
    <div id="imageModal" class="image-modal-overlay">
        <div class="image-modal-content">
            <button class="image-modal-close" onclick="closeImageModal()" aria-label="Close image">&times;</button>
            <img id="imageModalImg" src="" alt="Full size image">
        </div>
    </div>
        </div> <!-- End visualizations-section -->

        <!-- Insights Section -->
        <div id="insights-section" class="spa-section">
            <div class="control-bar" style="position: relative;">
                <h1 style="margin: 0; font-size: 20px; font-weight: 600; color: #37352f; margin-right: 0.5rem;">Insights</h1>
                <div class="search-box insights-section-search">
                    <input
                        type="text"
                        id="searchInput"
                        placeholder="Search insights..."
                        oninput="handleSearch()"
                        onfocus="updateInsightsSectionSearchClearButton()"
                    >
                    <button
                        id="insightsSectionSearchClear"
                        onclick="clearInsightsSectionSearch()"
                        title="Clear search"
                        style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 0; display: none; color: #666; font-size: 20px; line-height: 1; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 3px;"
                    >&times;</button>
                </div>
                <div class="filter-chips" id="filterChips"></div>
                <div style="position: relative;">
                    <button class="filter-button" onclick="toggleFilterMenu(event)" id="filterMenuBtn" type="button" aria-label="Open filters">
                        <img src="/static/images/filter_list.svg" alt="" aria-hidden="true">
                        <span id="insightsListFilterBadge" class="filter-badge" aria-hidden="true"></span>
                    </button>
                    
                    <!-- Filter Dropdown Menu -->
                    <div class="filter-dropdown" id="filterDropdown">
                        <div class="filter-dropdown-search">
                            <input type="text" id="filterSearchInput" placeholder="Filter by..." oninput="filterFilterOptions()">
                        </div>
                        <div class="filter-dropdown-list" id="filterOptionsList">
                            <!-- Filter options will be populated here -->
                        </div>
                        <div class="filter-active-filters" id="activeFiltersSection" style="display: none;">
                            <div class="filter-active-filters-title">Active filters</div>
                            <div id="activeFiltersList"></div>
                        </div>
                    </div>
                </div>
                <button class="btn-delete" onclick="deleteSelectedInsights()" id="insightsSectionDeleteBtn" style="display: none;">Delete Selected</button>
                <button class="btn-new" onclick="openCreateModal()">+ New</button>
            </div>
            
            <!-- Filter Value Selection Dialog -->
            <div class="filter-dialog-overlay" id="filterDialogOverlay" onclick="closeFilterValueDialog()"></div>
            <div class="filter-value-dialog" id="filterValueDialog">
                <div class="filter-value-dialog-header">
                    <div class="filter-value-dialog-title" id="filterValueDialogTitle">Select value</div>
                    <button class="filter-value-dialog-close" onclick="closeFilterValueDialog()">&times;</button>
                </div>
                <div class="filter-value-dialog-body" id="filterValueDialogBody">
                    <!-- Filter value options will be populated here -->
                </div>
            </div>

            <div class="table-container">
                <table class="notion-table">
                    <thead>
                        <tr>
                            <th class="name-cell sorted draggable" data-column="name" draggable="true" onclick="sortBy('name')">
                                <span>Name</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="status" draggable="true" onclick="sortBy('status')">
                                <span>Status</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="origin" draggable="true" onclick="sortBy('origin')">
                                <span>Origin</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="draggable" data-column="created_at" draggable="true" onclick="sortBy('created_at')">
                                <span>Created</span>
                                <span class="sort-indicator"></span>
                            </th>
                            <th class="actions-cell">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="insightsPageTableBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Slideout Panel for Insight Notes -->
        <!-- Removed: insightNotesPanel and insightNotesOverlay - now using slideoutPanel and slideoutOverlay -->

        <!-- Create/Edit Modal -->
        <div id="insightModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalTitle">Create Insight</h2>
                    <button class="close-btn" onclick="closeModal()"></button>
                </div>
                <form id="insightForm" onsubmit="saveInsight(event)">
                    <div class="form-group">
                        <label>Insight Name *</label>
                        <input type="text" id="insightName" required>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="insightDescription" placeholder="Detailed description"></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn-secondary" onclick="closeModal()">Cancel</button>
                        <button type="submit" class="btn-save">Save</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- End insights-section -->
</body>
</html>


